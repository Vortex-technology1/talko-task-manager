<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#22c55e">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="TALKO Tasks">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icons/icon-192x192.png">
    <link rel="apple-touch-icon" sizes="152x152" href="icons/icon-152x152.png">
    <link rel="apple-touch-icon" sizes="192x192" href="icons/icon-192x192.png">
    <link rel="icon" type="image/png" sizes="96x96" href="icons/icon-96x96.png">
    <link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192x192.png">
    <title>TALKO System - Таск Менеджер Pro</title>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-storage-compat.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    <script src="https://apis.google.com/js/api.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --primary: #22c55e;
            --primary-dark: #16a34a;
            --success: #22c55e;
            --warning: #f59e0b;
            --danger: #ef4444;
            --info: #3b82f6;
            --dark: #1a1a1a;
            --gray: #525252;
            --light: #ffffff;
            --white: #ffffff;
            --shadow: 0 2px 10px rgba(0,0,0,0.08);
            --shadow-lg: 0 10px 40px rgba(0,0,0,0.12);
            --radius: 16px;
            --radius-sm: 8px;
            --header-bg: #0d1f0d;
        }
        
        /* SVG Icon styles */
        .icon {
            width: 18px;
            height: 18px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            vertical-align: middle;
        }
        .icon svg {
            width: 100%;
            height: 100%;
            stroke-width: 2;
        }
        .icon-sm { width: 14px; height: 14px; }
        .icon-lg { width: 22px; height: 22px; }
        .icon-xl { width: 28px; height: 28px; }
        
        .btn .icon, .tab-btn .icon { margin-right: 6px; }
        .action-btn .icon { margin: 0; }
        
        body { 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            background: #f9fafb; 
            color: var(--dark);
            min-height: 100vh;
            overflow-x: hidden;
            -webkit-text-size-adjust: 100%;
        }
        
        * { -webkit-tap-highlight-color: transparent; }
        
        .header { 
            background: var(--header-bg); 
            color: white; 
            padding: 0.75rem 1rem; 
            box-shadow: var(--shadow);
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .header-content { 
            max-width: 1400px; 
            margin: 0 auto; 
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        
        .logo { font-size: 1.1rem; font-weight: 700; display: flex; align-items: center; gap: 0.5rem; }
        .header-actions { display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap; }
        .notification-bell:hover { background: #f3f4f6 !important; }
        
        .header-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 20px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .header-btn:hover { background: rgba(255,255,255,0.3); }
        
        .header-ai-btn {
            background: rgba(255,255,255,0.2);
            color: white;
            padding: 0.4rem 0.6rem;
            border-radius: 15px;
            font-size: 0.75rem;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 0.3rem;
            transition: all 0.2s;
        }
        
        .header-ai-btn:hover { background: rgba(255,255,255,0.35); transform: translateY(-1px); }
        .header-ai-btn.tech { background: rgba(46, 204, 113, 0.3); }
        .header-ai-btn.tech:hover { background: rgba(46, 204, 113, 0.5); }
        
        .lang-switcher {
            display: flex;
            background: rgba(255,255,255,0.2);
            border-radius: 15px;
            overflow: hidden;
        }
        
        .lang-btn {
            background: transparent;
            border: none;
            color: rgba(255,255,255,0.7);
            padding: 0.3rem 0.5rem;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .lang-btn.active {
            background: rgba(255,255,255,0.3);
            color: white;
            font-weight: 600;
        }
        
        .lang-btn:hover { color: white; }
        
        .user-info {
            display: none;
            background: rgba(255,255,255,0.2);
            padding: 0.4rem 0.8rem;
            border-radius: 20px;
            font-size: 0.85rem;
            transition: background 0.2s;
        }
        
        .user-info:hover {
            background: rgba(255,255,255,0.35);
        }
        
        .mobile-logout-btn { display: none; }
        
        .container { max-width: 1400px; margin: 0 auto; padding: 1rem; overflow-x: hidden; }
        
        .tab-navigation { 
            display: flex; 
            background: var(--white); 
            border-radius: var(--radius) var(--radius) 0 0; 
            box-shadow: var(--shadow);
            overflow-x: auto;
            scrollbar-width: none;
        }
        
        .tab-navigation::-webkit-scrollbar { display: none; }
        
        .tab-btn { 
            background: transparent; 
            border: none; 
            padding: 0.9rem 1rem; 
            cursor: pointer; 
            font-size: 0.8rem; 
            font-weight: 500; 
            color: var(--gray); 
            border-bottom: 3px solid transparent; 
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        .tab-btn:hover { color: var(--dark); background: rgba(34, 197, 94, 0.05); }
        .tab-btn.active { color: var(--primary); border-bottom-color: var(--primary); font-weight: 600; }
        
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        /* MY DAY STYLES */
        .myday-header {
            background: linear-gradient(135deg, #fef3c7, #fef9c3);
            padding: 1.25rem;
            border-radius: var(--radius);
            margin-bottom: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }
        .myday-date {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .myday-date h2 {
            font-size: 1.25rem;
            margin: 0;
            color: var(--dark);
        }
        .myday-date-text {
            color: var(--gray);
            font-size: 0.9rem;
        }
        .myday-progress {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .myday-progress-bar {
            width: 120px;
            height: 8px;
            background: rgba(0,0,0,0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        .myday-progress-fill {
            height: 100%;
            background: var(--success);
            border-radius: 4px;
            transition: width 0.3s;
        }
        .myday-progress-text {
            font-weight: 600;
            color: var(--dark);
            font-size: 0.9rem;
        }
        .myday-content {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            padding-bottom: 100px; /* Space for bottom nav */
        }
        .myday-section {
            background: white;
            border-radius: var(--radius);
            padding: 1rem;
            box-shadow: var(--shadow);
        }
        .myday-section-title {
            font-size: 0.85rem;
            color: var(--gray);
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .myday-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 1rem;
            border-radius: var(--radius-sm);
            background: #f9fafb;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 60px; /* Touch-friendly height */
            -webkit-tap-highlight-color: transparent;
            border-left: 3px solid transparent;
        }
        .myday-item:last-child { margin-bottom: 0; }
        .myday-item:hover { background: #f0fdf4; }
        .myday-item:active { 
            background: #dcfce7; 
            transform: scale(0.98);
        }
        .myday-item.done {
            background: #f0fdf4;
            opacity: 0.7;
        }
        .myday-item.done .myday-item-title {
            text-decoration: line-through;
            color: var(--gray);
        }
        .myday-item.overdue {
            background: #fef2f2;
            border-left: 4px solid var(--danger);
        }
        .myday-checkbox {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid #d1d5db;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            cursor: pointer;
            transition: all 0.2s;
            -webkit-tap-highlight-color: transparent;
        }
        .myday-checkbox:hover { border-color: var(--success); }
        .myday-checkbox:active { 
            transform: scale(0.9); 
            background: #dcfce7;
        }
        .myday-checkbox.checked {
            background: var(--success);
            border-color: var(--success);
            color: white;
        }
        .myday-item-content {
            flex: 1;
            min-width: 0;
        }
        .myday-item-title {
            font-weight: 500;
            color: var(--dark);
            margin-bottom: 0.25rem;
            font-size: 0.95rem;
            line-height: 1.3;
        }
        .myday-item-meta {
            font-size: 0.8rem;
            color: var(--gray);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        .myday-item-time {
            background: #e5e7eb;
            padding: 0.2rem 0.6rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
        }
        .myday-item-tag {
            font-size: 0.7rem;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            background: #dbeafe;
            color: #1d4ed8;
        }
        .myday-item-tag.regular {
            background: #f3e8ff;
            color: #7c3aed;
        }
        .myday-empty {
            text-align: center;
            padding: 3rem 1rem;
            color: var(--gray);
        }
        .myday-empty-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }
        .myday-all-done {
            text-align: center;
            padding: 2rem 1rem;
            background: linear-gradient(135deg, #dcfce7, #d1fae5);
            border-radius: var(--radius);
        }
        .myday-all-done-icon {
            font-size: 3rem;
            margin-bottom: 0.5rem;
        }
        .myday-all-done h3 {
            color: var(--success);
            margin-bottom: 0.25rem;
        }
        .myday-refresh-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            background: rgba(0,0,0,0.05);
            color: var(--gray);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            -webkit-tap-highlight-color: transparent;
        }
        .myday-refresh-btn:hover {
            background: rgba(0,0,0,0.1);
            color: var(--dark);
        }
        .myday-refresh-btn:active {
            transform: scale(0.9);
        }
        .myday-refresh-btn.spinning .icon {
            animation: spin 0.5s linear;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        /* Mobile optimizations for My Day */
        @media (max-width: 767px) {
            .myday-header {
                padding: 1rem;
                margin: 0 -0.5rem 1rem -0.5rem;
                border-radius: 0;
                flex-direction: column;
                align-items: flex-start;
            }
            .myday-date h2 {
                font-size: 1.1rem;
            }
            .myday-progress {
                width: 100%;
                justify-content: space-between;
            }
            .myday-progress-bar {
                flex: 1;
                max-width: none;
                width: auto;
            }
            .myday-section {
                border-radius: var(--radius-sm);
                padding: 0.75rem;
            }
            .myday-item {
                padding: 1rem;
                gap: 0.625rem;
                margin-bottom: 0.35rem;
            }
            .myday-item:active { 
                background: #dcfce7; 
                transform: scale(0.98);
                transition: all 0.1s;
            }
            .myday-item-title {
                font-size: 0.9rem;
            }
            .myday-checkbox {
                width: 36px;
                height: 36px;
                /* Expanded touch target */
                position: relative;
            }
            .myday-checkbox::before {
                content: '';
                position: absolute;
                top: -6px; right: -6px; bottom: -6px; left: -6px;
            }
        }
        
        .controls { 
            background: var(--white); 
            padding: 1rem; 
            border-radius: 0 0 var(--radius) var(--radius); 
            box-shadow: var(--shadow); 
            margin-bottom: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        
        .controls-row { display: flex; flex-wrap: wrap; gap: 0.5rem; }
        
        .btn { 
            background: var(--info); 
            color: white; 
            border: none; 
            padding: 0.7rem 1rem; 
            border-radius: var(--radius-sm); 
            cursor: pointer; 
            font-size: 0.85rem; 
            font-weight: 500;
            min-height: 44px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.4rem;
            transition: all 0.2s;
        }
        
        .btn:hover { transform: translateY(-1px); box-shadow: var(--shadow); }
        .btn:active { transform: translateY(0); }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }
        .btn-success { background: var(--success); color: white; }
        .btn-success:hover { background: var(--primary-dark); }
        .btn-danger { background: var(--danger); color: white; }
        .btn-warning { background: var(--warning); color: white; }
        .btn-clear { background: var(--gray); color: white; }
        .btn-outline { background: transparent; border: 2px solid var(--primary); color: var(--primary); }
        .btn-outline:hover { background: var(--primary); color: white; }
        .btn-dark { background: var(--dark); color: white; }
        .btn-small { padding: 0.4rem 0.6rem; font-size: 0.8rem; min-height: 36px; }
        
        .btn-google {
            background: white;
            color: #444;
            border: 2px solid #e5e7eb;
            font-weight: 600;
        }
        
        .btn-google:hover {
            background: #f9fafb;
            border-color: #d1d5db;
        }
        
        .btn-google img {
            width: 20px;
            height: 20px;
        }
        
        .filters { display: flex; flex-wrap: wrap; gap: 0.5rem; width: 100%; }
        
        .filter-select { 
            padding: 0.6rem; 
            border: 2px solid #e5e7eb; 
            border-radius: var(--radius-sm); 
            background: var(--white); 
            font-size: 0.85rem;
            min-height: 44px;
            flex: 1;
            min-width: 100px;
        }
        
        .filter-select:focus { outline: none; border-color: var(--info); }
        
        /* Status multi-select dropdown */
        .status-multiselect {
            position: relative;
            flex: 1;
            min-width: 100px;
        }
        .status-multiselect-toggle {
            padding: 0.6rem;
            border: 2px solid #e5e7eb;
            border-radius: var(--radius-sm);
            background: var(--white);
            font-size: 0.85rem;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.4rem;
            cursor: pointer;
            transition: border-color 0.2s;
            user-select: none;
        }
        .status-multiselect-toggle:hover { border-color: #bbb; }
        .status-multiselect-toggle.open { border-color: var(--info); }
        .status-multiselect-label {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: var(--dark);
            font-size: 0.85rem;
        }
        .status-multiselect-label.placeholder { color: var(--gray); }
        .status-multiselect-arrow { transition: transform 0.2s; flex-shrink: 0; }
        .status-multiselect-toggle.open .status-multiselect-arrow { transform: rotate(180deg); }
        .status-multiselect-count {
            background: var(--primary);
            color: white;
            font-size: 0.7rem;
            font-weight: 600;
            padding: 0.1rem 0.45rem;
            border-radius: 10px;
            flex-shrink: 0;
        }
        .status-multiselect-dropdown {
            display: none;
            position: absolute;
            top: calc(100% + 4px);
            left: 0;
            right: 0;
            min-width: 180px;
            background: var(--white);
            border: 2px solid #e5e7eb;
            border-radius: var(--radius-sm);
            box-shadow: var(--shadow-lg);
            z-index: 200;
            padding: 0.35rem 0;
            animation: statusDropFade 0.15s ease;
        }
        .status-multiselect-dropdown.show { display: block; }
        @keyframes statusDropFade {
            from { opacity: 0; transform: translateY(-6px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .status-multiselect-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.55rem 0.75rem;
            cursor: pointer;
            font-size: 0.85rem;
            transition: background 0.15s;
            user-select: none;
        }
        .status-multiselect-item:hover { background: #f0fdf4; }
        .status-multiselect-item input[type="checkbox"] {
            width: 17px;
            height: 17px;
            accent-color: var(--primary);
            cursor: pointer;
            flex-shrink: 0;
        }
        .status-multiselect-all {
            border-bottom: 1px solid #e5e7eb;
            font-weight: 500;
            padding-bottom: 0.6rem;
            margin-bottom: 0.15rem;
        }
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .tasks-container, .cards-grid {
            background: var(--white);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            overflow: hidden;
        }
        
        .cards-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 0.75rem;
            padding: 1rem;
        }
        
        .task-card, .function-card, .user-card {
            padding: 1rem;
            border-bottom: 1px solid #e5e7eb;
            transition: all 0.2s;
        }
        
        .function-card, .user-card {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: var(--radius);
        }
        
        .task-card:last-child { border-bottom: none; }
        .task-card:hover, .function-card:hover, .user-card:hover { background: #f9fafb; border-color: var(--primary); }
        
        /* Process Board Styles */
        .process-board-container {
            overflow-x: auto;
            padding-bottom: 1rem;
        }
        
        .process-board {
            display: flex;
            flex-direction: column;
            gap: 0;
            padding: 0;
        }
        
        /* Pipeline row — один процес на рядок */
        .process-pipeline-row {
            background: white;
            border-radius: 12px;
            padding: 1rem 1.25rem;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid #e5e7eb;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        
        .process-pipeline-row:hover {
            box-shadow: 0 4px 16px rgba(0,0,0,0.08);
            border-color: #d1d5db;
        }
        
        .process-pipeline-row.overdue {
            border-left: 4px solid var(--danger);
            background: #fef8f8;
        }
        
        .process-pipeline-row.completed {
            opacity: 0.7;
            border-left: 4px solid var(--primary);
            background: #f0fdf4;
        }
        
        .process-row-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
        }
        
        .process-row-title {
            font-weight: 700;
            font-size: 0.95rem;
            color: var(--dark);
            flex: 1;
            min-width: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .process-row-meta {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 0.8rem;
            color: var(--gray);
            flex-shrink: 0;
        }
        
        .process-row-meta span {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            white-space: nowrap;
        }
        
        .process-row-meta .overdue-badge {
            color: var(--danger);
            font-weight: 600;
        }
        
        .process-row-percent {
            font-weight: 700;
            font-size: 0.85rem;
            color: var(--primary);
            min-width: 36px;
            text-align: right;
        }
        
        .process-row-percent.complete {
            color: var(--primary);
        }
        
        /* Pipeline steps — горизонтальний рядок етапів */
        .process-pipeline-steps {
            display: flex;
            gap: 2px;
            align-items: stretch;
            position: relative;
        }
        
        .pipeline-step {
            flex: 1;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0.4rem 0.25rem;
            border-radius: 6px;
            background: #f3f4f6;
            transition: all 0.2s;
            min-width: 0;
        }
        
        .pipeline-step.done {
            background: var(--primary);
        }
        
        .pipeline-step.active {
            background: #3b82f6;
            box-shadow: 0 0 0 2px white, 0 0 0 4px #3b82f6;
            z-index: 1;
        }
        
        .pipeline-step.pending {
            background: #e5e7eb;
        }
        
        .pipeline-step-label {
            font-size: 0.65rem;
            font-weight: 500;
            color: white;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
            line-height: 1.2;
        }
        
        .pipeline-step.pending .pipeline-step-label {
            color: #9ca3af;
        }
        
        .pipeline-step.done .pipeline-step-label,
        .pipeline-step.active .pipeline-step-label {
            color: white;
        }
        
        /* Стрілки між кроками */
        .pipeline-arrow {
            flex-shrink: 0;
            width: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #d1d5db;
            font-size: 0.7rem;
        }
        
        /* Assignee badge */
        .process-row-assignee {
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
            background: #eff6ff;
            color: #1d4ed8;
            padding: 0.15rem 0.5rem;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 500;
        }
        
        /* Mobile: vertical stacked layout */
        @media (max-width: 767px) {
            .process-board {
                flex-direction: column;
                min-width: unset;
                width: 100%;
            }
            .process-board-container {
                overflow-x: hidden;
            }
            .process-pipeline-row {
                padding: 0.75rem;
                border-radius: 10px;
            }
            .process-row-top {
                flex-wrap: wrap;
            }
            .process-row-meta {
                flex-wrap: wrap;
                gap: 0.5rem;
            }
            .pipeline-step-label {
                font-size: 0.55rem;
            }
        }
        
        /* ===================== */
        /* PROJECTS             */
        /* ===================== */
        .projects-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 1rem;
        }
        
        .project-card {
            background: white;
            border-radius: 12px;
            padding: 1.25rem;
            border: 1px solid #e5e7eb;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }
        
        .project-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
        }
        
        .project-card:hover {
            box-shadow: 0 8px 24px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }
        
        .project-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0.75rem;
        }
        
        .project-card-title {
            font-weight: 700;
            font-size: 1rem;
            color: var(--dark);
            line-height: 1.3;
        }
        
        .project-card-status {
            font-size: 0.7rem;
            font-weight: 600;
            padding: 0.15rem 0.5rem;
            border-radius: 6px;
            white-space: nowrap;
        }
        
        .project-card-status.active { background: #dcfce7; color: #16a34a; }
        .project-card-status.paused { background: #fef3c7; color: #d97706; }
        .project-card-status.completed { background: #e0e7ff; color: #4338ca; }
        
        .project-card-desc {
            font-size: 0.8rem;
            color: var(--gray);
            margin-bottom: 0.75rem;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        
        .project-card-stats {
            display: flex;
            gap: 1rem;
            font-size: 0.75rem;
            color: var(--gray);
            margin-bottom: 0.75rem;
        }
        
        .project-card-stats span {
            display: flex;
            align-items: center;
            gap: 0.2rem;
        }
        
        .project-progress-bar {
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            overflow: hidden;
        }
        
        .project-progress-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s;
        }
        
        .project-progress-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            color: var(--gray);
            margin-top: 0.25rem;
        }
        
        .project-card-deadline {
            font-size: 0.75rem;
            margin-top: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        
        .project-card-deadline.overdue { color: var(--danger); font-weight: 600; }
        
        /* Project list view */
        .projects-list-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
        }
        
        .projects-list-table th {
            text-align: left;
            padding: 0.75rem 1rem;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--gray);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            border-bottom: 2px solid #e5e7eb;
        }
        
        .projects-list-table td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #f0f0f0;
            font-size: 0.85rem;
            cursor: pointer;
        }
        
        .projects-list-table tr:hover td {
            background: #f9fafb;
        }
        
        /* Project timeline view */
        .project-timeline {
            position: relative;
            padding: 1rem 0;
        }
        
        .timeline-header {
            display: flex;
            border-bottom: 2px solid #e5e7eb;
            margin-bottom: 0.5rem;
        }
        
        .timeline-header-label {
            flex: 1;
            text-align: center;
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--gray);
            padding: 0.25rem;
        }
        
        .timeline-row {
            display: flex;
            align-items: center;
            height: 40px;
            margin-bottom: 4px;
            position: relative;
        }
        
        .timeline-row-label {
            width: 180px;
            flex-shrink: 0;
            font-size: 0.8rem;
            font-weight: 600;
            padding-right: 1rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
        }
        
        .timeline-row-bar-area {
            flex: 1;
            position: relative;
            height: 100%;
        }
        
        .timeline-bar {
            position: absolute;
            height: 24px;
            top: 8px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            padding: 0 0.5rem;
            font-size: 0.65rem;
            color: white;
            font-weight: 600;
            overflow: hidden;
            white-space: nowrap;
        }
        
        .timeline-bar-progress {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            border-radius: 4px;
            opacity: 0.3;
            background: white;
        }
        
        /* Project detail — board/kanban */
        .project-detail-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            gap: 0.75rem;
        }
        
        .project-detail-back {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            font-weight: 600;
            color: var(--dark);
            font-size: 1.1rem;
        }
        
        .project-detail-back:hover { color: var(--primary); }
        
        .project-board-columns {
            display: flex;
            gap: 1rem;
            overflow-x: auto;
            padding-bottom: 1rem;
        }
        
        .project-board-col {
            min-width: 260px;
            max-width: 300px;
            flex-shrink: 0;
            background: #f3f4f6;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            max-height: calc(100vh - 280px);
        }
        
        .project-board-col-header {
            padding: 0.75rem 1rem;
            font-weight: 600;
            font-size: 0.85rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #e5e7eb;
        }
        
        .project-board-col-cards {
            padding: 0.5rem;
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
        }
        
        .project-task-card {
            background: white;
            border-radius: 8px;
            padding: 0.65rem 0.75rem;
            cursor: pointer;
            border-left: 3px solid #e5e7eb;
            font-size: 0.85rem;
            transition: box-shadow 0.2s;
        }
        
        .project-task-card:hover { box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .project-task-card.priority-high { border-left-color: #ef4444; }
        .project-task-card.priority-medium { border-left-color: #f59e0b; }
        .project-task-card.priority-low { border-left-color: #22c55e; }
        
        .project-task-card-title { font-weight: 500; margin-bottom: 0.25rem; }
        .project-task-card-meta { font-size: 0.7rem; color: var(--gray); display: flex; gap: 0.5rem; }
        
        /* Color dot for project color picker */
        input[name="projectColor"]:checked + .color-dot {
            border-color: var(--dark) !important;
            box-shadow: 0 0 0 2px white, 0 0 0 4px var(--dark);
        }
        
        @media (max-width: 767px) {
            .projects-grid { grid-template-columns: 1fr; }
            .project-board-columns { flex-direction: column; }
            .project-board-col { min-width: unset; max-width: unset; max-height: none; }
            .timeline-row-label { width: 100px; font-size: 0.7rem; }
        }

        .process-template-step {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem;
            background: #f9fafb;
            border-radius: 8px;
            margin-bottom: 0.5rem;
        }
        
        .process-template-step .step-number {
            width: 28px;
            height: 28px;
            background: var(--primary);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 0.85rem;
            flex-shrink: 0;
        }
        
        .process-template-step .step-arrow {
            color: var(--gray);
            margin-left: auto;
        }
        
        .process-steps-builder {
            border: 2px dashed #e5e7eb;
            border-radius: 12px;
            padding: 1rem;
            min-height: 120px;
        }
        
        .process-steps-builder.drag-over {
            border-color: var(--primary);
            background: #f0fdf4;
        }
        
        .add-step-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.75rem;
            border: 2px dashed #d1d5db;
            border-radius: 8px;
            color: var(--gray);
            cursor: pointer;
            transition: all 0.2s;
            background: transparent;
            width: 100%;
            font-size: 0.9rem;
        }
        
        .add-step-btn:hover {
            border-color: var(--primary);
            color: var(--primary);
            background: #f0fdf4;
        }
        
        /* (process-card removed — replaced by pipeline rows) */
        
        .task-card.pinned {
            background: linear-gradient(90deg, rgba(34, 197, 94, 0.08) 0%, var(--white) 100%);
            border-left: 4px solid var(--primary);
        }
        
        .task-card-header, .function-header, .user-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }
        
        .task-title, .function-title, .user-name { font-weight: 600; font-size: 0.95rem; flex: 1; color: var(--dark); }
        
        .pin-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 0.9rem;
            color: #d1d5db;
            padding: 0.2rem;
        }
        
        .pin-btn:hover, .pin-btn.pinned { color: var(--warning); }
        
        .task-meta, .function-description, .user-details {
            font-size: 0.8rem;
            color: var(--gray);
            margin-bottom: 0.5rem;
            line-height: 1.4;
        }
        
        .task-meta { display: flex; flex-wrap: wrap; gap: 0.5rem; }
        .task-meta-item { display: flex; align-items: center; gap: 0.2rem; }
        
        .task-badges, .function-assignees { display: flex; flex-wrap: wrap; gap: 0.4rem; margin-bottom: 0.5rem; }
        
        .badge, .assignee-badge, .role-badge {
            padding: 0.2rem 0.5rem;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 500;
        }
        
        .badge-new { background: #eff6ff; color: #2563eb; }
        .badge-progress { background: #fef3c7; color: #d97706; }
        .badge-review { background: #fae8ff; color: #a855f7; }
        .badge-done { background: #f0fdf4; color: #16a34a; }
        .badge-high { background: #fef2f2; color: #dc2626; }
        .badge-medium { background: #fef3c7; color: #d97706; }
        .badge-low { background: #f0fdf4; color: #16a34a; }
        
        .assignee-badge { background: var(--primary); color: white; }
        .assignee-badge.head { background: var(--warning); }
        
        .role-badge { color: white; }
        .role-badge.owner { background: var(--danger); }
        .role-badge.manager { background: var(--warning); }
        .role-badge.employee { background: var(--info); }
        
        .task-actions, .function-stats, .user-stats { 
            display: flex; 
            gap: 0.4rem; 
            justify-content: flex-end;
            padding-top: 0.5rem;
        }
        
        .task-deadline-row {
            display: flex;
            gap: 0.75rem;
            align-items: center;
            font-size: 0.85rem;
            padding: 0.5rem 0;
            flex-wrap: wrap;
        }
        
        .task-deadline-row.overdue-text { color: #e74c3c; font-weight: 600; }
        .task-deadline-row.today-text { color: #2980b9; font-weight: 600; }
        
        .time-badge {
            background: #e8f4fd;
            color: #2980b9;
            padding: 0.15rem 0.5rem;
            border-radius: 10px;
            font-size: 0.75rem;
            font-weight: 500;
        }
        
        .task-detail {
            font-size: 0.8rem;
            color: #555;
            padding: 0.4rem 0.6rem;
            background: #f8f9fa;
            border-radius: 6px;
            margin-top: 0.4rem;
            line-height: 1.4;
        }
        
        .task-detail strong { color: #333; }
        
        .task-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 0.5rem;
            margin-top: 0.5rem;
            border-top: 1px solid #ecf0f1;
        }
        
        .task-created {
            font-size: 0.7rem;
            color: #95a5a6;
        }
        
        .regular-schedule {
            font-size: 0.85rem;
            color: #2980b9;
            font-weight: 500;
            margin-bottom: 0.5rem;
            padding: 0.3rem 0.6rem;
            background: #e8f4fd;
            border-radius: 6px;
            display: inline-block;
        }
        
        .instruction-preview {
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .instruction-preview:hover {
            background: #e8f4fd;
        }
        
        .task-card.overdue {
            border-left: 4px solid #e74c3c;
            background: linear-gradient(90deg, rgba(231, 76, 60, 0.05) 0%, var(--white) 100%);
        }
        
        .task-card.today {
            border-left: 4px solid #3498db;
            background: linear-gradient(90deg, rgba(52, 152, 219, 0.05) 0%, var(--white) 100%);
        }
        
        .total-time-badge {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 500;
        }
        
        .total-time-container {
            padding: 0.5rem 1rem;
            text-align: right;
        }
        
        .filters-row {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            align-items: center;
        }
        
        .btn-clear {
            background: #95a5a6;
        }
        
        /* Table styles */
        .table-container {
            background: var(--white);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            overflow-x: auto;
        }
        
        .tasks-table {
            width: 100%;
            border-collapse: collapse;
            min-width: 800px;
        }
        
        .tasks-table th {
            background: #34495e;
            color: white;
            padding: 1rem;
            text-align: left;
            font-weight: 500;
            font-size: 0.85rem;
            position: relative;
            user-select: none;
        }
        .tasks-table th.sortable { cursor: pointer; }
        .tasks-table th.sortable:hover { background: #2c3e50; }
        .tasks-table th .sort-icon { opacity: 0.4; margin-left: 4px; font-size: 0.75rem; }
        .tasks-table th.sort-active .sort-icon { opacity: 1; }
        .tasks-table th .col-resize-handle {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 6px;
            cursor: col-resize;
            background: transparent;
            z-index: 1;
        }
        .tasks-table th .col-resize-handle:hover,
        .tasks-table th .col-resize-handle.resizing { background: rgba(255,255,255,0.3); }
        
        .tasks-table td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #ecf0f1;
            font-size: 0.85rem;
        }
        
        .tasks-table tr:hover {
            background: #f8f9fa;
        }
        
        .tasks-table .task-title-cell {
            max-width: 250px;
        }
        
        .tasks-table .task-title-text {
            font-weight: 500;
            color: var(--dark);
            cursor: pointer;
            transition: color 0.15s;
        }
        .tasks-table .task-title-text:hover {
            color: var(--primary-dark);
            text-decoration: underline;
        }
        
        .tasks-table .task-title-text.pinned {
            color: #e74c3c;
        }
        
        .btn-clear.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        
        .status-badge {
            padding: 0.25rem 0.6rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 500;
            display: inline-block;
        }
        
        .status-new { background: #e3f2fd; color: #1976d2; }
        .status-progress { background: #fff3e0; color: #f57c00; }
        .status-review { background: #fce4ec; color: #c2185b; }
        .status-done { background: #e8f5e8; color: #388e3c; }
        
        .myday-item.review { background: #faf5ff; border-left: 3px solid #8b5cf6; }
        .myday-item.review .myday-item-title { color: #6b21a8; }
        
        .deadline-text.overdue { color: #e74c3c; font-weight: 600; }
        .deadline-text.today { color: #3498db; font-weight: 600; }
        
        .action-btns {
            display: flex;
            gap: 0.25rem;
        }
        
        .action-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            padding: 0.25rem;
            border-radius: 4px;
            transition: background 0.2s;
        }
        
        .action-btn:hover {
            background: #ecf0f1;
        }
        
        /* Dashboard subtitle */
        .dashboard-subtitle {
            font-size: 0.7rem;
            opacity: 0.85;
            margin-top: 0.25rem;
        }
        
        /* Analytics */
        .analytics-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }
        
        .analytics-card {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 1.25rem;
            text-align: center;
        }
        
        .analytics-card h3 {
            font-size: 0.85rem;
            color: var(--gray);
            margin-bottom: 0.5rem;
        }
        
        .analytics-number {
            font-size: 2rem;
            font-weight: 700;
            color: var(--dark);
        }
        
        .analytics-number.green { color: #27ae60; }
        .analytics-number.blue { color: #3498db; }
        .analytics-number.orange { color: #f39c12; }
        
        @media (min-width: 768px) {
            .analytics-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }
        
        .controls-row {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            align-items: center;
        }
        
        .empty-table {
            text-align: center;
            padding: 3rem;
            color: var(--gray);
        }
        
        .empty-table h3 {
            margin-bottom: 0.5rem;
            color: var(--dark);
        }
        
        .function-stats, .user-stats {
            justify-content: space-between;
            border-top: 1px solid #ecf0f1;
            font-size: 0.8rem;
        }
        
        .empty-state { text-align: center; padding: 2.5rem 1.5rem; color: var(--gray); }
        .empty-state h3 { margin-bottom: 0.5rem; color: var(--dark); font-size: 1.1rem; }
        
        .modal { 
            display: none; 
            position: fixed; 
            z-index: 1000; 
            left: 0; top: 0; 
            width: 100%; height: 100%; 
            background: rgba(0,0,0,0.5); 
            backdrop-filter: blur(3px);
            overflow-y: auto;
            padding: 0.5rem;
        }
        
        .modal-content { 
            background: var(--white); 
            margin: 0 auto;
            border-radius: var(--radius); 
            width: 100%;
            max-width: 550px;
            max-height: calc(100vh - 1rem);
            overflow-y: auto;
            box-shadow: var(--shadow-lg);
        }
        
        /* Wider modal for regular tasks - almost fullscreen */
        #regularTaskModal .modal-content {
            max-width: 1000px;
            width: 95%;
            max-height: calc(100vh - 2rem);
        }
        
        /* Wider modal for tasks */
        #taskModal .modal-content {
            max-width: 750px;
            width: 95%;
        }
        
        .modal-header { 
            background: var(--dark); 
            color: white; 
            padding: 1rem; 
            border-radius: var(--radius) var(--radius) 0 0;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .modal-header h2 { font-size: 1.1rem; padding-right: 2rem; }
        .modal-body { padding: 1rem; }
        
        .close { 
            color: rgba(255,255,255,0.7);
            position: absolute;
            right: 1rem; top: 0.8rem;
            font-size: 1.5rem;
            cursor: pointer;
        }
        
        .close:hover { color: white; }
        
        .form-grid { display: grid; grid-template-columns: 1fr; gap: 0.9rem; }
        .form-group { display: flex; flex-direction: column; }
        .form-group.full-width { grid-column: span 1; }
        .form-label { margin-bottom: 0.4rem; font-weight: 600; color: var(--dark); font-size: 0.85rem; }
        
        .form-input, .form-select, .form-textarea { 
            padding: 0.7rem; 
            border: 2px solid #ecf0f1; 
            border-radius: var(--radius-sm); 
            font-size: 1rem;
            min-height: 44px;
        }
        
        .form-input:focus, .form-select:focus, .form-textarea:focus { outline: none; border-color: var(--info); }
        .form-textarea { resize: vertical; min-height: 70px; cursor: text; }
        .form-textarea::-webkit-resizer { background: linear-gradient(135deg, transparent 40%, #d1d5db 40%, #d1d5db 45%, transparent 45%, transparent 60%, #d1d5db 60%, #d1d5db 65%, transparent 65%); }
        .form-actions { display: flex; gap: 0.5rem; justify-content: flex-end; margin-top: 1rem; flex-wrap: wrap; }
        
        .dashboard-cards {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.6rem;
            margin-bottom: 1rem;
        }
        
        .dashboard-card {
            border-radius: var(--radius);
            padding: 0.8rem;
            text-align: center;
            color: white;
        }
        
        .dashboard-card.urgent { background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%); }
        .dashboard-card.warning { background: linear-gradient(135deg, #feca57 0%, #f39c12 100%); }
        .dashboard-card.active { background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%); }
        .dashboard-card.completed { background: linear-gradient(135deg, #55efc4 0%, #00b894 100%); }
        
        .dashboard-card h3 { font-size: 0.75rem; margin-bottom: 0.2rem; opacity: 0.9; }
        .dashboard-number { font-size: 1.75rem; font-weight: 700; }
        
        /* AUTH */
        .auth-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: calc(100vh - 80px);
            padding: 0;
            background: #f9fafb;
        }
        
        .auth-card {
            background: var(--white);
            border-radius: 0;
            box-shadow: none;
            width: 100%;
            max-width: 480px;
            overflow: hidden;
            border: none;
        }
        
        @media (min-width: 768px) {
            .auth-container {
                align-items: center;
                padding: 1rem;
            }
            .auth-card {
                border-radius: var(--radius);
                box-shadow: var(--shadow-lg);
                border: 1px solid #e5e7eb;
            }
        }
        
        .auth-header {
            background: var(--header-bg);
            color: white;
            padding: 2rem 1.5rem;
            text-align: center;
        }
        
        .auth-header h2 { font-size: 1.5rem; margin-bottom: 0.4rem; display: flex; align-items: center; justify-content: center; gap: 0.5rem; }
        .auth-header p { opacity: 0.85; font-size: 0.9rem; }
        .auth-body { padding: 1.5rem; }
        
        .auth-input-group {
            margin-bottom: 1rem;
        }
        .auth-input-group label {
            display: block;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--dark);
            margin-bottom: 0.4rem;
        }
        .auth-input-group .form-input {
            width: 100%;
            padding: 0.9rem 1rem;
            font-size: 16px;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            transition: border-color 0.2s, box-shadow 0.2s;
            background: #f9fafb;
        }
        .auth-input-group .form-input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.1);
            background: white;
            outline: none;
        }
        .auth-input-group .input-wrapper {
            position: relative;
        }
        .auth-input-group .input-wrapper .form-input {
            padding-right: 50px;
        }
        .auth-input-group .password-toggle {
            position: absolute;
            right: 4px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 10px;
            color: var(--gray);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .auth-btn-primary {
            width: 100%;
            padding: 1rem;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            transition: all 0.2s;
            min-height: 56px;
            margin-top: 1.25rem;
        }
        .auth-btn-primary:active {
            transform: scale(0.98);
        }
        .auth-btn-login {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white;
            box-shadow: 0 4px 14px rgba(34, 197, 94, 0.3);
        }
        .auth-btn-login:hover {
            box-shadow: 0 6px 20px rgba(34, 197, 94, 0.4);
        }
        .auth-btn-register {
            background: linear-gradient(135deg, #a855f7, #7c3aed);
            color: white;
            box-shadow: 0 4px 14px rgba(168, 85, 247, 0.3);
        }
        .auth-btn-register:hover {
            box-shadow: 0 6px 20px rgba(168, 85, 247, 0.4);
        }
        
        .auth-forgot-link {
            display: block;
            text-align: center;
            margin-top: 1rem;
            font-size: 0.9rem;
            color: var(--info);
            text-decoration: none;
        }
        .auth-forgot-link:hover { text-decoration: underline; }
        
        .auth-message {
            padding: 0.75rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            font-size: 0.85rem;
        }
        .auth-message.success { background: #f0fdf4; color: #16a34a; }
        .auth-message.error { background: #fef2f2; color: #dc2626; }
        .auth-message.info { background: #eff6ff; color: #2563eb; }
        
        .auth-divider {
            display: flex;
            align-items: center;
            margin: 1.25rem 0;
            color: var(--gray);
            font-size: 0.85rem;
        }
        
        .auth-divider::before,
        .auth-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: #e5e7eb;
        }
        
        .auth-divider span {
            padding: 0 1rem;
        }
        
        .main-interface { display: none; }
        
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 3rem;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #e5e7eb;
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin { to { transform: rotate(360deg); } }
        
        .footer {
            text-align: center;
            padding: 1.25rem;
            background: #f9fafb;
            border-top: 1px solid #e5e7eb;
            margin-top: 1.5rem;
        }
        
        .footer p { color: var(--gray); font-size: 0.8rem; margin-bottom: 0.5rem; }
        .footer-links { display: flex; justify-content: center; gap: 1rem; flex-wrap: wrap; }
        .footer-links a { color: var(--primary); text-decoration: none; font-size: 0.8rem; }
        
        .support-btn {
            position: fixed;
            bottom: 16px;
            right: 16px;
            z-index: 999;
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 12px 20px;
            background: var(--primary);
            color: #ffffff !important;
            border-radius: 50px;
            font-weight: 600;
            font-size: 14px;
            box-shadow: 0 4px 15px rgba(34, 197, 94, 0.4);
            cursor: pointer;
            text-decoration: none;
            border: none;
            transition: all 0.3s;
        }
        
        .support-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(16, 185, 129, 0.5); }
        
        /* Mobile buttons */
        
        @media (min-width: 768px) {
            .header { padding: 1rem 2rem; }
            .logo { font-size: 1.4rem; }
            .user-info { display: flex; }
            .container { padding: 1.5rem; }
            .controls { flex-direction: row; align-items: center; justify-content: space-between; }
            .filters { width: auto; flex-wrap: nowrap; }
            .filter-select { flex: none; min-width: auto; }
            .status-multiselect { flex: none; min-width: auto; }
            .form-grid { grid-template-columns: 1fr 1fr; }
            .form-group.full-width { grid-column: span 2; }
            .cards-grid { grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); }
            .dashboard-cards { grid-template-columns: repeat(4, 1fr); }
        }
        
        /* Mobile optimizations */
        @media (max-width: 767px) {
            .filters {
                display: flex;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                padding-bottom: 0.5rem;
                gap: 0.5rem;
            }
            
            .filter-select {
                flex: 0 0 auto;
                min-width: 130px;
                font-size: 0.8rem;
                padding: 0.5rem;
            }
            
            .status-multiselect {
                flex: 0 0 auto;
                min-width: 130px;
            }
            .status-multiselect-toggle {
                font-size: 0.8rem;
                padding: 0.5rem;
            }
            
            .task-card {
                padding: 0.75rem;
            }
            
            .task-title {
                font-size: 0.9rem;
            }
            
            .task-deadline-row {
                font-size: 0.8rem;
                gap: 0.5rem;
            }
            
            .task-meta {
                gap: 0.3rem;
            }
            
            .task-meta-item {
                font-size: 0.75rem;
            }
            
            .task-detail {
                font-size: 0.75rem;
                padding: 0.3rem 0.5rem;
            }
            
            .btn {
                padding: 0.6rem 0.8rem;
                font-size: 0.8rem;
            }
            
            .btn-small {
                padding: 0.35rem 0.5rem;
                font-size: 0.75rem;
                min-height: 44px;
                min-width: 44px;
            }
            
            .total-time-badge {
                font-size: 0.75rem;
                padding: 0.4rem 0.8rem;
            }
            
            .controls-row {
                justify-content: space-between;
                width: 100%;
            }
            
            .modal-content {
                margin-top: 0;
                border-radius: var(--radius) var(--radius) 0 0;
                max-height: 95vh;
            }
            
            .form-input, .form-select, .form-textarea {
                font-size: 16px; /* Prevents zoom on iOS */
            }
            
            /* Hide table on mobile */
            .tasks-table { display: none !important; }
            
            /* Mobile task cards */
            .mobile-tasks-list { display: block; }
            
            .mobile-task-card {
                background: transparent;
                border-radius: 0;
                margin-bottom: 0;
                position: relative;
                overflow: hidden;
            }
            
            .mobile-task-content {
                background: white;
                padding: 1rem 1rem;
                border-left: 4px solid var(--gray);
                position: relative;
                z-index: 2;
                transition: transform 0.15s ease-out, opacity 0.2s, background 0.15s;
                border-bottom: 1px solid #f0f0f0;
                min-height: 56px;
                -webkit-tap-highlight-color: transparent;
            }
            
            .mobile-task-content:active {
                background: #f3f4f6;
                transform: scale(0.985);
            }
            
            .mobile-task-card.status-new .mobile-task-content { border-left-color: #3498db; }
            .mobile-task-card.status-progress .mobile-task-content { border-left-color: #f39c12; }
            .mobile-task-card.status-review .mobile-task-content { border-left-color: #9b59b6; }
            .mobile-task-card.status-done .mobile-task-content { border-left-color: #27ae60; opacity: 0.65; }
            .mobile-task-card.overdue .mobile-task-content { border-left-color: #e74c3c; }
            .mobile-task-card.pinned .mobile-task-content { border-left-color: #e74c3c; background: #fff5f5; }
            
            .mobile-task-header {
                display: flex;
                justify-content: space-between;
                align-items: flex-start;
                gap: 0.5rem;
                margin-bottom: 0.35rem;
            }
            
            .mobile-task-title {
                font-weight: 600;
                font-size: 0.9rem;
                color: #1a1a1a;
                flex: 1;
                line-height: 1.3;
                display: -webkit-box;
                -webkit-line-clamp: 2;
                -webkit-box-orient: vertical;
                overflow: hidden;
            }
            
            .mobile-task-title-done {
                text-decoration: line-through;
                color: #999;
            }
            
            .mobile-task-deadline-badge {
                flex-shrink: 0;
                font-size: 0.75rem;
                font-weight: 500;
                padding: 0.15rem 0.5rem;
                border-radius: 6px;
                white-space: nowrap;
            }
            
            .mobile-task-deadline-badge.overdue {
                background: #fef2f2;
                color: #dc2626;
            }
            
            .mobile-task-deadline-badge.today {
                background: #fffbeb;
                color: #d97706;
            }
            
            .mobile-task-deadline-badge.upcoming {
                color: #6b7280;
            }
            
            .mobile-task-status {
                flex-shrink: 0;
            }
            
            .mobile-task-meta {
                display: flex;
                flex-wrap: wrap;
                gap: 0.4rem;
                font-size: 0.75rem;
                color: #888;
                align-items: center;
            }
            
            .mobile-task-meta-item {
                display: flex;
                align-items: center;
                gap: 0.2rem;
            }
            
            .mobile-task-meta-item .icon {
                width: 13px;
                height: 13px;
            }
            
            .mobile-task-meta-item.deadline-overdue {
                color: #e74c3c;
                font-weight: 600;
            }
            
            .mobile-task-meta-item.deadline-today {
                color: #f57c00;
                font-weight: 600;
            }
            
            .mobile-task-meta-sep {
                color: #ddd;
                font-size: 0.6rem;
            }
            
            /* Аватар ініціали */
            .mobile-task-avatar {
                width: 28px;
                height: 28px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 0.65rem;
                font-weight: 700;
                color: white;
                flex-shrink: 0;
            }
            
            /* Badges row — коментарі, файли, чеклист */
            .mobile-task-badges {
                display: flex;
                align-items: center;
                gap: 0.6rem;
                margin-top: 0.35rem;
            }
            
            .mobile-badge {
                display: flex;
                align-items: center;
                gap: 0.2rem;
                font-size: 0.7rem;
                color: #999;
            }
            
            .mobile-badge .icon {
                width: 13px;
                height: 13px;
            }
            
            .mobile-badge.has-items {
                color: #22c55e;
                font-weight: 600;
            }
            
            .mobile-task-actions {
                display: flex;
                gap: 0.4rem;
                padding-top: 0.6rem;
                border-top: 1px solid #f0f0f0;
                margin-top: 0.4rem;
            }
            
            .mobile-action-btn {
                flex: 1;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 0.3rem;
                padding: 0.55rem;
                border: none;
                border-radius: 8px;
                font-size: 0.8rem;
                font-weight: 500;
                cursor: pointer;
                min-height: 44px;
                transition: all 0.15s;
                touch-action: manipulation;
                -webkit-tap-highlight-color: transparent;
            }
            
            .mobile-action-btn.delete {
                flex: 0 0 44px;
                max-width: 44px;
            }
            
            .mobile-action-btn.complete {
                background: #e8f5e9;
                color: #2e7d32;
            }
            
            .mobile-action-btn.edit {
                background: #e3f2fd;
                color: #1565c0;
            }
            
            .mobile-action-btn.delete {
                background: #ffebee;
                color: #c62828;
            }
            
            .mobile-action-btn:active {
                transform: scale(0.95);
            }
        }
        
        /* Desktop: show table, hide mobile cards */
        @media (min-width: 768px) {
            .mobile-tasks-list { display: none !important; }
            .tasks-table { display: table !important; }
            .bottom-nav { display: none !important; }
            .fab-add { display: none !important; }
            .mobile-filter-bar { display: none !important; }
            .filters-row:not(#calendarFiltersRow) { display: flex !important; }
            .controls-row .btn { display: inline-flex !important; }
        }
        
        /* Bottom Navigation for Mobile */
        .bottom-nav {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: white;
            box-shadow: 0 -4px 20px rgba(0,0,0,0.06);
            z-index: 900;
            padding: 0.4rem 0;
            padding-bottom: calc(0.4rem + env(safe-area-inset-bottom));
            border-top: 1px solid #f0f0f0;
        }
        
        .bottom-nav-items {
            display: flex;
            justify-content: space-around;
            max-width: 500px;
            margin: 0 auto;
        }
        
        .bottom-nav-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.15rem;
            padding: 0.4rem 0.3rem;
            background: none;
            border: none;
            color: #b0b8c4;
            font-size: 0.6rem;
            font-weight: 500;
            cursor: pointer;
            border-radius: 10px;
            min-width: 60px;
            min-height: 48px;
            transition: color 0.15s, transform 0.1s;
            position: relative;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        .bottom-nav-btn .icon {
            width: 22px;
            height: 22px;
            transition: all 0.2s;
        }
        
        .bottom-nav-btn.active {
            color: var(--primary);
            background: transparent;
        }
        
        .bottom-nav-btn.active .icon {
            transform: scale(1.1);
        }
        
        .bottom-nav-btn.active::after {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 3px;
            background: var(--primary);
            border-radius: 0 0 3px 3px;
        }
        
        .bottom-nav-btn:active {
            transform: scale(0.92);
        }
        
        @media (max-width: 767px) {
            .bottom-nav { display: block; }
            .tab-navigation { display: none !important; }
            .main-interface { padding-bottom: 80px; }
            .hide-mobile { display: none !important; }
            
            /* Compact mobile header */
            .header {
                padding: 0.5rem 0.75rem;
                position: sticky;
                top: 0;
            }
            
            .header .header-ai-btn,
            .header .lang-switcher,
            .header .user-info,
            .header #logoutBtn,
            .header #demoDataBtnDesktop {
                display: none !important;
            }
            
            .logo {
                font-size: 0.95rem;
            }
            
            .header-actions {
                gap: 0.25rem;
            }
            
            /* Mobile logout icon only */
            .header .mobile-logout-btn {
                display: flex !important;
                background: rgba(255,255,255,0.15);
                border: none;
                color: white;
                width: 36px;
                height: 36px;
                border-radius: 50%;
                align-items: center;
                justify-content: center;
                cursor: pointer;
            }
            
            .container {
                padding: 0.5rem;
            }
            
            /* Tab content title — compact */
            .tab-content h3 {
                font-size: 0.95rem;
                margin-bottom: 0.5rem;
            }
            
            /* Fullscreen modals on mobile - only main editing modals */
            .modal {
                padding: 0;
            }
            
            #taskModal .modal-content,
            #regularTaskModal .modal-content,
            #processTemplatesModal .modal-content,
            #projectModal .modal-content {
                border-radius: 0;
                max-height: 100vh;
                min-height: 100vh;
                margin: 0;
                max-width: 100%;
                animation: slideUpModal 0.25s ease-out;
            }
            
            @keyframes slideUpModal {
                from { transform: translateY(40px); opacity: 0.8; }
                to { transform: translateY(0); opacity: 1; }
            }
            
            /* Smaller modals stay compact */
            #demoDataModal .modal-content,
            #profileModal .modal-content,
            #filterModal .modal-content {
                border-radius: 16px;
                min-height: auto;
                max-height: 90vh;
                margin: auto;
                max-width: 95%;
            }
            
            /* Mobile menu - bottom sheet */
            #mobileMenuModal .modal-content {
                min-height: auto;
                max-height: none;
            }
            
            .modal-header {
                border-radius: 0;
                padding: 0.75rem 1rem;
                position: sticky;
                top: 0;
            }
            
            .modal-header h2 {
                font-size: 1rem;
            }
            
            .modal-body {
                padding: 0.75rem;
            }
            
            /* Smooth card shadows */
            .task-card, .process-pipeline-row, .project-card {
                box-shadow: 0 1px 3px rgba(0,0,0,0.06);
                border: 1px solid #f0f0f0;
            }
            
            /* Empty states compact */
            .empty-state {
                padding: 2rem 1rem;
            }
            
            .empty-state h3 {
                font-size: 1rem;
            }
            
            /* FAB for adding tasks */
            .fab-add {
                position: fixed;
                bottom: 90px;
                right: 16px;
                width: 56px;
                height: 56px;
                border-radius: 50%;
                background: var(--success);
                color: white;
                border: none;
                box-shadow: 0 4px 12px rgba(34, 197, 94, 0.4);
                cursor: pointer;
                z-index: 899;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s;
            }
            
            .fab-add:active {
                transform: scale(0.9);
            }
            
            .fab-add .icon {
                width: 24px;
                height: 24px;
            }
            
            /* Hide desktop add buttons on mobile */
            .controls .btn-success:first-child { display: none; }
            
            /* Compact mobile header */
            .header-container {
                padding: 0.5rem 1rem;
            }
            
            .header-logo {
                font-size: 1rem;
            }
            
            .header-logo .company-badge {
                display: none !important;
            }
            
            .header-actions {
                gap: 0.5rem;
            }
            
            /* Hide AI buttons and full logout on mobile */
            .header-ai-btn { display: none !important; }
            .header-btn span { display: none; }
            .header-btn { 
                padding: 0.5rem; 
                border-radius: 50%;
                min-width: 40px;
                min-height: 40px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            .header-btn .icon { margin: 0; }
            
            .lang-switcher { display: none; }
            .user-info { display: none !important; }
            
            /* Pull-to-refresh */
            .ptr-indicator {
                text-align: center;
                padding: 0;
                overflow: hidden;
                height: 0;
                transition: height 0.2s;
                color: var(--primary);
                font-size: 0.85rem;
                font-weight: 500;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 0.4rem;
            }
            
            .ptr-indicator.pulling {
                height: 50px;
            }
            
            .ptr-indicator.refreshing {
                height: 50px;
            }
            
            .ptr-spinner {
                width: 20px;
                height: 20px;
                border: 2px solid #e5e7eb;
                border-top-color: var(--primary);
                border-radius: 50%;
                animation: spin 0.6s linear infinite;
            }
            
            @keyframes spin {
                to { transform: rotate(360deg); }
            }
            
            /* Swipe to complete */
            .mobile-task-card {
                position: relative;
                overflow: hidden;
                touch-action: pan-y;
                transition: transform 0.2s ease-out;
            }
            
            .mobile-task-card.swiping {
                transition: none;
            }
            
            .swipe-action-bg {
                position: absolute;
                top: 0;
                bottom: 0;
                width: 100%;
                display: flex;
                align-items: center;
                padding: 0 1.5rem;
                font-weight: 600;
                font-size: 0.9rem;
                opacity: 0;
                transition: opacity 0.2s;
            }
            
            .swipe-action-bg.left {
                left: 0;
                background: linear-gradient(90deg, #27ae60 0%, #2ecc71 100%);
                color: white;
                justify-content: flex-start;
            }
            
            .swipe-action-bg.right {
                right: 0;
                background: linear-gradient(90deg, #e74c3c 0%, #c0392b 100%);
                color: white;
                justify-content: flex-end;
            }
            
            .swipe-action-bg.visible {
                opacity: 1;
            }
            
            .mobile-task-content {
                position: relative;
                z-index: 1;
            }
            
            /* Swipe hint animation */
            @keyframes swipeHint {
                0%, 100% { transform: translateX(0); }
                50% { transform: translateX(10px); }
            }
            
            .mobile-task-card.hint-swipe {
                animation: swipeHint 0.5s ease-in-out;
            }
            
            /* Mobile filter button */
            .mobile-filter-bar {
                display: flex;
                gap: 0.35rem;
                padding: 0.4rem 0.75rem;
                background: white;
                border-radius: 0;
                margin: 0 -0.5rem 0.25rem;
                box-shadow: none;
                border-bottom: 1px solid #f3f4f6;
            }
            
            .mobile-filter-btn {
                flex: 0 0 auto;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 0.3rem;
                padding: 0.45rem 0.5rem;
                background: #f5f5f5;
                border: none;
                border-radius: 8px;
                font-size: 0.78rem;
                font-weight: 500;
                color: #555;
                cursor: pointer;
                min-height: 36px;
                transition: all 0.15s ease;
                -webkit-tap-highlight-color: transparent;
            }
            
            .mobile-filter-btn.active {
                background: var(--success);
                color: white;
            }
            
            .mobile-filter-btn .filter-count {
                background: var(--success);
                color: white;
                font-size: 0.7rem;
                padding: 0.15rem 0.4rem;
                border-radius: 10px;
                font-weight: 600;
            }
            
            .mobile-filter-btn.active .filter-count {
                background: white;
                color: var(--success);
            }
            
            /* Hide desktop filters on mobile */
            .filters-row { display: none !important; }
            .controls-row .btn:not(.btn-success) { display: none; }
            
            /* Date group headers */
            .date-group-header {
                display: flex;
                align-items: center;
                gap: 0.5rem;
                padding: 0.75rem 0.5rem;
                font-weight: 600;
                font-size: 0.85rem;
                color: #555;
                border-bottom: 2px solid #eee;
                margin-top: 0.5rem;
            }
            
            .date-group-header:first-child {
                margin-top: 0;
            }
            
            .date-group-header .date-label {
                flex: 1;
            }
            
            .date-group-header .task-count {
                background: #f0f0f0;
                padding: 0.2rem 0.6rem;
                border-radius: 10px;
                font-size: 0.75rem;
                color: #888;
            }
            
            .date-group-header.overdue {
                color: #e74c3c;
                border-bottom-color: #ffcccc;
            }
            
            .date-group-header.today {
                color: #f39c12;
                border-bottom-color: #ffe5b4;
            }
            
            .date-group-header.tomorrow {
                color: #3498db;
                border-bottom-color: #cce5ff;
            }
            
            /* Filter modal */
            .filter-modal-content {
                padding: 0;
                max-height: 80vh;
                overflow-y: auto;
            }
            
            .filter-modal-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 1rem;
                border-bottom: 1px solid #eee;
                position: sticky;
                top: 0;
                background: white;
                z-index: 10;
            }
            
            .filter-modal-header h3 {
                margin: 0;
                font-size: 1.1rem;
            }
            
            .filter-section {
                padding: 1rem;
                border-bottom: 1px solid #f0f0f0;
            }
            
            .filter-section:last-child {
                border-bottom: none;
            }
            
            .filter-section-title {
                font-weight: 600;
                font-size: 0.85rem;
                color: #888;
                margin-bottom: 0.75rem;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .filter-chips {
                display: flex;
                flex-wrap: wrap;
                gap: 0.5rem;
            }
            
            .filter-chip {
                padding: 0.5rem 1rem;
                background: #f5f5f5;
                border: 2px solid transparent;
                border-radius: 20px;
                font-size: 0.85rem;
                cursor: pointer;
                transition: all 0.2s;
            }
            
            .filter-chip.selected {
                background: #e8f5e9;
                border-color: var(--success);
                color: var(--success);
                font-weight: 500;
            }
            
            .filter-modal-footer {
                display: flex;
                gap: 0.75rem;
                padding: 1rem;
                border-top: 1px solid #eee;
                position: sticky;
                bottom: 0;
                background: white;
            }
            
            .filter-modal-footer .btn {
                flex: 1;
            }
        }
        
        @media (max-width: 400px) {
            .header-ai-btn span { display: none; }
            .header-ai-btn { padding: 0.4rem; font-size: 0.9rem; }
            .support-btn span { display: none; }
            .support-btn { padding: 14px; border-radius: 50%; font-size: 18px; }
        }
        
        .assignee-checkbox {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            background: #f0f0f0;
            padding: 0.3rem 0.5rem;
            border-radius: 15px;
            font-size: 0.8rem;
            cursor: pointer;
        }
        
        .assignee-checkbox:hover { background: #e0e0e0; }
        .assignee-checkbox input { width: 14px; height: 14px; cursor: pointer; }
        
        .company-badge {
            background: rgba(255,255,255,0.3);
            padding: 0.2rem 0.5rem;
            border-radius: 10px;
            font-size: 0.7rem;
            margin-left: 0.5rem;
        }
        
        .password-toggle {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.1rem;
            color: var(--gray);
        }
        
        .input-wrapper {
            position: relative;
        }
        
        .no-access-card {
            text-align: center;
            padding: 2rem;
        }
        
        .no-access-card h3 {
            color: var(--danger);
            margin-bottom: 1rem;
        }
        
        .no-access-card p {
            color: var(--gray);
            margin-bottom: 1.5rem;
            line-height: 1.5;
        }
        
        /* ===================== */
        /* CALENDAR VIEW STYLES  */
        /* ===================== */
        
        .calendar-view-switcher {
            display: flex;
            gap: 0.25rem;
            background: #e5e7eb;
            padding: 0.25rem;
            border-radius: 8px;
            margin-right: 1rem;
        }
        
        .calendar-view-btn {
            padding: 0.4rem 0.8rem;
            border: none;
            background: transparent;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            color: var(--gray);
            transition: all 0.2s;
        }
        
        .calendar-view-btn:hover {
            color: var(--dark);
        }
        
        .calendar-view-btn.active {
            background: white;
            color: var(--dark);
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .calendar-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
            padding: 1rem;
            background: white;
            border-radius: 12px;
            margin-bottom: 1rem;
            box-shadow: var(--shadow);
        }
        
        .calendar-nav {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .calendar-nav-btn {
            width: 36px;
            height: 36px;
            border: 1px solid #e5e7eb;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .calendar-nav-btn:hover {
            background: #f3f4f6;
        }
        
        .calendar-title {
            font-size: 1.25rem;
            font-weight: 600;
            min-width: 120px;
            flex: 1;
        }
        
        .calendar-today-btn {
            padding: 0.5rem 1rem;
            border: 1px solid #e5e7eb;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }
        
        .calendar-today-btn:hover {
            background: #f3f4f6;
        }
        
        /* Day View */
        .calendar-day-view {
            background: white;
            border-radius: 12px;
            box-shadow: var(--shadow);
            overflow: hidden;
        }
        
        .calendar-day-header {
            display: flex;
            border-bottom: 1px solid #e5e7eb;
            background: #f9fafb;
        }
        
        .calendar-time-gutter {
            width: 60px;
            flex-shrink: 0;
            border-right: 1px solid #e5e7eb;
        }
        
        .calendar-day-column-header {
            flex: 1;
            padding: 0.75rem;
            text-align: center;
            font-weight: 500;
        }
        
        .calendar-day-column-header .day-name {
            font-size: 0.75rem;
            color: var(--gray);
            text-transform: uppercase;
        }
        
        .calendar-day-column-header .day-number {
            font-size: 1.5rem;
            font-weight: 600;
            margin-top: 0.25rem;
        }
        
        .calendar-day-column-header.today .day-number {
            background: var(--primary);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        
        .calendar-day-body {
            display: flex;
            position: relative;
            max-height: calc(100vh - 300px);
            overflow-y: auto;
        }
        
        .calendar-time-slots {
            width: 60px;
            flex-shrink: 0;
            border-right: 1px solid #e5e7eb;
        }
        
        .calendar-time-slot {
            height: 60px;
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            color: var(--gray);
            text-align: right;
            border-bottom: 1px solid #f3f4f6;
        }
        
        .calendar-events-container {
            flex: 1;
            position: relative;
        }
        
        .calendar-hour-row {
            height: 60px;
            border-bottom: 1px solid #f3f4f6;
            position: relative;
        }
        
        .calendar-hour-row:hover {
            background: rgba(102, 126, 234, 0.08);
        }
        
        /* Hint on hover - desktop only */
        @media (min-width: 768px) {
            .calendar-hour-row:hover::after {
                content: '+ Додати';
                position: absolute;
                right: 8px;
                top: 50%;
                transform: translateY(-50%);
                font-size: 0.75rem;
                color: var(--primary);
                opacity: 0.7;
                pointer-events: none;
            }
        }
        
        .calendar-event {
            position: absolute;
            left: 4px;
            right: 4px;
            border-radius: 6px;
            padding: 0.35rem 0.5rem;
            font-size: 0.8rem;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 1;
            border-left: 3px solid;
        }
        
        .calendar-event:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 2;
        }
        
        .calendar-event.status-new {
            background: #dbeafe;
            border-color: #3b82f6;
            color: #1e40af;
        }
        
        .calendar-event.status-progress {
            background: #fef3c7;
            border-color: #f59e0b;
            color: #92400e;
        }
        
        .calendar-event.status-review {
            background: #e0e7ff;
            border-color: #6366f1;
            color: #3730a3;
        }
        
        .calendar-event.status-done {
            background: #d1fae5;
            border-color: #10b981;
            color: #065f46;
            opacity: 0.7;
        }
        
        .calendar-event-title {
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .calendar-event-time {
            font-size: 0.7rem;
            opacity: 0.8;
            margin-top: 2px;
        }
        
        .calendar-event-done-mark {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 16px;
            height: 16px;
            background: #10b981;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .calendar-event-done-mark svg {
            width: 10px;
            height: 10px;
            color: white;
        }
        
        /* Mobile Week Strip (Google Calendar Style) */
        .mobile-week-strip {
            display: none;
        }
        
        @media (max-width: 767px) {
            .mobile-week-strip {
                display: block;
                background: white;
                padding: 12px 0 8px;
                margin: 0 -0.5rem;
                border-bottom: 1px solid #e5e7eb;
            }
            
            .week-strip-days {
                display: flex;
                justify-content: space-around;
                padding: 0 8px;
            }
            
            .week-strip-day {
                display: flex;
                flex-direction: column;
                align-items: center;
                padding: 4px;
                border-radius: 16px;
                cursor: pointer;
                min-width: 40px;
                transition: all 0.15s ease;
                -webkit-tap-highlight-color: transparent;
            }
            
            .week-strip-day:active {
                transform: scale(0.92);
                background: rgba(0,0,0,0.05);
            }
            
            .week-strip-day .day-label {
                font-size: 0.65rem;
                color: #8e8e93;
                font-weight: 600;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                margin-bottom: 6px;
            }
            
            .week-strip-day .day-num {
                width: 34px;
                height: 34px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 1.1rem;
                font-weight: 400;
                border-radius: 50%;
                color: #1c1c1e;
                position: relative;
                transition: all 0.2s ease;
            }
            
            .week-strip-day.today .day-label {
                color: #007aff;
            }
            
            .week-strip-day.today .day-num {
                background: #007aff;
                color: white;
                font-weight: 500;
            }
            
            .week-strip-day.selected:not(.today) .day-num {
                background: rgba(0, 122, 255, 0.12);
                color: #007aff;
                font-weight: 500;
            }
            
            .week-strip-day.today.selected .day-num {
                box-shadow: none;
            }
            
            /* Task dots under day number - Apple style */
            .week-strip-day .task-dots {
                display: flex;
                gap: 3px;
                margin-top: 6px;
                min-height: 6px;
                justify-content: center;
            }
            
            .week-strip-day .task-dot {
                width: 5px;
                height: 5px;
                border-radius: 50%;
                background: #c7c7cc;
            }
            
            .week-strip-day .task-dot.status-new { background: #007aff; }
            .week-strip-day .task-dot.status-progress { background: #ff9500; }
            .week-strip-day .task-dot.status-review { background: #af52de; }
            .week-strip-day .task-dot.status-done { background: #34c759; }
        }
        
        /* Task Quick Menu / Bottom Sheet */
        .task-quick-menu {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            z-index: 10000;
            min-width: 180px;
            overflow: hidden;
            animation: fadeInMenu 0.15s ease;
        }
        
        @keyframes fadeInMenu {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Mobile Bottom Sheet */
        @media (max-width: 767px) {
            .task-quick-menu {
                position: fixed !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                top: auto !important;
                max-width: 100%;
                min-width: 100%;
                border-radius: 20px 20px 0 0;
                box-shadow: 0 -4px 30px rgba(0,0,0,0.2);
                animation: slideUpSheet 0.25s ease-out;
                padding-bottom: env(safe-area-inset-bottom);
            }
            
            @keyframes slideUpSheet {
                from { transform: translateY(100%); }
                to { transform: translateY(0); }
            }
            
            .task-bottom-sheet-overlay {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.4);
                z-index: 9999;
                animation: fadeIn 0.2s ease;
            }
            
            @keyframes fadeIn {
                from { opacity: 0; }
                to { opacity: 1; }
            }
            
            .task-quick-menu::before {
                content: '';
                display: block;
                width: 40px;
                height: 4px;
                background: #ddd;
                border-radius: 2px;
                margin: 12px auto 8px;
            }
            
            .task-quick-menu-header {
                padding: 12px 20px 16px;
                font-size: 1.1rem;
                max-width: 100%;
                border-bottom: 1px solid #f0f0f0;
            }
            
            .task-quick-menu-item {
                padding: 16px 20px;
                font-size: 1rem;
            }
            
            .task-quick-menu-item svg {
                width: 22px;
                height: 22px;
            }
        }
        
        .task-quick-menu-header {
            padding: 12px 16px;
            font-weight: 600;
            font-size: 0.9rem;
            background: #f9fafb;
            border-bottom: 1px solid #e5e7eb;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 200px;
        }
        
        .task-quick-menu-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 16px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.15s;
        }
        
        .task-quick-menu-item:hover {
            background: #f3f4f6;
        }
        
        .task-quick-menu-item.complete {
            color: #059669;
        }
        
        .task-quick-menu-item.complete:hover {
            background: #ecfdf5;
        }
        
        .task-quick-menu-item.delete {
            color: #dc2626;
        }
        
        .task-quick-menu-item.delete:hover {
            background: #fef2f2;
        }
        
        .task-quick-menu-item svg {
            flex-shrink: 0;
        }
        
        /* Drag & Drop */
        .calendar-hour-row {
            cursor: pointer;
            transition: background 0.15s;
        }
        
        .calendar-hour-row:hover {
            background: rgba(102, 126, 234, 0.05);
        }
        
        .calendar-hour-row.drag-over {
            background: rgba(102, 126, 234, 0.15);
            box-shadow: inset 0 0 0 2px var(--primary);
        }
        
        .calendar-event[draggable="true"] {
            cursor: grab;
        }
        
        .calendar-event[draggable="true"]:active {
            cursor: grabbing;
        }
        
        /* Week View */
        .calendar-week-view {
            background: white;
            border-radius: 12px;
            box-shadow: var(--shadow);
            overflow: hidden;
        }
        
        .calendar-week-header {
            display: flex;
            border-bottom: 1px solid #e5e7eb;
            background: #f9fafb;
        }
        
        .calendar-week-day-header {
            flex: 1;
            padding: 0.5rem;
            text-align: center;
            border-right: 1px solid #e5e7eb;
            min-width: 0;
        }
        
        .calendar-week-day-header:last-child {
            border-right: none;
        }
        
        .calendar-week-body {
            display: flex;
            max-height: calc(100vh - 300px);
            overflow-y: auto;
        }
        
        .calendar-week-day-column {
            flex: 1;
            border-right: 1px solid #e5e7eb;
            position: relative;
            min-width: 0;
        }
        
        .calendar-week-day-column:last-child {
            border-right: none;
        }
        
        .calendar-week-event {
            margin: 2px 4px;
            padding: 0.25rem 0.4rem;
            border-radius: 4px;
            font-size: 0.75rem;
            cursor: pointer;
            border-left: 3px solid;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        /* Month View */
        .calendar-month-view {
            background: white;
            border-radius: 12px;
            box-shadow: var(--shadow);
            overflow: hidden;
        }
        
        .calendar-month-header {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            background: #f9fafb;
            border-bottom: 1px solid #e5e7eb;
        }
        
        .calendar-month-day-name {
            padding: 0.75rem;
            text-align: center;
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--gray);
            text-transform: uppercase;
        }
        
        .calendar-month-body {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
        }
        
        .calendar-month-day {
            min-height: 100px;
            border-right: 1px solid #e5e7eb;
            border-bottom: 1px solid #e5e7eb;
            padding: 0.25rem;
        }
        
        .calendar-month-day:nth-child(7n) {
            border-right: none;
        }
        
        .calendar-month-day.other-month {
            background: #f9fafb;
        }
        
        .calendar-month-day.other-month .month-day-number {
            color: #d1d5db;
        }
        
        .calendar-month-day.today .month-day-number {
            background: var(--primary);
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        
        .month-day-number {
            font-size: 0.85rem;
            font-weight: 500;
            margin-bottom: 0.25rem;
        }
        
        .calendar-month-event {
            padding: 0.15rem 0.35rem;
            margin-bottom: 2px;
            border-radius: 3px;
            font-size: 0.7rem;
            cursor: pointer;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            border-left: 3px solid;
        }
        
        .calendar-month-event.status-new {
            background: #dbeafe;
            border-color: #3b82f6;
            color: #1e40af;
        }
        .calendar-month-event.status-progress {
            background: #fef3c7;
            border-color: #f59e0b;
            color: #92400e;
        }
        .calendar-month-event.status-review {
            background: #e0e7ff;
            border-color: #6366f1;
            color: #3730a3;
        }
        .calendar-month-event.status-done {
            background: #d1fae5;
            border-color: #10b981;
            color: #065f46;
            opacity: 0.7;
        }
        .calendar-month-event:hover {
            filter: brightness(0.95);
        }
        
        .calendar-month-more {
            font-size: 0.7rem;
            color: var(--gray);
            padding: 0.15rem 0.35rem;
            cursor: pointer;
        }
        
        .calendar-month-more:hover {
            color: var(--primary);
        }
        
        /* All-day events / No time tasks */
        .calendar-allday-section {
            border-bottom: 1px solid #e5e7eb;
            padding: 0.5rem;
            background: #fefce8;
            min-height: 40px;
        }
        
        .calendar-allday-label {
            font-size: 0.7rem;
            color: var(--gray);
            margin-bottom: 0.25rem;
        }
        
        .calendar-allday-event {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            margin: 2px;
            border-radius: 4px;
            font-size: 0.75rem;
            cursor: pointer;
        }
        
        /* Current time indicator */
        .calendar-current-time {
            position: absolute;
            left: 0;
            right: 0;
            height: 2px;
            background: #ef4444;
            z-index: 10;
        }
        
        .calendar-current-time::before {
            content: '';
            position: absolute;
            left: -5px;
            top: -4px;
            width: 10px;
            height: 10px;
            background: #ef4444;
            border-radius: 50%;
        }
        
        /* List View (existing) */
        .calendar-list-view {
            /* existing table/card styles */
        }
        
        /* Mobile Calendar Styles - Google Calendar Style */
        @media (max-width: 767px) {
            .calendar-header {
                flex-wrap: wrap;
                gap: 0.3rem;
                padding: 0.5rem 0.75rem 0.25rem;
                margin: 0 -0.5rem 0 -0.5rem;
                border-radius: 0;
                background: white;
                border-bottom: none;
                justify-content: space-between;
            }
            
            .calendar-view-switcher {
                display: flex;
                gap: 0;
                order: 10;
                width: 100%;
                padding: 3px;
                background: #f1f3f5;
                border-radius: 10px;
                margin: 0.15rem 0 0.15rem;
            }
            
            .calendar-view-switcher .calendar-view-btn {
                flex: 1;
                font-size: 0;
                padding: 0.4rem 0;
                border-radius: 8px;
                text-align: center;
                margin-right: 0;
                min-height: 36px;
                transition: all 0.15s ease;
                border: none;
                background: transparent;
                color: #6b7280;
                font-weight: 500;
            }
            
            .calendar-view-switcher .calendar-view-btn.active {
                background: white;
                color: #1a1a1a;
                font-weight: 600;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .calendar-view-switcher .calendar-view-btn::after {
                content: attr(data-short);
                font-size: 0.8rem;
            }
            
            .calendar-nav {
                order: 1;
                gap: 0;
            }
            
            .calendar-nav-btn {
                width: 32px;
                height: 32px;
                background: transparent;
                border: none;
            }
            
            .calendar-title {
                order: 2;
                min-width: auto;
                font-size: 1.05rem;
                font-weight: 600;
                flex: 1;
                text-align: left;
                margin-left: 2px;
            }
            
            .calendar-today-btn {
                display: inline-flex;
                order: 3;
                padding: 0.3rem 0.7rem;
                font-size: 0.8rem;
                border: 1px solid #e5e7eb;
                background: white;
                min-height: 32px;
            }
            }
            
            /* Hide add button in TASKS header on mobile - use FAB instead */
            #calendarHeader .btn-success {
                display: none;
            }
            
            /* Hide day header on mobile - use week strip instead */
            .calendar-day-header {
                display: none;
            }
            
            .calendar-day-view {
                border-radius: 0;
                margin: 0 -0.5rem;
                box-shadow: none;
                border-top: none;
                -webkit-overflow-scrolling: touch;
            }
            
            .calendar-time-gutter,
            .calendar-time-slots {
                width: 48px;
            }
            
            .calendar-time-slot {
                font-size: 0.75rem;
                padding: 0.2rem 0.4rem;
                text-align: right;
                color: #6b7280;
            }
            
            .calendar-day-body {
                max-height: calc(100vh - 260px);
                min-height: 400px;
            }
            
            .calendar-hour-row {
                height: 48px;
                cursor: pointer;
                transition: background 0.1s ease;
                -webkit-tap-highlight-color: transparent;
            }
            
            .calendar-hour-row:active {
                background: rgba(0, 122, 255, 0.15) !important;
            }
            
            /* Hint text on empty hours */
            .calendar-hour-row:empty::after {
                content: '';
            }
            
            /* Hide desktop day column header */
            .calendar-day-column-header {
                display: none;
            }
            
            .calendar-allday-section {
                margin: 0;
                padding: 8px 12px;
                background: #f9fafb;
                border-bottom: 1px solid #e5e7eb;
            }
            
            .calendar-event {
                font-size: 0.85rem;
                padding: 8px 10px;
                left: 2px;
                right: 2px;
                border-radius: 8px;
                border-left-width: 4px;
                min-height: 36px;
                -webkit-tap-highlight-color: transparent;
            }
            
            .calendar-event:active {
                opacity: 0.7;
                transform: scale(0.98);
            }
            
            .calendar-event-title {
                font-size: 0.85rem;
                font-weight: 600;
            }
            
            .calendar-event-time {
                display: block;
                font-size: 0.75rem;
                opacity: 0.85;
                margin-top: 2px;
            }
            
            .calendar-allday-event {
                font-size: 0.85rem;
                padding: 8px 10px;
                border-radius: 8px;
                margin-bottom: 4px;
            }
            
            /* Week view on mobile */
            .calendar-week-view {
                border-radius: 0;
                margin: 0 -0.5rem;
            }
            
            .calendar-week-header {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                display: flex;
            }
            
            .calendar-week-day-header {
                min-width: 90px;
                flex-shrink: 0;
                padding: 0.5rem 0.25rem;
            }
            
            .calendar-week-body {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                display: flex;
            }
            
            .calendar-week-day-column {
                min-width: 90px;
                flex-shrink: 0;
            }
            
            /* Month view on mobile */
            .calendar-month-view {
                border-radius: 0;
                margin: 0 -0.5rem;
            }
            
            .calendar-month-day {
                min-height: 55px;
                padding: 0.15rem;
            }
            
            .month-day-number {
                font-size: 0.75rem;
            }
            
            .calendar-month-event {
                font-size: 0.6rem;
                padding: 0.1rem 0.15rem;
            }
            
            .calendar-month-more {
                font-size: 0.6rem;
            }
            
            /* Regular calendar mobile */
            .regular-week-view {
                border-radius: 0;
                margin: 0 -0.5rem;
            }
            
            .regular-week-header {
                display: flex;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .regular-week-day-header {
                min-width: 120px;
                flex-shrink: 0;
                padding: 0.6rem 0.3rem;
            }
            
            .regular-week-day-header .day-name {
                font-size: 0.85rem;
            }
            
            .regular-week-body {
                display: flex;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                scroll-snap-type: x mandatory;
                padding-bottom: 8px;
            }
            
            .regular-week-day-column {
                min-width: 85%;
                max-width: 85%;
                flex-shrink: 0;
                padding: 0.5rem;
                scroll-snap-align: start;
            }
            
            .regular-task-card {
                padding: 0.75rem;
                padding-right: 50px;
                margin-bottom: 0.75rem;
            }
            
            .regular-task-card .task-title {
                font-size: 0.9rem;
                line-height: 1.3;
            }
            
            .regular-task-card .task-time {
                font-size: 0.8rem;
            }
            
            .regular-task-complete-btn {
                width: 36px;
                height: 36px;
            }
            
            .regular-day-empty {
                padding: 2rem 0.5rem;
                font-size: 0.85rem;
            }
            
            /* Scroll indicator */
            .regular-week-body::after {
                content: '';
                min-width: 15%;
                flex-shrink: 0;
            }
        }
        
        /* iOS Safe Areas */
        @supports (padding-bottom: env(safe-area-inset-bottom)) {
            .bottom-nav {
                padding-bottom: calc(0.5rem + env(safe-area-inset-bottom));
            }
            
            .calendar-day-body {
                max-height: calc(100vh - 280px - env(safe-area-inset-bottom));
            }
        }
        
        /* Mobile Regular Tasks Day Tabs */
        .mobile-regular-tabs {
            display: none;
        }
        
        .mobile-regular-day-view {
            display: none;
        }
        
        @media (max-width: 767px) {
            .mobile-regular-tabs {
                display: block;
                background: white;
                padding: 12px 8px;
                margin: 0 -0.5rem;
                border-bottom: 1px solid #e5e7eb;
            }
            
            .regular-day-tabs {
                display: flex;
                justify-content: space-between;
                gap: 4px;
            }
            
            .regular-day-tab {
                flex: 1;
                padding: 10px 4px;
                border: none;
                background: #f3f4f6;
                border-radius: 10px;
                font-size: 0.85rem;
                font-weight: 600;
                color: #6b7280;
                cursor: pointer;
                transition: all 0.2s;
                -webkit-tap-highlight-color: transparent;
            }
            
            .regular-day-tab:active {
                transform: scale(0.95);
            }
            
            .regular-day-tab.active {
                background: var(--primary);
                color: white;
            }
            
            .regular-day-tab.today:not(.active) {
                background: #e0e7ff;
                color: var(--primary);
            }
            
            .regular-day-tab.has-tasks::after {
                content: '';
                display: block;
                width: 5px;
                height: 5px;
                background: currentColor;
                border-radius: 50%;
                margin: 4px auto 0;
                opacity: 0.6;
            }
            
            .mobile-regular-day-view {
                display: block;
                background: #f9fafb;
                min-height: calc(100vh - 350px);
                padding: 12px;
                margin: 0 -0.5rem;
            }
            
            .mobile-regular-day-content {
                max-height: calc(100vh - 380px);
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .mobile-regular-empty {
                text-align: center;
                padding: 60px 20px;
                color: #9ca3af;
            }
            
            .mobile-regular-empty-icon {
                font-size: 3rem;
                margin-bottom: 12px;
                opacity: 0.5;
            }
            
            .mobile-regular-empty-text {
                font-size: 1rem;
                font-weight: 500;
            }
            
            .mobile-regular-section-header {
                display: flex;
                align-items: center;
                gap: 8px;
                font-size: 0.85rem;
                font-weight: 600;
                color: #6b7280;
                padding: 16px 4px 8px;
                margin-top: 8px;
                border-top: 1px solid #e5e7eb;
            }
            
            .mobile-regular-section-header:first-child {
                border-top: none;
                margin-top: 0;
                padding-top: 0;
            }
            
            /* Hide desktop week view on mobile */
            .regular-calendar-container {
                display: none !important;
            }
            
            /* Bigger task cards on mobile */
            .mobile-regular-day-view .regular-task-card {
                padding: 16px;
                padding-right: 56px;
                margin-bottom: 12px;
                border-radius: 12px;
            }
            
            .mobile-regular-day-view .regular-task-card .task-title {
                font-size: 1rem;
                margin-bottom: 6px;
            }
            
            .mobile-regular-day-view .regular-task-card .task-time {
                font-size: 0.85rem;
                margin-bottom: 6px;
            }
            
            .mobile-regular-day-view .regular-task-card .task-assignee {
                font-size: 0.8rem;
            }
            
            .mobile-regular-day-view .regular-task-card .task-function {
                font-size: 0.75rem;
                padding: 4px 8px;
            }
            
            .mobile-regular-day-view .regular-task-complete-btn {
                width: 40px;
                height: 40px;
                right: 12px;
            }
            
            .mobile-regular-day-view .regular-task-complete-btn svg {
                width: 20px;
                height: 20px;
            }
            
            /* Hide regular header view switcher on mobile */
            #regularCalendarHeader .calendar-view-switcher {
                display: none;
            }
            
            #regularCalendarHeader h3 {
                font-size: 1rem !important;
            }
        }
        
        /* Demo Data Options */
        .demo-option-btn {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
            width: 100%;
        }
        
        .demo-option-btn:hover {
            border-color: var(--primary);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.15);
        }
        
        .demo-option-icon {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .demo-option-info {
            flex: 1;
            min-width: 0;
        }
        
        .demo-option-info strong {
            display: block;
            font-size: 1rem;
            color: var(--dark);
            margin-bottom: 0.25rem;
        }
        
        .demo-option-info span {
            font-size: 0.8rem;
            color: var(--gray);
        }
        
        /* Hide calendar on desktop when list is active */
        .calendar-container {
            display: none;
        }
        
        .calendar-container.active {
            display: block;
        }
        
        .list-container {
            display: none;
        }
        
        .list-container.active {
            display: block;
        }
        
        /* ===================== */
        /* REGULAR CALENDAR      */
        /* ===================== */
        
        .regular-calendar-container {
            display: none;
        }
        
        .regular-calendar-container.active {
            display: block;
        }
        
        .regular-list-container {
            display: none;
        }
        
        .regular-list-container.active {
            display: block;
        }
        
        /* Control Panel Expandable Rows */
        .control-row {
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 0.5rem;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .control-row:hover {
            background: #f0f0f0;
        }
        
        .control-row-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
        }
        
        .control-row-count {
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .control-row .expand-icon {
            transition: transform 0.2s;
        }
        
        .control-row.expanded .expand-icon {
            transform: rotate(180deg);
        }
        
        .control-row-tasks {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            background: white;
            border-top: 1px solid #e5e7eb;
        }
        
        .control-row.expanded .control-row-tasks {
            max-height: 500px;
            overflow-y: auto;
        }
        
        .control-task-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.6rem 1rem;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            transition: background 0.15s;
        }
        
        .control-task-item:hover {
            background: #f0fdf4;
        }
        
        .control-task-item:last-child {
            border-bottom: none;
        }
        
        .control-task-item.overdue {
            background: #fef2f2;
        }
        
        .control-task-item.overdue:hover {
            background: #fee2e2;
        }
        
        .control-task-item .task-title {
            font-size: 0.85rem;
            color: var(--dark);
            flex: 1;
        }
        
        .control-task-item .task-meta {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            font-size: 0.75rem;
        }
        
        .control-task-item .task-func {
            background: #e0e7ff;
            color: #4338ca;
            padding: 0.15rem 0.4rem;
            border-radius: 4px;
        }
        
        .control-task-item .task-assignee {
            background: #dbeafe;
            color: #1d4ed8;
            padding: 0.15rem 0.4rem;
            border-radius: 4px;
        }
        
        .control-task-item .task-date {
            color: var(--gray);
        }
        
        .control-task-item .task-date.overdue {
            color: #dc2626;
            font-weight: 600;
        }
        
        .regular-schedule-view {
            background: white;
            border-radius: 12px;
            box-shadow: var(--shadow);
            overflow: hidden;
        }
        
        .regular-schedule-header {
            display: flex;
            background: #f9fafb;
            border-bottom: 1px solid #e5e7eb;
        }
        
        .regular-time-gutter {
            width: 60px;
            flex-shrink: 0;
            border-right: 1px solid #e5e7eb;
        }
        
        .regular-days-header {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            flex: 1;
        }
        
        .regular-week-day-header {
            padding: 1rem 0.5rem;
            text-align: center;
            border-right: 1px solid #e5e7eb;
        }
        
        .regular-week-day-header:last-child {
            border-right: none;
        }
        
        .regular-week-day-header .day-name {
            font-weight: 600;
            color: var(--dark);
            font-size: 0.9rem;
        }
        
        .regular-week-day-header.today {
            background: #ecfdf5;
        }
        
        .regular-week-day-header.today .day-name {
            color: var(--success);
        }
        
        .regular-schedule-body {
            display: flex;
            max-height: calc(100vh - 300px);
            min-height: 500px;
            overflow-y: auto;
        }
        
        .regular-time-column {
            width: 60px;
            flex-shrink: 0;
            border-right: 1px solid #e5e7eb;
            background: #f9fafb;
            position: sticky;
            left: 0;
            z-index: 5;
        }
        
        .regular-time-column .time-slot {
            height: 60px;
            padding: 4px 8px;
            font-size: 0.8rem;
            color: #666;
            border-bottom: 1px solid #f0f0f0;
            text-align: right;
            font-weight: 500;
        }
        
        .regular-days-body {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            flex: 1;
            position: relative;
        }
        
        .regular-day-column {
            border-right: 1px solid #e5e7eb;
            position: relative;
            min-height: 960px; /* 16 hours * 60px */
        }
        
        .regular-day-column:last-child {
            border-right: none;
        }
        
        .regular-day-column.today {
            background: #f0fdf4;
        }
        
        .regular-day-column .hour-line {
            position: absolute;
            left: 0;
            right: 0;
            height: 1px;
            background: #f0f0f0;
        }
        
        .regular-task-block {
            position: absolute;
            left: 4px;
            right: 4px;
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            border-left: 5px solid var(--primary);
            border-radius: 8px;
            padding: 8px 10px;
            cursor: pointer;
            transition: all 0.2s;
            overflow: hidden;
            z-index: 1;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }
        
        .regular-task-block:hover {
            box-shadow: 0 6px 16px rgba(34, 197, 94, 0.25);
            transform: scale(1.02);
            z-index: 10;
            border-left-width: 6px;
        }
        
        .regular-task-block .task-time {
            font-size: 0.75rem;
            color: #16a34a;
            font-weight: 700;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .regular-task-block .task-time::before {
            content: '';
            width: 6px;
            height: 6px;
            background: #22c55e;
            border-radius: 50%;
            display: inline-block;
        }
        
        .regular-task-block .task-title {
            font-weight: 600;
            font-size: 0.85rem;
            color: #1a1a1a;
            line-height: 1.3;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            margin-bottom: 4px;
        }
        
        .regular-task-block .task-assignee {
            font-size: 0.7rem;
            color: #525252;
            margin-top: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .regular-task-block .task-assignee::before {
            content: '';
            display: inline-block;
            width: 0.75rem;
            height: 0.75rem;
            background: currentColor;
            -webkit-mask: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2'/%3E%3Ccircle cx='12' cy='7' r='4'/%3E%3C/svg%3E") center/contain no-repeat;
            mask: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2'/%3E%3Ccircle cx='12' cy='7' r='4'/%3E%3C/svg%3E") center/contain no-repeat;
        }
        
        .regular-task-block .task-function {
            font-size: 0.65rem;
            background: rgba(255,255,255,0.85);
            color: #4338ca;
            padding: 2px 6px;
            border-radius: 4px;
            display: inline-block;
            margin-top: 4px;
            font-weight: 500;
            border: 1px solid rgba(67, 56, 202, 0.2);
        }
        
        .regular-task-block.completed {
            opacity: 0.5;
            background: linear-gradient(135deg, #f5f5f5 0%, #e0e0e0 100%);
            border-left-color: #9e9e9e;
        }
        
        .regular-task-block.completed .task-time::before {
            background: #9e9e9e;
        }
        
        .regular-task-block.short {
            padding: 2px 6px;
        }
        
        .regular-task-block.short .task-title {
            font-size: 0.7rem;
        }
        
        .regular-task-block.short .task-assignee,
        .regular-task-block.short .task-function {
            display: none;
        }
        
        .regular-task-block.narrow {
            padding: 4px 6px;
        }
        
        .regular-task-block.narrow .task-time {
            font-size: 0.6rem;
        }
        
        .regular-task-block.narrow .task-title {
            font-size: 0.7rem;
            line-height: 1.1;
        }
        
        .regular-task-block.narrow .task-assignee,
        .regular-task-block.narrow .task-function {
            display: none;
        }
        
        /* Old styles for compatibility */
        .regular-week-view {
            background: white;
            border-radius: 12px;
            box-shadow: var(--shadow);
            overflow: hidden;
        }
        
        .regular-week-header {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            background: #f9fafb;
            border-bottom: 1px solid #e5e7eb;
        }
        
        .regular-week-body {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            min-height: 400px;
        }
        
        .regular-week-day-column {
            border-right: 1px solid #e5e7eb;
            padding: 0.5rem;
            min-height: 300px;
        }
        
        .regular-week-day-column:last-child {
            border-right: none;
        }
        
        .regular-week-day-column.today {
            background: #f0fdf4;
        }
        
        .regular-task-card {
            background: white;
            border: 1px solid #e5e7eb;
            border-left: 4px solid var(--primary);
            border-radius: 8px;
            padding: 0.6rem;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .regular-task-card:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transform: translateY(-1px);
        }
        
        .regular-task-card .task-time {
            font-size: 0.75rem;
            color: var(--gray);
            margin-bottom: 0.25rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        
        .regular-task-card .task-title {
            font-weight: 500;
            font-size: 0.85rem;
            color: var(--dark);
            margin-bottom: 0.25rem;
            padding-right: 40px;
        }
        
        .regular-task-card .task-assignee {
            font-size: 0.7rem;
            color: var(--gray);
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        
        .regular-task-card .task-function {
            font-size: 0.65rem;
            background: #e0e7ff;
            color: #4338ca;
            padding: 0.15rem 0.4rem;
            border-radius: 4px;
            display: inline-block;
            margin-top: 0.25rem;
        }
        
        /* Complete button for regular tasks */
        .regular-task-complete-btn {
            position: absolute;
            top: 50%;
            right: 8px;
            transform: translateY(-50%);
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid #d1d5db;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 5;
        }
        
        .regular-task-complete-btn:hover {
            border-color: var(--success);
            background: #f0fdf4;
        }
        
        .regular-task-complete-btn:active {
            transform: translateY(-50%) scale(0.9);
        }
        
        .regular-task-complete-btn svg {
            width: 16px;
            height: 16px;
            color: #d1d5db;
            transition: color 0.2s;
        }
        
        .regular-task-complete-btn:hover svg {
            color: var(--success);
        }
        
        .regular-task-complete-btn.completed {
            border-color: var(--success);
            background: var(--success);
        }
        
        .regular-task-complete-btn.completed svg {
            color: white;
        }
        
        .regular-task-card.completed {
            opacity: 0.6;
            border-left-color: var(--success);
        }
        
        .regular-task-card.completed .task-title {
            text-decoration: line-through;
            color: var(--gray);
        }
        
        /* Empty day placeholder */
        .regular-day-empty {
            text-align: center;
            color: #d1d5db;
            font-size: 0.8rem;
            padding: 2rem 0.5rem;
        }
        
        /* ===================== */
        /* IMPROVED LIST VIEW    */
        /* ===================== */
        
        .task-list-card {
            background: white;
            border-radius: 12px;
            padding: 1rem;
            margin-bottom: 0.75rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            border-left: 4px solid var(--gray);
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .task-list-card:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .task-list-card.priority-high { border-left-color: var(--danger); }
        .task-list-card.priority-medium { border-left-color: var(--warning); }
        .task-list-card.priority-low { border-left-color: var(--success); }
        
        .task-list-card.status-done {
            opacity: 0.6;
            border-left-color: var(--success);
        }
        
        .task-list-checkbox {
            width: 22px;
            height: 22px;
            border: 2px solid #d1d5db;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: all 0.2s;
        }
        
        .task-list-checkbox:hover {
            border-color: var(--success);
            background: #ecfdf5;
        }
        
        .task-list-checkbox.checked {
            background: var(--success);
            border-color: var(--success);
        }
        
        .task-list-checkbox.checked svg {
            color: white;
        }
        
        .task-list-content {
            flex: 1;
            min-width: 0;
        }
        
        .task-list-title {
            font-weight: 500;
            font-size: 1rem;
            color: var(--dark);
            margin-bottom: 0.35rem;
        }
        
        .task-list-card.status-done .task-list-title {
            text-decoration: line-through;
            color: var(--gray);
        }
        
        .task-list-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            font-size: 0.8rem;
            color: var(--gray);
        }
        
        .task-list-meta-item {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        
        .task-list-meta-item.overdue {
            color: var(--danger);
            font-weight: 500;
        }
        
        .task-list-actions {
            display: flex;
            gap: 0.5rem;
            flex-shrink: 0;
        }
        
        /* Mobile Regular Calendar */
        @media (max-width: 767px) {
            .regular-week-header {
                display: flex;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .regular-week-day-header {
                min-width: 80px;
                flex-shrink: 0;
            }
            
            .regular-week-body {
                display: flex;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .regular-week-day-column {
                min-width: 150px;
                flex-shrink: 0;
            }
            
            .task-list-card {
                flex-direction: column;
                gap: 0.75rem;
            }
            
            .task-list-actions {
                width: 100%;
                justify-content: flex-end;
            }
        }
        
        /* ===================== */
        /* COMMENTS SYSTEM       */
        /* ===================== */
        
        .comments-section {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 2px solid #e5e7eb;
        }
        
        .comments-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
            color: var(--dark);
            font-weight: 600;
            font-size: 0.95rem;
        }
        
        .comments-header .comment-count {
            background: var(--primary);
            color: white;
            font-size: 0.75rem;
            padding: 0.15rem 0.5rem;
            border-radius: 10px;
            font-weight: 600;
        }
        
        .comments-list {
            max-height: 250px;
            overflow-y: auto;
            margin-bottom: 1rem;
            padding-right: 0.5rem;
        }
        
        .comments-list::-webkit-scrollbar {
            width: 6px;
        }
        
        .comments-list::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }
        
        .comments-list::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }
        
        .comment-item {
            background: #f9fafb;
            border-radius: 12px;
            padding: 0.75rem 1rem;
            margin-bottom: 0.75rem;
            border-left: 3px solid var(--primary);
            animation: slideIn 0.2s ease-out;
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .comment-item.own-comment {
            background: #ecfdf5;
            border-left-color: var(--success);
        }
        
        .comment-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.4rem;
        }
        
        .comment-author {
            font-weight: 600;
            font-size: 0.85rem;
            color: var(--dark);
        }
        
        .comment-time {
            font-size: 0.75rem;
            color: var(--gray);
        }
        
        .comment-text {
            font-size: 0.9rem;
            color: #374151;
            line-height: 1.5;
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        .comment-text a {
            color: #2563eb;
            text-decoration: underline;
            word-break: break-all;
            transition: color 0.15s;
        }
        
        .comment-text a:hover {
            color: #1d4ed8;
        }
        
        .comment-text a:visited {
            color: #7c3aed;
        }
        
        /* File Attachments */
        .task-files-section {
            margin-top: 0.5rem;
        }
        
        .task-files-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }
        
        .task-files-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }
        
        .task-file-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.6rem 0.75rem;
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            transition: all 0.2s;
        }
        
        .task-file-item:hover {
            background: #f0fdf4;
            border-color: var(--primary);
        }
        
        .task-file-icon {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            font-size: 0.7rem;
            font-weight: 700;
            color: white;
        }
        
        .task-file-icon.pdf { background: #ef4444; }
        .task-file-icon.doc { background: #3b82f6; }
        .task-file-icon.xls { background: #22c55e; }
        .task-file-icon.img { background: #f59e0b; }
        .task-file-icon.other { background: #6b7280; }
        
        .file-role-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.2rem;
            font-size: 0.65rem;
            font-weight: 600;
            padding: 0.1rem 0.4rem;
            border-radius: 4px;
            line-height: 1.2;
        }
        
        .file-role-badge.creator {
            background: #dbeafe;
            color: #1d4ed8;
        }
        
        .file-role-badge.executor {
            background: #dcfce7;
            color: #16a34a;
        }
        
        .task-file-info {
            flex: 1;
            min-width: 0;
        }
        
        .task-file-name {
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--dark);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .task-file-meta {
            font-size: 0.75rem;
            color: var(--gray);
            display: flex;
            gap: 0.5rem;
        }
        
        .task-file-actions {
            display: flex;
            gap: 0.25rem;
            flex-shrink: 0;
        }
        
        .task-file-actions button {
            width: 32px;
            height: 32px;
            border: none;
            background: transparent;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
            color: var(--gray);
        }
        
        .task-file-actions button:hover {
            background: #e5e7eb;
        }
        
        .task-file-actions button.delete-file:hover {
            background: #fef2f2;
            color: #ef4444;
        }
        
        .file-upload-area {
            border: 2px dashed #d1d5db;
            border-radius: 10px;
            padding: 1rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--gray);
            font-size: 0.85rem;
        }
        
        .file-upload-area:hover,
        .file-upload-area.dragover {
            border-color: var(--primary);
            background: #f0fdf4;
            color: var(--primary);
        }
        
        .file-upload-area .upload-icon {
            margin-bottom: 0.25rem;
        }
        
        .file-upload-progress {
            display: none;
            margin-top: 0.5rem;
        }
        
        .file-upload-progress .progress-bar {
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            overflow: hidden;
        }
        
        .file-upload-progress .progress-fill {
            height: 100%;
            background: var(--primary);
            border-radius: 3px;
            transition: width 0.2s;
        }
        
        .file-upload-progress .progress-text {
            font-size: 0.75rem;
            color: var(--gray);
            margin-top: 0.25rem;
        }
        
        /* Image preview in files */
        .task-file-item.image-preview {
            flex-direction: column;
            align-items: flex-start;
        }
        
        .task-file-item.image-preview .file-preview-img {
            width: 100%;
            max-height: 200px;
            object-fit: cover;
            border-radius: 8px;
            margin-top: 0.5rem;
            cursor: pointer;
        }
        
        .task-file-item .file-preview-row {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            width: 100%;
        }
        
        .comment-input-wrapper {
            display: flex;
            gap: 0.5rem;
            align-items: flex-end;
        }
        
        .comment-input {
            flex: 1;
            min-height: 44px;
            max-height: 120px;
            padding: 0.6rem 0.9rem;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            font-size: 0.9rem;
            resize: none;
            font-family: inherit;
            transition: border-color 0.2s;
        }
        
        .comment-input:focus {
            outline: none;
            border-color: var(--primary);
        }
        
        .comment-send-btn {
            width: 44px;
            height: 44px;
            border-radius: 12px;
            background: var(--primary);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            flex-shrink: 0;
        }
        
        .comment-send-btn:hover {
            background: var(--primary-dark);
        }
        
        .comment-send-btn:disabled {
            background: #d1d5db;
            cursor: not-allowed;
        }
        
        .comments-empty {
            text-align: center;
            padding: 1.5rem;
            color: var(--gray);
            font-size: 0.9rem;
        }
        
        .comments-section.hidden { display: none; }
        
        /* Audit log entries */
        .audit-entry {
            display: flex;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            border-bottom: 1px solid #f3f4f6;
            font-size: 0.8rem;
            line-height: 1.4;
        }
        .audit-entry:last-child { border-bottom: none; }
        .audit-icon { 
            width: 24px; height: 24px; border-radius: 50%; 
            display: flex; align-items: center; justify-content: center; 
            flex-shrink: 0; font-size: 0.7rem; margin-top: 2px;
        }
        .audit-body { flex: 1; }
        .audit-user { font-weight: 600; color: var(--text); }
        .audit-action { color: var(--gray); }
        .audit-time { font-size: 0.7rem; color: #9ca3af; margin-top: 2px; }
        .audit-value { 
            display: inline-block; padding: 0.1rem 0.35rem; border-radius: 4px; 
            font-size: 0.75rem; font-weight: 500; background: #f3f4f6;
        }
        
        /* Escalation badges */
        .escalation-badge {
            display: inline-flex; align-items: center; gap: 0.25rem;
            padding: 0.15rem 0.5rem; border-radius: 10px;
            font-size: 0.7rem; font-weight: 600;
        }
        .escalation-1 { background: #fef3c7; color: #92400e; }
        .escalation-2 { background: #fed7aa; color: #9a3412; }
        .escalation-3 { background: #fee2e2; color: #dc2626; }
        
        /* Kanban Board */
        .kanban-board {
            display: flex; gap: 0.75rem; overflow-x: auto;
            padding: 0.5rem 0; min-height: 70vh;
            -webkit-overflow-scrolling: touch;
        }
        .kanban-column {
            flex: 0 0 280px; max-width: 280px;
            background: #f3f4f6; border-radius: 12px;
            display: flex; flex-direction: column; max-height: 80vh;
        }
        .kanban-column-header {
            padding: 0.75rem; font-weight: 700; font-size: 0.85rem;
            display: flex; justify-content: space-between; align-items: center;
            border-radius: 12px 12px 0 0; position: sticky; top: 0;
        }
        .kanban-column-count {
            background: rgba(255,255,255,0.7); padding: 0.1rem 0.5rem;
            border-radius: 10px; font-size: 0.75rem; font-weight: 700;
        }
        .kanban-column-body {
            flex: 1; overflow-y: auto; padding: 0.5rem;
            display: flex; flex-direction: column; gap: 0.5rem;
        }
        .kanban-card {
            background: white; border-radius: 10px; padding: 0.7rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08); cursor: pointer;
            border-left: 3px solid transparent; transition: box-shadow 0.15s;
        }
        .kanban-card:hover { box-shadow: 0 3px 8px rgba(0,0,0,0.12); }
        .kanban-card.overdue { border-left-color: #ef4444; }
        .kanban-card.today { border-left-color: #f59e0b; }
        .kanban-card-title {
            font-size: 0.85rem; font-weight: 600; margin-bottom: 0.35rem;
            line-height: 1.3; color: var(--text);
        }
        .kanban-card-meta {
            display: flex; flex-wrap: wrap; gap: 0.3rem; font-size: 0.72rem; color: #6b7280;
        }
        .kanban-card-meta span {
            display: inline-flex; align-items: center; gap: 0.2rem;
        }
        .kanban-card-badge {
            display: inline-block; padding: 0.1rem 0.35rem; border-radius: 6px;
            font-size: 0.68rem; font-weight: 600;
        }
        .kanban-card.dragging { opacity: 0.4; }
        .kanban-column-body.drag-over { background: #e0f2fe; border-radius: 0 0 12px 12px; }
        @media(max-width:768px) {
            .kanban-board { gap: 0.5rem; }
            .kanban-column { flex: 0 0 250px; max-width: 250px; }
        }
        
        /* Skeleton loading */
        .skeleton-card {
            background: white;
            padding: 0.75rem 1rem;
            border-left: 4px solid #e5e7eb;
            border-bottom: 1px solid #f0f0f0;
            animation: skeletonPulse 1.2s ease-in-out infinite;
        }
        
        .skeleton-line {
            height: 14px;
            background: #e5e7eb;
            border-radius: 4px;
            margin-bottom: 0.4rem;
        }
        
        .skeleton-line.short { width: 40%; }
        .skeleton-line.medium { width: 65%; }
        .skeleton-line.long { width: 90%; }
        
        .skeleton-row {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        
        .skeleton-circle {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: #e5e7eb;
            flex-shrink: 0;
        }
        
        @keyframes skeletonPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @media (max-width: 767px) {
            .comments-list { max-height: 200px; }
            .comment-input { font-size: 16px; }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-content">
            <div class="logo">
                <i data-lucide="rocket" class="icon"></i> TALKO System
                <span class="company-badge" id="companyBadge" style="display:none;"></span>
            </div>
            <div class="header-actions">
                <a href="https://chatgpt.com/g/g-684bb075301481918669f787231e1af7-radar-ai-alex-talko" target="_blank" class="header-ai-btn" title="Питання до керівника">
                    <i data-lucide="target" class="icon"></i> <span data-i18n="radarAI">Керівник</span>
                </a>
                <a href="https://chatgpt.com/g/g-685640bc592881918743da9332b83f31-ai-alex-talko-technical-lead" target="_blank" class="header-ai-btn tech" title="Помічник">
                    <i data-lucide="wrench" class="icon"></i> <span data-i18n="techAI">Помічник</span>
                </a>
                <div class="lang-switcher">
                    <button class="lang-btn active" onclick="setLanguage('ua')" id="langUA">UA</button>
                    <button class="lang-btn" onclick="setLanguage('ru')" id="langRU">RU</button>
                    <button class="lang-btn" onclick="setLanguage('pl')" id="langPL">PL</button>
                </div>
                <div class="notification-bell" id="notificationBell" onclick="toggleNotificationPanel()" style="position:relative;cursor:pointer;padding:0.4rem;border-radius:8px;display:none;" title="Сповіщення">
                    <i data-lucide="bell" class="icon" style="width:20px;height:20px;"></i>
                    <span id="notificationBadge" style="position:absolute;top:0;right:0;width:18px;height:18px;background:#ef4444;color:white;font-size:0.65rem;font-weight:700;border-radius:50%;display:none;align-items:center;justify-content:center;line-height:1;">0</span>
                </div>
                <div class="user-info" id="currentUserInfo" onclick="openProfileModal()" style="cursor:pointer;" title="Мій профіль">
                    <span><i data-lucide="user" class="icon"></i> <span id="currentUserName">...</span></span>
                    <span id="currentUserRole" style="opacity:0.8;font-size:0.8rem;"></span>
                </div>
                <button class="header-btn" onclick="logout()" id="logoutBtn" style="display:none;"><i data-lucide="log-out" class="icon"></i> <span data-i18n="logout">Вийти</span></button>
                <button class="header-btn" onclick="openDemoDataModal()" id="demoDataBtnDesktop" style="display:none;background:rgba(239,68,68,0.3);"><i data-lucide="database" class="icon"></i> Демо</button>
                <button class="mobile-logout-btn" onclick="logout()"><i data-lucide="log-out" class="icon" style="width:18px;height:18px;"></i></button>
            </div>
        </div>
    </header>

    <div class="container">
        <!-- LOADING -->
        <div id="loadingPage" class="loading">
            <div class="spinner"></div>
        </div>

        <!-- AUTH PAGE -->
        <div id="authPage" class="auth-container" style="display:none;">
            <div class="auth-card">
                <div class="auth-header">
                    <h2><i data-lucide="rocket" class="icon icon-lg"></i> TALKO System</h2>
                    <p data-i18n="authSubtitle">Управління завданнями для бізнесу</p>
                </div>
                <div class="auth-body">
                    <div id="authMessage" class="auth-message" style="display:none;"></div>
                    
                    <!-- NO ACCESS -->
                    <div id="noAccessCard" class="no-access-card" style="display:none;">
                        <h3><i data-lucide="building-2" class="icon"></i> Створити компанію</h3>
                        <p style="font-size:0.9rem;color:#525252;margin-bottom:1rem;">Ваш email не прив'язаний до жодної компанії. Створіть нову або зверніться до адміністратора.</p>
                        <div id="selfRegForm">
                            <div class="auth-input-group">
                                <label>Назва компанії *</label>
                                <input type="text" id="selfRegCompanyName" class="form-input" placeholder="ТОВ Моя Компанія" required>
                            </div>
                            <div class="auth-input-group">
                                <label>Ваше ім'я *</label>
                                <input type="text" id="selfRegOwnerName" class="form-input" placeholder="Іван Петренко" required>
                            </div>
                            <button onclick="selfRegisterCompany()" class="btn btn-success" style="width:100%;margin-top:0.5rem;" id="selfRegBtn">
                                <i data-lucide="rocket" class="icon"></i> Створити компанію
                            </button>
                        </div>
                        <div style="display:flex;gap:0.5rem;margin-top:0.75rem;">
                            <a href="https://alextalko.com" target="_blank" class="btn" style="flex:1;text-align:center;font-size:0.85rem;"><i data-lucide="phone" class="icon icon-sm"></i> Підтримка</a>
                            <button onclick="logout()" class="btn" style="flex:1;font-size:0.85rem;"><i data-lucide="refresh-cw" class="icon icon-sm"></i> Інший email</button>
                        </div>
                    </div>
                    
                    <!-- LOGIN FORM -->
                    <div id="loginForm">
                        <div class="auth-input-group">
                            <label>Email:</label>
                            <input type="email" id="loginEmail" class="form-input" placeholder="your@email.com" autocomplete="email">
                        </div>
                        <div class="auth-input-group">
                            <label data-i18n="password">Пароль:</label>
                            <div class="input-wrapper">
                                <input type="password" id="loginPassword" class="form-input" placeholder="••••••••" autocomplete="current-password">
                                <button type="button" class="password-toggle" onclick="togglePassword('loginPassword', this)"><i data-lucide="eye" class="icon icon-sm"></i></button>
                            </div>
                        </div>
                        <button onclick="signInWithEmail()" class="auth-btn-primary auth-btn-login">
                            <i data-lucide="log-in" class="icon icon-lg"></i> <span data-i18n="signIn">Увійти</span>
                        </button>
                        <a href="#" onclick="resetPassword(); return false;" class="auth-forgot-link" data-i18n="forgotPassword">Забули пароль?</a>
                        
                        <div class="auth-divider"><span data-i18n="haveInvite">Перший вхід?</span></div>
                        <button onclick="showRegisterForm()" class="auth-btn-primary auth-btn-register">
                            <i data-lucide="user-plus" class="icon icon-lg"></i> <span data-i18n="registerBtn">Активувати доступ</span>
                        </button>
                        
                        <!-- Акордеон з інструкцією -->
                        <div style="margin-top:1.25rem;">
                            <button onclick="toggleAuthHelp()" id="authHelpToggle" style="width:100%;background:none;border:1px solid #e5e7eb;padding:0.75rem 1rem;border-radius:12px;cursor:pointer;display:flex;align-items:center;justify-content:space-between;font-size:0.9rem;color:var(--gray);min-height:48px;">
                                <span style="display:flex;align-items:center;gap:0.5rem;">
                                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>
                                    <span data-i18n="howToLogin">Як увійти?</span>
                                </span>
                                <svg id="authHelpArrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="transition:transform 0.2s;"><polyline points="6 9 12 15 18 9"/></svg>
                            </button>
                            <div id="authHelpContent" style="display:none;padding:1rem;background:#f9fafb;border-radius:0 0 12px 12px;border:1px solid #e5e7eb;border-top:none;font-size:0.85rem;line-height:1.7;">
                                <div style="margin-bottom:0.75rem;">
                                    <div style="display:flex;align-items:center;gap:0.4rem;font-weight:600;color:var(--dark);margin-bottom:0.3rem;">
                                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#9b59b6" stroke-width="2"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>
                                        <span data-i18n="forOwners">Для власників:</span>
                                    </div>
                                    <div style="color:var(--gray);padding-left:1.2rem;" data-i18n="ownersInstruction">
                                        Перший раз → "Активувати доступ"<br>
                                        Далі → "Увійти" з email та паролем
                                    </div>
                                </div>
                                <div>
                                    <div style="display:flex;align-items:center;gap:0.4rem;font-weight:600;color:var(--dark);margin-bottom:0.3rem;">
                                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#22c55e" stroke-width="2"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/></svg>
                                        <span data-i18n="forEmployees">Для співробітників:</span>
                                    </div>
                                    <div style="color:var(--gray);padding-left:1.2rem;" data-i18n="employeesInstruction">
                                        Перейдіть за посиланням від керівника<br>
                                        Увійдіть через Google з робочим email
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <p style="text-align:center;margin-top:1rem;font-size:0.85rem;color:var(--gray);">
                            <span data-i18n="noAccess">Немає доступу?</span> <a href="https://alextalko.com" target="_blank" style="color:var(--info);font-weight:500;" data-i18n="contactUs">Зв'яжіться з нами</a>
                        </p>
                    </div>
                    
                    <!-- REGISTER FORM -->
                    <div id="registerForm" style="display:none;">
                        <h3 style="text-align:center;margin-bottom:1.25rem;color:var(--dark);font-size:1.1rem;"><i data-lucide="user-plus" class="icon"></i> <span data-i18n="registerTitle">Реєстрація за запрошенням</span></h3>
                        <div class="auth-input-group">
                            <label>Email:</label>
                            <input type="email" id="registerEmail" class="form-input" placeholder="your@email.com" autocomplete="email">
                        </div>
                        <div class="auth-input-group">
                            <label data-i18n="createPassword">Придумайте пароль:</label>
                            <div class="input-wrapper">
                                <input type="password" id="registerPassword" class="form-input" placeholder="мінімум 6 символів" autocomplete="new-password">
                                <button type="button" class="password-toggle" onclick="togglePassword('registerPassword', this)"><i data-lucide="eye" class="icon icon-sm"></i></button>
                            </div>
                        </div>
                        <div class="auth-input-group">
                            <label data-i18n="confirmPassword">Підтвердіть пароль:</label>
                            <div class="input-wrapper">
                                <input type="password" id="registerPasswordConfirm" class="form-input" placeholder="••••••••" autocomplete="new-password">
                                <button type="button" class="password-toggle" onclick="togglePassword('registerPasswordConfirm', this)"><i data-lucide="eye" class="icon icon-sm"></i></button>
                            </div>
                        </div>
                        <button onclick="registerWithInvite()" class="auth-btn-primary auth-btn-login">
                            <i data-lucide="check" class="icon icon-lg"></i> <span data-i18n="registerSubmit">Зареєструватися</span>
                        </button>
                        <p style="text-align:center;margin-top:1.25rem;">
                            <a href="#" onclick="showLoginForm()" style="color:var(--info);font-size:0.9rem;font-weight:500;" data-i18n="backToLogin">← Повернутися до входу</a>
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <!-- MAIN INTERFACE -->
        <div id="mainInterface" class="main-interface">
            <!-- Pull-to-refresh indicator -->
            <div id="ptrIndicator" class="ptr-indicator">
                <div class="ptr-spinner"></div>
                <span>Оновлення...</span>
            </div>
            <div class="tab-navigation">
                <button class="tab-btn active" onclick="switchTab('myday')"><i data-lucide="sun" class="icon"></i> <span data-i18n="tabMyDay">Мій день</span></button>
                <button class="tab-btn" onclick="switchTab('tasks')"><i data-lucide="clipboard-list" class="icon"></i> <span data-i18n="tabTasks">Завдання</span></button>
                <button class="tab-btn" onclick="switchTab('projects')"><i data-lucide="folder-kanban" class="icon"></i> <span data-i18n="tabProjects">Проєкти</span></button>
                <button class="tab-btn" onclick="switchTab('control')"><i data-lucide="layout-dashboard" class="icon"></i> <span data-i18n="tabControl">Контроль</span></button>
                <button class="tab-btn" onclick="switchTab('processes')"><i data-lucide="git-branch" class="icon"></i> <span data-i18n="tabProcesses">Процеси</span></button>
                <button class="tab-btn" onclick="switchTab('regular')"><i data-lucide="repeat" class="icon"></i> <span data-i18n="tabRegular">Регулярні</span></button>
                <button class="tab-btn" onclick="switchTab('functions')"><i data-lucide="settings" class="icon"></i> <span data-i18n="tabFunctions">Функції</span></button>
                <button class="tab-btn" onclick="switchTab('users')"><i data-lucide="users" class="icon"></i> <span data-i18n="tabUsers">Співробітники</span></button>
                <button class="tab-btn" onclick="switchTab('analytics')"><i data-lucide="bar-chart-3" class="icon"></i> <span data-i18n="tabAnalytics">Аналітика</span></button>
                <button class="tab-btn" onclick="switchTab('admin')" id="adminTabBtn" style="display:none;background:#fee2e2;color:#dc2626;"><i data-lucide="shield" class="icon"></i> <span data-i18n="tabAdmin">Адмін</span></button>
            </div>

            <!-- MY DAY TAB -->
            <div id="mydayTab" class="tab-content active">
                <div class="myday-header">
                    <div class="myday-date">
                        <i data-lucide="sun" class="icon icon-lg" style="color:var(--warning);"></i>
                        <div>
                            <h2 id="mydayTitle" data-i18n="myDay">Мій день</h2>
                            <span id="mydayDateText" class="myday-date-text"></span>
                        </div>
                    </div>
                    <div style="display:flex;align-items:center;gap:0.75rem;">
                        <button onclick="startFocusMode()" class="btn btn-success btn-sm" id="focusModeBtn" style="padding:0.4rem 0.75rem;font-size:0.85rem;white-space:nowrap;">
                            <i data-lucide="play" class="icon icon-sm"></i> <span data-i18n="focusMode">Фокус</span>
                        </button>
                        <div class="myday-progress">
                            <div class="myday-progress-bar">
                                <div class="myday-progress-fill" id="mydayProgressFill"></div>
                            </div>
                            <span id="mydayProgressText" class="myday-progress-text">0/0</span>
                        </div>
                        <button onclick="refreshMyDay()" class="myday-refresh-btn" title="Оновити">
                            <i data-lucide="refresh-cw" class="icon"></i>
                        </button>
                    </div>
                </div>
                
                <div id="mydayContent" class="myday-content">
                    <!-- Контент генерується динамічно -->
                </div>
            </div>

            <!-- TASKS -->
            <div id="tasksTab" class="tab-content">
                
                <!-- Calendar Header with Navigation -->
                <div class="calendar-header" id="calendarHeader">
                    <div class="calendar-nav">
                        <button class="calendar-nav-btn" onclick="calendarPrev()">
                            <i data-lucide="chevron-left" class="icon"></i>
                        </button>
                        <button class="calendar-today-btn" onclick="calendarToday()">Сьогодні</button>
                        <button class="calendar-nav-btn" onclick="calendarNext()">
                            <i data-lucide="chevron-right" class="icon"></i>
                        </button>
                    </div>
                    
                    <div class="calendar-title" id="calendarTitle"></div>
                    
                    <button class="btn btn-success" onclick="openTaskModal()">
                        <i data-lucide="plus" class="icon"></i> <span class="hide-mobile" data-i18n="add">Додати</span>
                    </button>
                    
                    <div class="calendar-view-switcher">
                        <button class="calendar-view-btn active" data-view="day" onclick="setCalendarView('day')" data-i18n="day" data-short="День">День</button>
                        <button class="calendar-view-btn" data-view="week" onclick="setCalendarView('week')" data-i18n="week" data-short="Тижд">Тиждень</button>
                        <button class="calendar-view-btn" data-view="month" onclick="setCalendarView('month')" data-i18n="month" data-short="Міс">Місяць</button>
                        <button class="calendar-view-btn" data-view="list" onclick="setCalendarView('list')" data-i18n="list" data-short="Список">Список</button>
                        <button class="calendar-view-btn" data-view="kanban" onclick="setCalendarView('kanban')" data-short="Канбан">Канбан</button>
                        <button class="calendar-view-btn" data-view="deadlines" onclick="setCalendarView('deadlines')" data-short="Терміни">Терміни</button>
                    </div>
                </div>
                
                <!-- Calendar Filters -->
                <div class="filters-row" id="calendarFiltersRow" style="background:white;padding:0.5rem 1rem;border-radius:12px;margin-bottom:0.5rem;box-shadow:var(--shadow);display:none;flex-wrap:wrap;gap:0.5rem;align-items:center;">
                    <button class="btn btn-sm" id="calendarMyBtn" onclick="filterCalendarMy()" style="padding:0.35rem 0.7rem;font-size:0.82rem;white-space:nowrap;"><i data-lucide="user" class="icon icon-sm"></i> Мої</button>
                    <select class="filter-select" id="calendarAssigneeFilter" onchange="renderCalendar()" style="font-size:0.82rem;padding:0.35rem;max-width:180px;">
                        <option value="" data-i18n="allAssignees">Всі виконавці</option>
                    </select>
                    <select class="filter-select" id="calendarFunctionFilter" onchange="renderCalendar()" style="font-size:0.82rem;padding:0.35rem;max-width:180px;">
                        <option value="" data-i18n="allFunctions">Всі функції</option>
                    </select>
                    <span id="calendarFilterCount" style="font-size:0.78rem;color:#6b7280;margin-left:auto;"></span>
                </div>
                
                <!-- Mobile Week Strip (Google Calendar style) -->
                <div class="mobile-week-strip" id="mobileWeekStrip">
                    <div class="week-strip-days" id="weekStripDays">
                        <!-- Generated by JS -->
                    </div>
                </div>
                
                <!-- Calendar Container -->
                <div class="calendar-container active" id="calendarContainer">
                    <!-- Day View -->
                    <div class="calendar-day-view" id="calendarDayView">
                        <div class="calendar-day-header">
                            <div class="calendar-time-gutter"></div>
                            <div class="calendar-day-column-header today" id="dayColumnHeader">
                                <div class="day-name">Середа</div>
                                <div class="day-number">25</div>
                            </div>
                        </div>
                        <div class="calendar-allday-section" id="calendarAllday">
                            <div class="calendar-allday-label" data-i18n="noTime">Без часу</div>
                        </div>
                        <div class="calendar-day-body" id="calendarDayBody">
                            <div class="calendar-time-slots" id="calendarTimeSlots"></div>
                            <div class="calendar-events-container" id="calendarEventsContainer">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Week View -->
                    <div class="calendar-week-view" id="calendarWeekView" style="display:none;">
                        <div class="calendar-week-header" id="weekHeader"></div>
                        <div class="calendar-week-body" id="weekBody"></div>
                    </div>
                    
                    <!-- Month View -->
                    <div class="calendar-month-view" id="calendarMonthView" style="display:none;">
                        <div class="calendar-month-header" id="calendarMonthDayNames">
                            <!-- Заповнюється через JS -->
                        </div>
                        <div class="calendar-month-body" id="monthBody"></div>
                    </div>
                </div>
                
                <!-- List Container (existing table view) -->
                <div class="list-container" id="listContainer">
                    <!-- Mobile filter bar -->
                    <div class="mobile-filter-bar" id="mobileFilterBar">
                        <div style="position:relative;flex:1;display:flex;align-items:center;">
                            <i data-lucide="search" class="icon" style="width:14px;height:14px;position:absolute;left:10px;color:#9ca3af;pointer-events:none;"></i>
                            <input type="text" id="mobileTaskSearchInput" placeholder="Пошук завдань..." oninput="document.getElementById('taskSearchInput').value=this.value;debouncedRenderTasks()" style="width:100%;padding:0.5rem 0.5rem 0.5rem 32px;font-size:0.85rem;border:1px solid #e5e7eb;border-radius:10px;outline:none;background:white;" onfocus="this.style.borderColor='#22c55e'" onblur="this.style.borderColor='#e5e7eb'">
                        </div>
                        <button class="mobile-filter-btn" onclick="setMobileQuickFilter('my')">
                            <i data-lucide="user" class="icon icon-sm"></i> Мої
                        </button>
                        <button class="mobile-filter-btn" onclick="setMobileQuickFilter('today')">
                            <i data-lucide="calendar" class="icon icon-sm"></i> Сьогодні
                        </button>
                        <button class="mobile-filter-btn" onclick="openFilterModal()">
                            <i data-lucide="sliders" class="icon icon-sm"></i> Фільтри
                            <span class="filter-count" id="activeFilterCount" style="display:none;">0</span>
                        </button>
                    </div>
                    
                    <div class="controls" style="margin-bottom:0.5rem;">
                        <div class="filters-row" style="display:flex;flex-wrap:wrap;gap:0.4rem;align-items:center;padding:0.5rem 0.75rem;background:white;border-radius:12px;box-shadow:var(--shadow);">
                            <button class="btn btn-success" onclick="openTaskModal()" style="padding:0.35rem 0.7rem;font-size:0.8rem;"><i data-lucide="plus" class="icon" style="width:14px;height:14px;"></i> <span data-i18n="addTask">Завдання</span></button>
                            <div style="position:relative;display:inline-block;" id="exportDropdownWrap">
                                <button class="btn" style="background:#2ecc71;padding:0.35rem 0.7rem;font-size:0.8rem;" onclick="toggleExportDropdown(event)"><i data-lucide="download" class="icon" style="width:14px;height:14px;"></i> Експорт <i data-lucide="chevron-down" class="icon" style="width:12px;height:12px;"></i></button>
                                <div id="exportDropdown" style="display:none;position:absolute;top:100%;left:0;margin-top:4px;background:white;border-radius:8px;box-shadow:0 4px 16px rgba(0,0,0,0.15);border:1px solid #e5e7eb;z-index:100;min-width:160px;overflow:hidden;">
                                    <button onclick="exportTasksCSV();closeExportDropdown()" style="display:flex;align-items:center;gap:0.5rem;width:100%;padding:0.6rem 1rem;border:none;background:none;cursor:pointer;font-size:0.85rem;text-align:left;transition:background 0.15s;" onmouseover="this.style.background='#f0fdf4'" onmouseout="this.style.background='none'">
                                        <i data-lucide="file-text" class="icon" style="width:16px;height:16px;color:#22c55e;"></i> CSV (.csv)
                                    </button>
                                    <button onclick="exportTasksXLSX();closeExportDropdown()" style="display:flex;align-items:center;gap:0.5rem;width:100%;padding:0.6rem 1rem;border:none;background:none;cursor:pointer;font-size:0.85rem;text-align:left;transition:background 0.15s;" onmouseover="this.style.background='#f0fdf4'" onmouseout="this.style.background='none'">
                                        <i data-lucide="table" class="icon" style="width:16px;height:16px;color:#16a34a;"></i> Excel (.xlsx)
                                    </button>
                                </div>
                            </div>
                            <button class="btn" id="archiveToggleBtn" onclick="toggleArchiveView()" style="background:#6b7280;padding:0.35rem 0.7rem;font-size:0.8rem;"><i data-lucide="archive" class="icon" style="width:14px;height:14px;"></i> <span data-i18n="archive">Архів</span></button>
                            <span style="width:1px;height:22px;background:#e0e0e0;margin:0 0.15rem;"></span>
                            <div class="task-type-tabs" style="display:flex;gap:1px;background:#e5e7eb;padding:2px;border-radius:8px;">
                                <button class="task-type-tab active" data-value="" onclick="setTaskTypeFilter(this)" style="padding:0.3rem 0.6rem;border:none;border-radius:6px;cursor:pointer;font-size:0.78rem;font-weight:600;background:#22c55e;color:white;white-space:nowrap;transition:all 0.15s;">Всі</button>
                                <button class="task-type-tab" data-value="my" onclick="setTaskTypeFilter(this)" style="padding:0.3rem 0.6rem;border:none;border-radius:6px;cursor:pointer;font-size:0.78rem;font-weight:500;background:transparent;color:#555;white-space:nowrap;transition:all 0.15s;display:flex;align-items:center;gap:0.2rem;"><i data-lucide="user" class="icon" style="width:12px;height:12px;"></i> Мої</button>
                                <button class="task-type-tab" data-value="created" onclick="setTaskTypeFilter(this)" style="padding:0.3rem 0.6rem;border:none;border-radius:6px;cursor:pointer;font-size:0.78rem;font-weight:500;background:transparent;color:#555;white-space:nowrap;transition:all 0.15s;">Створені</button>
                            </div>
                            <select class="filter-select" id="taskTypeFilter" onchange="renderTasks()" style="display:none;">
                                <option value="" data-i18n="allTasks">Всі завдання</option>
                                <option value="my" data-i18n="myTasks">Мої завдання</option>
                                <option value="created" data-i18n="createdByMe">Створені мною</option>
                            </select>
                            <span style="width:1px;height:22px;background:#e0e0e0;margin:0 0.15rem;"></span>
                            <div style="position:relative;display:flex;align-items:center;">
                                <i data-lucide="search" class="icon" style="width:14px;height:14px;position:absolute;left:8px;color:#9ca3af;pointer-events:none;"></i>
                                <input type="text" id="taskSearchInput" placeholder="Пошук..." oninput="syncSearchInputs(this);debouncedRenderTasks()" style="padding:0.3rem 0.4rem 0.3rem 28px;font-size:0.8rem;border:1px solid #e5e7eb;border-radius:6px;width:130px;outline:none;transition:all 0.2s;" onfocus="this.style.borderColor='#22c55e';this.style.width='180px'" onblur="this.style.borderColor='#e5e7eb';if(!this.value)this.style.width='130px'">
                            </div>
                            <select class="filter-select" id="dateFilter" onchange="handleDateFilter()" style="font-size:0.8rem;padding:0.3rem 0.4rem;">
                                <option value="" data-i18n="allDates">Дати</option>
                                <option value="today" data-i18n="today">Сьогодні</option>
                                <option value="week" data-i18n="thisWeek">Тиждень</option>
                                <option value="month" data-i18n="thisMonth">Місяць</option>
                                <option value="overdue" data-i18n="overdue">Прострочені</option>
                                <option value="custom" data-i18n="customPeriod">Період</option>
                            </select>
                            <div id="customDateRange" style="display:none;gap:0.4rem;align-items:center;">
                                <input type="date" id="dateFrom" class="form-input" style="width:auto;padding:0.25rem;" onchange="renderTasks()">
                                <span>—</span>
                                <input type="date" id="dateTo" class="form-input" style="width:auto;padding:0.25rem;" onchange="renderTasks()">
                            </div>
                            <div class="status-multiselect" id="statusFilterMulti">
                                <div class="status-multiselect-toggle" onclick="toggleStatusDropdown(event)">
                                    <span class="status-multiselect-label" id="statusFilterLabel" data-i18n="statuses" style="font-size:0.8rem;">Статуси</span>
                                    <i data-lucide="chevron-down" class="icon icon-sm status-multiselect-arrow"></i>
                                </div>
                                <div class="status-multiselect-dropdown" id="statusDropdown">
                                    <label class="status-multiselect-item status-multiselect-all" onclick="toggleAllStatuses(event)">
                                        <input type="checkbox" id="statusAll" checked> <span data-i18n="all">Всі</span>
                                    </label>
                                    <label class="status-multiselect-item"><input type="checkbox" value="new" onchange="onStatusCheckChange()"> <span class="status-dot" style="background:#1976d2"></span> <span data-i18n="statusNew">Нові</span></label>
                                    <label class="status-multiselect-item"><input type="checkbox" value="progress" onchange="onStatusCheckChange()"> <span class="status-dot" style="background:#f57c00"></span> <span data-i18n="statusProgress">В роботі</span></label>
                                    <label class="status-multiselect-item"><input type="checkbox" value="review" onchange="onStatusCheckChange()"> <span class="status-dot" style="background:#c2185b"></span> <span data-i18n="statusReview">Перевірка</span></label>
                                    <label class="status-multiselect-item"><input type="checkbox" value="done" onchange="onStatusCheckChange()"> <span class="status-dot" style="background:#388e3c"></span> <span data-i18n="statusDone">Готово</span></label>
                                </div>
                            </div>
                            <input type="hidden" id="statusFilter" value="">
                            <select class="filter-select" id="functionFilter" onchange="renderTasks()" style="font-size:0.8rem;padding:0.3rem 0.4rem;"><option value="" data-i18n="functions">Функції</option></select>
                            <select class="filter-select" id="assigneeFilter" onchange="renderTasks()" style="font-size:0.8rem;padding:0.3rem 0.4rem;"><option value="" data-i18n="assignees">Виконавці</option></select>
                            <span style="width:1px;height:22px;background:#e0e0e0;margin:0 0.15rem;"></span>
                            <button id="hideCompletedBtn" class="btn btn-clear" onclick="toggleHideCompleted()" style="white-space:nowrap;padding:0.3rem 0.5rem;font-size:0.75rem;">
                                <i data-lucide="eye-off" class="icon" style="width:12px;height:12px;"></i> <span data-i18n="hideCompleted">Виконані</span>
                            </button>
                            <button class="btn btn-clear" onclick="clearTaskFilters()" style="padding:0.3rem 0.5rem;font-size:0.75rem;"><i data-lucide="x" class="icon" style="width:12px;height:12px;"></i> Скинути</button>
                        </div>
                    </div>
                    <div id="totalTimeInfo" class="total-time-container"></div>
                    <div class="table-container" id="tasksContainer">
                        <div class="loading"><div class="spinner"></div></div>
                    </div>
                    
                    <!-- Archive View -->
                    <div id="archiveContainer" style="display:none;">
                        <div style="background:linear-gradient(135deg,#f3f4f6,#e5e7eb);padding:1rem;border-radius:var(--radius);margin-bottom:1rem;display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:0.5rem;">
                            <div style="display:flex;align-items:center;gap:0.5rem;">
                                <i data-lucide="archive" class="icon icon-lg" style="color:#6b7280;"></i>
                                <div>
                                    <h3 style="font-size:1rem;margin:0;">Архів виконаних завдань</h3>
                                    <p style="font-size:0.8rem;color:#6b7280;margin:0;">Завдання завершені більше 30 днів тому</p>
                                </div>
                            </div>
                            <div style="display:flex;gap:0.5rem;align-items:center;">
                                <span id="archiveCount" style="font-size:0.85rem;color:#6b7280;"></span>
                                <button class="btn btn-small" onclick="toggleArchiveView()" style="background:#6b7280;color:white;">
                                    <i data-lucide="arrow-left" class="icon icon-sm"></i> Назад до завдань
                                </button>
                            </div>
                        </div>
                        <div id="archiveTasksList"></div>
                        <div id="archiveLoadMore" style="display:none;text-align:center;padding:1rem;">
                            <button class="btn btn-small" onclick="loadMoreArchive()" style="padding:0.6rem 2rem;">
                                Завантажити ще
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- CONTROL -->
            <div id="controlTab" class="tab-content">
                <div class="controls">
                    <h2 style="font-size:1.2rem;margin-bottom:0;" data-i18n="controlPanelTitle">Панель контролю завдань</h2>
                </div>
                <div class="filters-row" style="background:white;padding:1rem;border-radius:12px;margin-bottom:1rem;box-shadow:var(--shadow);">
                    <span style="display:flex;align-items:center;gap:0.3rem;"><i data-lucide="user" class="icon icon-sm"></i> <span data-i18n="assigneeLabel">Виконавець:</span></span>
                    <select class="filter-select" id="controlAssigneeFilter" onchange="renderControl()"><option value="" data-i18n="allAssignees">Всі виконавці</option></select>
                    <span style="display:flex;align-items:center;gap:0.3rem;"><i data-lucide="tag" class="icon icon-sm"></i> <span data-i18n="functionLabel">Функція:</span></span>
                    <select class="filter-select" id="controlFunctionFilter" onchange="renderControl()"><option value="" data-i18n="allFunctions">Всі функції</option></select>
                    <span style="display:flex;align-items:center;gap:0.3rem;"><i data-lucide="calendar" class="icon"></i> <span data-i18n="periodLabel">Період:</span></span>
                    <select class="filter-select" id="controlPeriodFilter" onchange="renderControl()">
                        <option value="" data-i18n="allTime">Весь час</option>
                        <option value="today" data-i18n="today">Сьогодні</option>
                        <option value="week" data-i18n="thisWeek">Цей тиждень</option>
                        <option value="month" data-i18n="thisMonth">Цей місяць</option>
                    </select>
                    <button class="btn btn-clear" onclick="clearControlFilters()"><i data-lucide="x" class="icon"></i> <span data-i18n="clear">Очистити</span></button>
                </div>
                <div style="background:white;border-radius:12px;padding:1rem;box-shadow:var(--shadow);">
                    <div class="dashboard-cards">
                        <div class="dashboard-card urgent">
                            <h3><i data-lucide="alert-triangle" class="icon"></i> <span data-i18n="critical">Критичні</span></h3>
                            <div class="dashboard-number" id="urgentCount">0</div>
                            <div class="dashboard-subtitle" data-i18n="overdueLabel">Прострочені</div>
                        </div>
                        <div class="dashboard-card warning">
                            <h3><i data-lucide="alert-circle" class="icon"></i> <span data-i18n="attention">Увага</span></h3>
                            <div class="dashboard-number" id="warningCount">0</div>
                            <div class="dashboard-subtitle" data-i18n="todayTomorrow">Сьогодні-завтра</div>
                        </div>
                        <div class="dashboard-card active">
                            <h3><i data-lucide="loader" class="icon"></i> <span data-i18n="active">Активні</span></h3>
                            <div class="dashboard-number" id="activeCount">0</div>
                            <div class="dashboard-subtitle" data-i18n="inWork">В роботі</div>
                        </div>
                        <div class="dashboard-card completed">
                            <h3><i data-lucide="check-circle" class="icon"></i> <span data-i18n="completed">Готово</span></h3>
                            <div class="dashboard-number" id="completedCount">0</div>
                            <div class="dashboard-subtitle" data-i18n="completedLabel">Завершені</div>
                        </div>
                    </div>
                    <div style="margin-top:1rem;padding:1rem;background:#f8f9fa;border-radius:8px;">
                        <div style="display:flex;align-items:center;gap:0.5rem;margin-bottom:0.5rem;">
                            <span data-i18n="viewLabel">Перегляд:</span>
                            <select class="filter-select" id="controlViewType" onchange="renderControlContent()" style="min-width:150px;">
                                <option value="workload" data-i18n="workload">Навантаження</option>
                                <option value="functions" data-i18n="byFunctions">По функціях</option>
                            </select>
                        </div>
                    </div>
                    <div id="controlContent" style="margin-top:1rem;"></div>
                </div>
            </div>

            <!-- PROCESSES (Направляючі форми) -->
            <!-- PROJECTS TAB -->
            <div id="projectsTab" class="tab-content">
                <div class="projects-header" id="projectsHeader" style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:1rem;margin-bottom:1rem;">
                    <div style="display:flex;align-items:center;gap:1rem;flex-wrap:wrap;">
                        <h3 style="margin:0;font-size:1.1rem;"><i data-lucide="folder-kanban" class="icon"></i> <span data-i18n="projects">Проєкти</span> <span id="projectsCounter" class="badge" style="background:var(--primary);color:white;padding:2px 8px;border-radius:10px;font-size:0.8rem;"></span></h3>
                        <select id="projectStatusFilter" class="filter-select" onchange="renderProjects()" style="min-width:140px;">
                            <option value="">Всі статуси</option>
                            <option value="active" selected>Активні</option>
                            <option value="completed">Завершені</option>
                            <option value="paused">Призупинені</option>
                        </select>
                    </div>
                    <div style="display:flex;gap:0.5rem;">
                        <div class="calendar-view-switcher">
                            <button class="calendar-view-btn active" data-view="grid" onclick="setProjectView('grid')">Картки</button>
                            <button class="calendar-view-btn" data-view="list" onclick="setProjectView('list')">Список</button>
                            <button class="calendar-view-btn" data-view="timeline" onclick="setProjectView('timeline')">Таймлайн</button>
                        </div>
                        <button class="btn btn-success" onclick="openProjectModal()"><i data-lucide="plus" class="icon"></i> <span class="hide-mobile">Новий проєкт</span></button>
                    </div>
                </div>
                
                <div id="projectsContent">
                    <!-- Контент генерується динамічно -->
                </div>
                
                <div id="projectsEmptyState" class="empty-state" style="display:none;">
                    <i data-lucide="folder-kanban" class="icon icon-xl" style="color:var(--gray);margin-bottom:1rem;"></i>
                    <h3>Немає проєктів</h3>
                    <p>Створіть перший проєкт для групування завдань</p>
                    <button class="btn btn-success" onclick="openProjectModal()" style="margin-top:1rem;">
                        <i data-lucide="plus" class="icon"></i> Створити проєкт
                    </button>
                </div>
                
                <!-- Project Detail View (shown when project is selected) -->
                <div id="projectDetailView" style="display:none;">
                    <div id="projectDetailContent"></div>
                </div>
            </div>

            <!-- PROCESSES -->
            <div id="processesTab" class="tab-content">
                <div class="processes-header" style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:1rem;margin-bottom:1rem;">
                    <div style="display:flex;align-items:center;gap:1rem;flex-wrap:wrap;">
                        <h3 style="margin:0;font-size:1.1rem;"><i data-lucide="git-branch" class="icon"></i> <span data-i18n="processes">Бізнес-процеси</span> <span id="processesCounter" class="badge" style="background:var(--primary);color:white;padding:2px 8px;border-radius:10px;font-size:0.8rem;"></span></h3>
                        <select id="processTemplateFilter" class="filter-select" onchange="renderProcessBoard()" style="min-width:180px;">
                            <option value="" data-i18n="allProcesses">Всі процеси</option>
                        </select>
                        <select id="processAssigneeFilter" class="filter-select" onchange="renderProcessBoard()" style="min-width:160px;">
                            <option value="" data-i18n="allAssignees">Всі виконавці</option>
                        </select>
                        <button id="toggleCompletedBtn" class="btn btn-small" onclick="toggleShowCompletedProcesses()" style="font-size:0.8rem;">
                            <i data-lucide="archive" class="icon icon-sm"></i> <span data-i18n="showCompleted">Архів</span>
                        </button>
                    </div>
                    <div style="display:flex;gap:0.5rem;flex-wrap:wrap;">
                        <a href="https://chatgpt.com/g/g-693ec18df2c0819194f1c3de7404d6fe-talko-ai-business-process" target="_blank" class="btn" style="background:linear-gradient(135deg,#8b5cf6,#6366f1);color:white;border:none;">
                            <i data-lucide="sparkles" class="icon"></i> <span data-i18n="aiAssistant">AI-асистент</span>
                        </a>
                        <button class="btn" onclick="openProcessTemplatesModal()"><i data-lucide="file-cog" class="icon"></i> <span data-i18n="templates">Шаблони</span></button>
                        <button class="btn btn-success" onclick="openStartProcessModal()"><i data-lucide="play" class="icon"></i> <span data-i18n="startProcess">Запустити</span></button>
                    </div>
                </div>
                
                <!-- Process Board (Kanban style) -->
                <div id="processBoardContainer" class="process-board-container">
                    <div class="process-board" id="processBoard">
                        <!-- Колонки будуть згенеровані динамічно -->
                    </div>
                </div>
                
                <!-- Empty state -->
                <div id="processesEmptyState" class="empty-state" style="display:none;">
                    <i data-lucide="git-branch" class="icon icon-xl" style="color:var(--gray);margin-bottom:1rem;"></i>
                    <h3 data-i18n="noProcesses">Немає активних процесів</h3>
                    <p data-i18n="createProcessTemplate">Створіть шаблон процесу та запустіть перший процес</p>
                    <button class="btn btn-success" onclick="openProcessTemplatesModal()" style="margin-top:1rem;">
                        <i data-lucide="plus" class="icon"></i> <span data-i18n="createTemplate">Створити шаблон</span>
                    </button>
                </div>
            </div>

            <!-- REGULAR -->
            <div id="regularTab" class="tab-content">
                <!-- Regular Tasks Calendar Header -->
                <div class="calendar-header" id="regularCalendarHeader">
                    <div style="display:flex;align-items:center;gap:1rem;">
                        <h3 style="margin:0;font-size:1.1rem;"><i data-lucide="repeat" class="icon"></i> <span data-i18n="regularTasks">Регулярні завдання</span></h3>
                        <button class="btn btn-success" onclick="openRegularTaskModal()" style="white-space:nowrap;">
                            <i data-lucide="plus" class="icon"></i> <span data-i18n="add">Додати</span>
                        </button>
                    </div>
                    
                    <div style="display:flex;align-items:center;gap:0.5rem;">
                        <div class="calendar-view-switcher">
                            <button class="calendar-view-btn active" data-view="week" onclick="setRegularView('week')" data-i18n="week">Тиждень</button>
                            <button class="calendar-view-btn" data-view="list" onclick="setRegularView('list')" data-i18n="list">Список</button>
                        </div>
                    </div>
                </div>
                
                <!-- СПІЛЬНІ ФІЛЬТРИ ДЛЯ ВСІХ VIEWS -->
                <div class="filters-row" id="regularFiltersRow" style="background:white;padding:0.75rem 1rem;border-radius:12px;margin-bottom:0.75rem;box-shadow:var(--shadow);display:flex;flex-wrap:wrap;gap:0.5rem;align-items:center;">
                    <button class="btn btn-success btn-sm" onclick="filterRegularToday()" id="regularTodayBtn" style="padding:0.4rem 0.75rem;font-size:0.85rem;"><i data-lucide="calendar-check" class="icon icon-sm"></i> <span data-i18n="todaysTasks">Сьогодні</span></button>
                    <button class="btn btn-sm" id="regularMyBtn" onclick="filterRegularMy()" style="padding:0.4rem 0.75rem;font-size:0.85rem;white-space:nowrap;"><i data-lucide="user" class="icon icon-sm"></i> <span data-i18n="myTasks">Мої</span></button>
                    <select class="filter-select" id="regularAssigneeFilter" onchange="applyRegularFilters()" style="font-size:0.85rem;padding:0.4rem;"><option value="" data-i18n="allAssignees">Всі виконавці</option></select>
                    <select class="filter-select" id="regularFunctionFilter" onchange="applyRegularFilters()" style="font-size:0.85rem;padding:0.4rem;"><option value="" data-i18n="allFunctions">Всі функції</option></select>
                    <select class="filter-select" id="regularDayFilter" onchange="applyRegularFilters()" style="font-size:0.85rem;padding:0.4rem;">
                        <option value="" data-i18n="allDays">Всі дні</option>
                        <option value="1" data-i18n="monday">Пн</option>
                        <option value="2" data-i18n="tuesday">Вт</option>
                        <option value="3" data-i18n="wednesday">Ср</option>
                        <option value="4" data-i18n="thursday">Чт</option>
                        <option value="5" data-i18n="friday">Пт</option>
                        <option value="6" data-i18n="saturday">Сб</option>
                        <option value="0" data-i18n="sunday">Нд</option>
                    </select>
                    <button class="btn btn-clear btn-sm" onclick="clearRegularFilters()" style="padding:0.4rem 0.75rem;font-size:0.85rem;"><i data-lucide="x" class="icon icon-sm"></i></button>
                    <span id="regularFilterCount" style="font-size:0.8rem;color:#6b7280;margin-left:auto;"></span>
                </div>
                
                <!-- Mobile Day Tabs for Regular Tasks -->
                <div class="mobile-regular-tabs" id="mobileRegularTabs">
                    <div class="regular-day-tabs" id="regularDayTabs">
                        <button class="regular-day-tab" data-day="1" onclick="selectRegularDay(1)">Пн</button>
                        <button class="regular-day-tab" data-day="2" onclick="selectRegularDay(2)">Вт</button>
                        <button class="regular-day-tab" data-day="3" onclick="selectRegularDay(3)">Ср</button>
                        <button class="regular-day-tab" data-day="4" onclick="selectRegularDay(4)">Чт</button>
                        <button class="regular-day-tab" data-day="5" onclick="selectRegularDay(5)">Пт</button>
                        <button class="regular-day-tab" data-day="6" onclick="selectRegularDay(6)">Сб</button>
                        <button class="regular-day-tab" data-day="0" onclick="selectRegularDay(0)">Нд</button>
                    </div>
                </div>
                
                <!-- Mobile Single Day View -->
                <div class="mobile-regular-day-view" id="mobileRegularDayView">
                    <div class="mobile-regular-day-content" id="mobileRegularDayContent">
                        <!-- Generated by JS -->
                    </div>
                </div>
                
                <!-- Regular Calendar View (Week) - Desktop only -->
                <div class="regular-calendar-container active" id="regularCalendarContainer">
                    <div class="regular-schedule-view" id="regularWeekView">
                        <div class="regular-schedule-header">
                            <div class="regular-time-gutter"></div>
                            <div class="regular-days-header" id="regularWeekHeader"></div>
                        </div>
                        <div class="regular-schedule-body">
                            <div class="regular-time-column">
                                <div class="time-slot">06:00</div>
                                <div class="time-slot">07:00</div>
                                <div class="time-slot">08:00</div>
                                <div class="time-slot">09:00</div>
                                <div class="time-slot">10:00</div>
                                <div class="time-slot">11:00</div>
                                <div class="time-slot">12:00</div>
                                <div class="time-slot">13:00</div>
                                <div class="time-slot">14:00</div>
                                <div class="time-slot">15:00</div>
                                <div class="time-slot">16:00</div>
                                <div class="time-slot">17:00</div>
                                <div class="time-slot">18:00</div>
                                <div class="time-slot">19:00</div>
                                <div class="time-slot">20:00</div>
                                <div class="time-slot">21:00</div>
                            </div>
                            <div class="regular-days-body" id="regularWeekBody"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Regular List View -->
                <div class="regular-list-container" id="regularListContainer" style="display:none;">
                    <div class="table-container" id="regularTasksContainer">
                        <div class="loading"><div class="spinner"></div></div>
                    </div>
                </div>
            </div>

            <!-- FUNCTIONS -->
            <div id="functionsTab" class="tab-content">
                <div class="controls" style="display:flex;gap:0.5rem;flex-wrap:wrap;">
                    <button class="btn btn-success" onclick="openFunctionModal()" data-i18n="addFunction">+ Функція</button>
                    <button class="btn" onclick="openMergeFunctionsModal()" id="mergeFunctionsBtn" style="display:none;"><i data-lucide="git-merge" class="icon"></i> <span data-i18n="mergeFunctions">Об'єднати</span></button>
                </div>
                <div id="functionsContainer" class="cards-grid">
                    <div class="loading"><div class="spinner"></div></div>
                </div>
            </div>

            <!-- USERS -->
            <div id="usersTab" class="tab-content">
                <div class="controls">
                    <button class="btn btn-success" onclick="openInviteModal()" id="inviteBtn"><i data-lucide="user-plus" class="icon"></i> <span data-i18n="invite">Запросити</span></button>
                </div>
                <div id="usersContainer" class="cards-grid">
                    <div class="loading"><div class="spinner"></div></div>
                </div>
            </div>

            <!-- ANALYTICS -->
            <div id="analyticsTab" class="tab-content">
                <div class="controls" style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:1rem;">
                    <h2 style="font-size:1.2rem;margin:0;" data-i18n="analytics"><i data-lucide="trending-up" class="icon"></i> Аналітика</h2>
                </div>
                <div style="background:white;border-radius:12px;padding:1.5rem;box-shadow:var(--shadow);margin-top:1rem;">
                    <div class="analytics-grid">
                        <div class="analytics-card">
                            <h3 data-i18n="totalTasks">Всього завдань</h3>
                            <div class="analytics-number" id="analyticsTotalTasks">0</div>
                        </div>
                        <div class="analytics-card">
                            <h3 data-i18n="completedTasks">Виконано</h3>
                            <div class="analytics-number green" id="analyticsCompletedTasks">0</div>
                        </div>
                        <div class="analytics-card">
                            <h3 data-i18n="completionRate">Виконання %</h3>
                            <div class="analytics-number blue" id="analyticsCompletionRate">0%</div>
                        </div>
                        <div class="analytics-card">
                            <h3 data-i18n="avgTime">Сер. час</h3>
                            <div class="analytics-number orange" id="analyticsAvgTime">-</div>
                        </div>
                    </div>
                    <div id="analyticsContent" style="margin-top:1.5rem;"></div>
                </div>
            </div>

            <!-- ADMIN (only for superadmin) -->
            <div id="adminTab" class="tab-content">
                <div class="controls" style="background:linear-gradient(135deg,#fee2e2,#fecaca);">
                    <h2 style="font-size:1.1rem;color:#dc2626;"><i data-lucide="shield" class="icon"></i> <span data-i18n="adminPanel">Адмін-панель TALKO</span></h2>
                </div>
                <div style="background:white;border-radius:12px;padding:1rem;box-shadow:var(--shadow);margin-bottom:1rem;">
                    <h3 style="margin-bottom:1rem;"><i data-lucide="plus" class="icon"></i> <span data-i18n="createCompany">Створити нову компанію</span></h3>
                    <form id="adminCreateForm" onsubmit="adminCreateCompany(event)">
                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label" data-i18n="ownerEmail">Email власника *</label>
                                <input type="email" id="adminOwnerEmail" class="form-input" placeholder="client@email.com" required>
                            </div>
                            <div class="form-group">
                                <label class="form-label" data-i18n="passwordLabel">Пароль *</label>
                                <input type="text" id="adminOwnerPassword" class="form-input" placeholder="мін. 6 символів" required minlength="6">
                            </div>
                            <div class="form-group">
                                <label class="form-label" data-i18n="ownerName">Ім'я власника *</label>
                                <input type="text" id="adminOwnerName" class="form-input" placeholder="Іван Петренко" required>
                            </div>
                            <div class="form-group">
                                <label class="form-label" data-i18n="companyName">Назва компанії *</label>
                                <input type="text" id="adminCompanyName" class="form-input" placeholder="ТОВ Компанія" required>
                            </div>
                        </div>
                        <button type="submit" class="btn btn-success" style="margin-top:1rem;" id="adminCreateBtn"><i data-lucide="rocket" class="icon"></i> <span data-i18n="createCompanyBtn">Створити компанію та Owner</span></button>
                    </form>
                </div>
                
                <!-- Інструкції для адміна -->
                <div style="display:grid;gap:1rem;grid-template-columns:repeat(auto-fit, minmax(300px, 1fr));">
                    
                    <!-- Інструкція: Додавання Owner -->
                    <div style="background:white;border-radius:12px;padding:1.25rem;box-shadow:var(--shadow);border-left:4px solid #3b82f6;">
                        <h4 style="display:flex;align-items:center;gap:0.5rem;margin-bottom:1rem;color:#3b82f6;">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>
                            1. Додавання Owner (Власника)
                        </h4>
                        <ol style="margin:0;padding-left:1.25rem;color:#4b5563;font-size:0.9rem;line-height:1.7;">
                            <li>Заповни форму вище і натисни <b>"Створити компанію та Owner"</b></li>
                            <li>Система автоматично створить:
                                <ul style="margin:0.3rem 0;padding-left:1rem;">
                                    <li>Компанію в Firebase</li>
                                    <li>Користувача з роллю Owner</li>
                                    <li>Акаунт в Firebase Auth</li>
                                </ul>
                            </li>
                            <li>Надішли клієнту:
                                <ul style="margin:0.3rem 0;padding-left:1rem;">
                                    <li>Посилання: <code style="background:#f3f4f6;padding:0.15rem 0.4rem;border-radius:4px;font-size:0.85rem;">taskmanagerai-vert.vercel.app</code></li>
                                    <li>Email та пароль</li>
                                </ul>
                            </li>
                        </ol>
                    </div>
                    
                    <!-- Інструкція: Додавання співробітників -->
                    <div style="background:white;border-radius:12px;padding:1.25rem;box-shadow:var(--shadow);border-left:4px solid #10b981;">
                        <h4 style="display:flex;align-items:center;gap:0.5rem;margin-bottom:1rem;color:#10b981;">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><line x1="19" x2="19" y1="8" y2="14"/><line x1="22" x2="16" y1="11" y2="11"/></svg>
                            2. Додавання співробітників
                        </h4>
                        <ol style="margin:0;padding-left:1.25rem;color:#4b5563;font-size:0.9rem;line-height:1.7;">
                            <li><b>Owner сам додає</b> співробітників через вкладку "Співробітники"</li>
                            <li>Owner натискає <b>"+ Додати співробітника"</b></li>
                            <li>Вводить email і створює запрошення</li>
                            <li>Система генерує посилання для реєстрації</li>
                            <li>Співробітник переходить по посиланню і створює пароль</li>
                        </ol>
                        <div style="margin-top:0.75rem;padding:0.75rem;background:#f0fdf4;border-radius:8px;font-size:0.85rem;color:#166534;">
                            <b>Важливо:</b> Адмін не додає співробітників напряму — це робить Owner компанії
                        </div>
                    </div>
                    
                    <!-- Інструкція: Google Calendar -->
                    <div style="background:white;border-radius:12px;padding:1.25rem;box-shadow:var(--shadow);border-left:4px solid #f59e0b;">
                        <h4 style="display:flex;align-items:center;gap:0.5rem;margin-bottom:1rem;color:#f59e0b;">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect width="18" height="18" x="3" y="4" rx="2" ry="2"/><line x1="16" x2="16" y1="2" y2="6"/><line x1="8" x2="8" y1="2" y2="6"/><line x1="3" x2="21" y1="10" y2="10"/></svg>
                            3. Інтеграція Google Calendar
                        </h4>
                        <div style="color:#4b5563;font-size:0.9rem;line-height:1.7;">
                            <p style="margin:0 0 0.75rem;"><b>Поточний режим:</b> Testing (до 100 користувачів)</p>
                            <p style="margin:0 0 0.5rem;"><b>Щоб клієнт міг підключити календар:</b></p>
                            <ol style="margin:0;padding-left:1.25rem;">
                                <li>Відкрий <a href="https://console.cloud.google.com/apis/credentials/consent?project=stats-tracker-ai" target="_blank" style="color:#f59e0b;">Google Cloud Console → Audience</a></li>
                                <li>Натисни <b>"+ Add users"</b></li>
                                <li>Введи email клієнта (той самий що в TALKO)</li>
                                <li>Натисни <b>"Save"</b></li>
                            </ol>
                            <div style="margin-top:0.75rem;padding:0.75rem;background:#fefce8;border-radius:8px;font-size:0.85rem;color:#854d0e;">
                                <b>Ліміт:</b> 100 Test Users. Після цього потрібна верифікація Google (1-4 тижні)
                            </div>
                        </div>
                    </div>
                    
                    <!-- Інструкція: Процес для клієнта -->
                    <div style="background:white;border-radius:12px;padding:1.25rem;box-shadow:var(--shadow);border-left:4px solid #8b5cf6;">
                        <h4 style="display:flex;align-items:center;gap:0.5rem;margin-bottom:1rem;color:#8b5cf6;">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>
                            Інструкція для клієнта
                        </h4>
                        <div style="color:#4b5563;font-size:0.9rem;line-height:1.7;">
                            <p style="margin:0 0 0.75rem;"><b>Надішли клієнту:</b></p>
                            <div style="background:#f5f3ff;padding:1rem;border-radius:8px;font-size:0.85rem;">
                                <p style="margin:0 0 0.5rem;display:flex;align-items:center;gap:0.4rem;">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#8b5cf6" stroke-width="2"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>
                                    Посилання: <code style="background:#e9d5ff;padding:0.2rem 0.5rem;border-radius:4px;">taskmanagerai-vert.vercel.app</code>
                                </p>
                                <p style="margin:0 0 0.5rem;display:flex;align-items:center;gap:0.4rem;">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#8b5cf6" stroke-width="2"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg>
                                    Email: <i>(який ви вказали)</i>
                                </p>
                                <p style="margin:0 0 0.75rem;display:flex;align-items:center;gap:0.4rem;">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#8b5cf6" stroke-width="2"><path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"/></svg>
                                    Пароль: <i>(який ви вказали)</i>
                                </p>
                                <hr style="border:none;border-top:1px dashed #c4b5fd;margin:0.75rem 0;">
                                <p style="margin:0;"><b>Перший вхід:</b> натисніть "Активувати доступ" → введіть email та пароль</p>
                                <p style="margin:0.25rem 0 0;"><b>Наступні входи:</b> просто "Увійти"</p>
                            </div>
                        </div>
                    </div>
                    
                </div>
                
                <!-- Список компаній -->
                <div style="background:white;border-radius:12px;padding:1rem;box-shadow:var(--shadow);margin-top:1rem;">
                    <h3 style="margin-bottom:1rem;display:flex;align-items:center;justify-content:space-between;">
                        <span><i data-lucide="building-2" class="icon"></i> Компанії</span>
                        <button onclick="loadAdminCompanies()" class="btn" style="padding:0.4rem 0.8rem;font-size:0.8rem;">
                            <i data-lucide="refresh-cw" class="icon icon-sm"></i> Оновити
                        </button>
                    </h3>
                    <div id="adminCompaniesList" style="overflow-x:auto;">
                        <p style="color:var(--gray);text-align:center;padding:2rem;">Натисніть "Оновити" щоб завантажити список</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- MODALS -->
    <!-- PROJECT MODAL -->
    <div id="projectModal" class="modal">
        <div class="modal-content" style="max-width:560px;">
            <div class="modal-header"><span class="close" onclick="closeModal('projectModal')">&times;</span><h2 id="projectModalTitle">Новий проєкт</h2></div>
            <div class="modal-body">
                <form id="projectForm" onsubmit="saveProject(event)">
                    <div class="form-group"><label class="form-label">Назва проєкту *</label><input type="text" id="projectName" class="form-input" required placeholder="Наприклад: Редизайн сайту"></div>
                    <div class="form-grid">
                        <div class="form-group"><label class="form-label">Дата старту</label><input type="date" id="projectStartDate" class="form-input"></div>
                        <div class="form-group"><label class="form-label">Дедлайн</label><input type="date" id="projectDeadline" class="form-input"></div>
                    </div>
                    <div class="form-group"><label class="form-label">Колір</label>
                        <div id="projectColorPicker" style="display:flex;gap:0.5rem;flex-wrap:wrap;margin-top:0.25rem;">
                            <label style="cursor:pointer;"><input type="radio" name="projectColor" value="#22c55e" checked style="display:none;"><span class="color-dot" style="width:28px;height:28px;border-radius:50%;display:block;background:#22c55e;border:3px solid transparent;"></span></label>
                            <label style="cursor:pointer;"><input type="radio" name="projectColor" value="#3b82f6" style="display:none;"><span class="color-dot" style="width:28px;height:28px;border-radius:50%;display:block;background:#3b82f6;border:3px solid transparent;"></span></label>
                            <label style="cursor:pointer;"><input type="radio" name="projectColor" value="#8b5cf6" style="display:none;"><span class="color-dot" style="width:28px;height:28px;border-radius:50%;display:block;background:#8b5cf6;border:3px solid transparent;"></span></label>
                            <label style="cursor:pointer;"><input type="radio" name="projectColor" value="#f59e0b" style="display:none;"><span class="color-dot" style="width:28px;height:28px;border-radius:50%;display:block;background:#f59e0b;border:3px solid transparent;"></span></label>
                            <label style="cursor:pointer;"><input type="radio" name="projectColor" value="#ef4444" style="display:none;"><span class="color-dot" style="width:28px;height:28px;border-radius:50%;display:block;background:#ef4444;border:3px solid transparent;"></span></label>
                            <label style="cursor:pointer;"><input type="radio" name="projectColor" value="#ec4899" style="display:none;"><span class="color-dot" style="width:28px;height:28px;border-radius:50%;display:block;background:#ec4899;border:3px solid transparent;"></span></label>
                            <label style="cursor:pointer;"><input type="radio" name="projectColor" value="#06b6d4" style="display:none;"><span class="color-dot" style="width:28px;height:28px;border-radius:50%;display:block;background:#06b6d4;border:3px solid transparent;"></span></label>
                        </div>
                    </div>
                    <div class="form-group"><label class="form-label">Опис</label><textarea id="projectDescription" class="form-textarea" rows="3" placeholder="Короткий опис мети проєкту"></textarea></div>
                    <input type="hidden" id="projectEditId" value="">
                    <div class="form-actions" style="margin-top:1rem;">
                        <button type="button" class="btn" onclick="closeModal('projectModal')">Скасувати</button>
                        <button type="submit" class="btn btn-success"><i data-lucide="check" class="icon"></i> Зберегти</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- TASK MODAL -->
    <div id="taskModal" class="modal">
        <div class="modal-content">
            <div class="modal-header"><span class="close" onclick="closeModal('taskModal')">&times;</span><h2 id="taskModalTitle" data-i18n="newTask">Нове завдання</h2></div>
            <div class="modal-body">
                <form id="taskForm" onsubmit="saveTask(event)">
                    <div class="form-grid">
                        <div class="form-group full-width"><label class="form-label" data-i18n="title">Назва *</label><input type="text" id="taskTitle" class="form-input" required></div>
                        <div class="form-group"><label class="form-label" data-i18n="function">Функція</label><select id="taskFunction" class="form-select"><option value="" data-i18n="noFunction">Без функції</option></select></div>
                        <div class="form-group"><label class="form-label">Проєкт</label><select id="taskProject" class="form-select"><option value="">Без проєкту</option></select></div>
                        <div class="form-group"><label class="form-label" data-i18n="assignee">Виконавець *</label><select id="taskAssignee" class="form-select" required><option value="" data-i18n="select">Оберіть</option></select></div>
                        <div class="form-group"><label class="form-label" data-i18n="deadlineDate">Дедлайн (дата) *</label><input type="date" id="taskDeadlineDate" class="form-input" required></div>
                        <div class="form-group"><label class="form-label">Початок *</label><input type="time" id="taskDeadlineTime" class="form-input" required></div>
                        <div class="form-group"><label class="form-label" data-i18n="endDuration">Кінець / Тривалість</label>
                            <div style="display:flex;gap:8px;align-items:center;">
                                <select id="taskTimeMode" class="form-select" style="width:auto;" onchange="toggleTaskTimeMode()">
                                    <option value="end" data-i18n="endTime">Час кінця</option>
                                    <option value="duration" data-i18n="duration">Тривалість</option>
                                </select>
                                <input type="time" id="taskTimeEnd" class="form-input" value="19:00" style="flex:1;">
                                <select id="taskEstimatedTime" class="form-select" style="flex:1;display:none;"><option value="15" data-i18n="min15">15 хв</option><option value="30" data-i18n="min30">30 хв</option><option value="45" data-i18n="min45">45 хв</option><option value="60" selected data-i18n="hour1">1 год</option><option value="90" data-i18n="hour1_5">1.5 год</option><option value="120" data-i18n="hour2">2 год</option><option value="180" data-i18n="hour3">3 год</option><option value="240" data-i18n="hour4">4 год</option><option value="480" data-i18n="hour8">8 год</option></select>
                            </div>
                        </div>
                        
                        <!-- FEAT-003: Дата початку -->
                        <div class="form-group"><label class="form-label" data-i18n="startDate">Дата початку</label><input type="date" id="taskStartDate" class="form-input" placeholder="Опціонально"></div>
                        
                        <div class="form-group"><label class="form-label" data-i18n="priority">Пріоритет</label><select id="taskPriority" class="form-select"><option value="low" data-i18n="priorityLow">Низький</option><option value="medium" selected data-i18n="priorityMedium">Середній</option><option value="high" data-i18n="priorityHigh">Високий</option></select></div>
                        <div class="form-group"><label class="form-label" data-i18n="status">Статус</label><select id="taskStatus" class="form-select"><option value="new" data-i18n="statusNew">Нове</option><option value="progress" data-i18n="statusProgress">В роботі</option><option value="review" data-i18n="statusReview">Перевірка</option><option value="done" data-i18n="statusDone">Готово</option></select></div>
                        
                        <!-- FEAT-001: Співвиконавці -->
                        <div class="form-group full-width">
                            <label class="form-label"><i data-lucide="users" class="icon icon-sm"></i> <span data-i18n="coExecutors">Співвиконавці</span></label>
                            <div id="taskCoExecutors" style="margin-top:0.5rem;"></div>
                        </div>
                        
                        <!-- FEAT-001: Спостерігачі -->
                        <div class="form-group full-width">
                            <label class="form-label"><i data-lucide="eye" class="icon icon-sm"></i> <span data-i18n="observers">Спостерігачі</span></label>
                            <div id="taskObservers" style="margin-top:0.5rem;"></div>
                        </div>
                        
                        <!-- FEAT-002+007: Toggles контролю та зміни строків -->
                        <div class="form-group full-width" style="display:flex;gap:2rem;flex-wrap:wrap;">
                            <label style="display:flex;align-items:center;gap:0.5rem;cursor:pointer;padding:0.5rem 0.75rem;background:#f0fdf4;border-radius:8px;">
                                <input type="checkbox" id="taskRequireReview" style="width:18px;height:18px;accent-color:var(--primary);" checked>
                                <span style="font-size:0.85rem;font-weight:500;" data-i18n="requireReview">Перевірка після виконання</span>
                            </label>
                            <label style="display:flex;align-items:center;gap:0.5rem;cursor:pointer;padding:0.5rem 0.75rem;background:#fef3c7;border-radius:8px;">
                                <input type="checkbox" id="taskAllowDeadlineChange" style="width:18px;height:18px;accent-color:#f59e0b;">
                                <span style="font-size:0.85rem;font-weight:500;" data-i18n="allowDeadlineChange">Виконавець може змінювати строки</span>
                            </label>
                        </div>
                        
                        <div class="form-group full-width"><label class="form-label" data-i18n="expectedResult">Очікуваний результат</label><textarea id="taskExpectedResult" class="form-textarea" placeholder="Що конкретно має бути зроблено?"></textarea></div>
                        <div class="form-group full-width"><label class="form-label" data-i18n="reportFormat">Формат звіту</label><textarea id="taskReportFormat" class="form-textarea" style="min-height:80px;resize:vertical;" placeholder="Скрін / Посилання / Фото / Документ"></textarea></div>
                        <div class="form-group full-width"><label class="form-label" data-i18n="description">Опис</label><textarea id="taskDescription" class="form-textarea"></textarea></div>
                        <div class="form-group full-width" id="taskAiHelpRow" style="display:none;">
                            <a id="taskAiHelpLink" href="#" target="_blank" style="display:inline-flex;align-items:center;gap:6px;padding:8px 14px;background:linear-gradient(135deg,#f0fdf4,#dcfce7);border:1px solid #bbf7d0;border-radius:10px;font-size:0.85rem;color:#16a34a;text-decoration:none;font-weight:500;">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>
                                <span data-i18n="askAi">Не зрозуміло? Запитай AI-помічника</span>
                            </a>
                        </div>
                        
                        <!-- FEAT-001: Чеклист -->
                        <div class="form-group full-width">
                            <label class="form-label"><i data-lucide="list-checks" class="icon icon-sm"></i> <span data-i18n="checklist">Чеклист</span></label>
                            <div id="taskChecklist" style="margin-top:0.5rem;"></div>
                            <button type="button" onclick="addChecklistItem()" style="margin-top:0.5rem;padding:0.4rem 0.75rem;background:#f9fafb;border:1px dashed #d1d5db;border-radius:8px;cursor:pointer;font-size:0.85rem;color:#6b7280;display:flex;align-items:center;gap:0.4rem;">
                                <i data-lucide="plus" class="icon icon-sm"></i> <span data-i18n="addChecklistItem">Додати пункт</span>
                            </button>
                        </div>
                        
                        <!-- FEAT-006: Time Tracking -->
                        <div class="form-group full-width" id="timeTrackingSection" style="display:none;">
                            <label class="form-label"><i data-lucide="timer" class="icon icon-sm"></i> <span data-i18n="timeTracking">Облік часу</span></label>
                            <div style="display:flex;gap:1rem;align-items:center;flex-wrap:wrap;margin-top:0.5rem;padding:0.75rem;background:#f0f9ff;border-radius:8px;">
                                <div style="text-align:center;">
                                    <div style="font-size:0.75rem;color:#6b7280;" data-i18n="planned">Запланований</div>
                                    <div id="timeTrackPlanned" style="font-size:1.2rem;font-weight:600;color:#3b82f6;">—</div>
                                </div>
                                <div style="text-align:center;">
                                    <div style="font-size:0.75rem;color:#6b7280;" data-i18n="actual">Фактичний</div>
                                    <div id="timeTrackActual" style="font-size:1.2rem;font-weight:600;color:#22c55e;">00:00</div>
                                </div>
                                <div style="flex:1;display:flex;gap:0.5rem;justify-content:flex-end;align-items:center;">
                                    <button type="button" id="timeTrackBtn" onclick="toggleTimeTracker()" style="padding:0.5rem 1rem;border:none;border-radius:8px;background:#22c55e;color:white;font-weight:600;cursor:pointer;display:flex;align-items:center;gap:0.4rem;font-size:0.85rem;">
                                        <i data-lucide="play" class="icon icon-sm"></i> <span data-i18n="startTimer">Старт</span>
                                    </button>
                                    <button type="button" onclick="addManualTime()" style="padding:0.5rem 0.75rem;border:1px solid #d1d5db;border-radius:8px;background:white;cursor:pointer;font-size:0.85rem;" title="Додати час вручну">
                                        <i data-lucide="plus" class="icon icon-sm"></i>
                                    </button>
                                </div>
                            </div>
                            <div id="timeTrackLog" style="margin-top:0.5rem;max-height:120px;overflow-y:auto;font-size:0.8rem;color:#6b7280;"></div>
                        </div>
                        
                        <!-- Налаштування нагадувань -->
                        <div class="form-group full-width">
                            <label class="form-label">
                                <i data-lucide="alarm-clock" class="icon icon-sm"></i> 
                                <span data-i18n="reminders">Нагадування до дедлайну</span>
                            </label>
                            <div style="display:flex;flex-wrap:wrap;gap:0.5rem;margin-top:0.5rem;">
                                <label style="display:flex;align-items:center;gap:0.35rem;cursor:pointer;padding:0.4rem 0.75rem;background:#f9fafb;border-radius:6px;">
                                    <input type="checkbox" id="taskReminder60" value="60" style="width:16px;height:16px;accent-color:var(--primary);">
                                    <span style="font-size:0.85rem;" data-i18n="reminder1hour">За 1 год</span>
                                </label>
                                <label style="display:flex;align-items:center;gap:0.35rem;cursor:pointer;padding:0.4rem 0.75rem;background:#f9fafb;border-radius:6px;">
                                    <input type="checkbox" id="taskReminder30" value="30" style="width:16px;height:16px;accent-color:var(--primary);">
                                    <span style="font-size:0.85rem;" data-i18n="reminder30min">За 30 хв</span>
                                </label>
                                <label style="display:flex;align-items:center;gap:0.35rem;cursor:pointer;padding:0.4rem 0.75rem;background:#f9fafb;border-radius:6px;">
                                    <input type="checkbox" id="taskReminder15" value="15" checked style="width:16px;height:16px;accent-color:var(--primary);">
                                    <span style="font-size:0.85rem;" data-i18n="reminder15min">За 15 хв</span>
                                </label>
                            </div>
                        </div>
                        
                        <!-- Ескалація при простроченні -->
                        <div class="form-group full-width">
                            <label class="form-label">
                                <i data-lucide="alert-triangle" class="icon icon-sm"></i> 
                                <span data-i18n="escalation">Ескалація при простроченні</span>
                            </label>
                            <div style="display:flex;align-items:center;gap:1rem;margin-top:0.5rem;padding:0.75rem;background:#fef3c7;border-radius:8px;">
                                <label style="display:flex;align-items:center;gap:0.5rem;cursor:pointer;">
                                    <input type="checkbox" id="taskEscalationEnabled" style="width:18px;height:18px;accent-color:#f59e0b;">
                                    <span style="font-size:0.9rem;font-weight:500;" data-i18n="createRepeatTask">Створити повторну задачу</span>
                                </label>
                                <span style="font-size:0.85rem;color:#92400e;" data-i18n="afterTime">через</span>
                                <select id="taskEscalationMinutes" style="padding:0.4rem;border-radius:6px;border:1px solid #d1d5db;font-size:0.85rem;">
                                    <option value="15" data-i18n="min15">15 хв</option>
                                    <option value="30" data-i18n="min30">30 хв</option>
                                    <option value="60" selected data-i18n="hour1">1 год</option>
                                    <option value="120" data-i18n="hour2">2 год</option>
                                </select>
                            </div>
                        </div>
                        
                        <!-- Сповістити про нагадування (контроль) -->
                        <div class="form-group full-width">
                            <label class="form-label">
                                <i data-lucide="eye" class="icon icon-sm"></i> 
                                <span data-i18n="notifyOnReminder">Контроль (хто отримає нагадування)</span>
                            </label>
                            <div id="taskNotifyReminder" style="margin-top:0.5rem;"></div>
                        </div>
                        
                        <!-- Сповіщення про виконання -->
                        <div class="form-group full-width">
                            <label class="form-label">
                                <i data-lucide="bell" class="icon icon-sm"></i> 
                                <span data-i18n="notifyOnComplete">Сповістити про виконання</span>
                            </label>
                            <div id="taskNotifyUsers" style="margin-top:0.5rem;"></div>
                        </div>
                    </div>
                    <div id="taskReviewActions" style="display:none;padding:0.75rem 1rem;margin:0.5rem 0;border-radius:12px;">
                        <div id="taskActionsLabel" style="font-size:0.85rem;font-weight:600;margin-bottom:0.5rem;display:flex;align-items:center;gap:0.4rem;"></div>
                        <div id="taskActionsButtons" style="display:flex;gap:0.5rem;flex-wrap:wrap;"></div>
                    </div>
                    <div class="form-actions"><button type="button" class="btn" onclick="closeModal('taskModal')" data-i18n="cancel">Скасувати</button><button type="submit" class="btn btn-success" data-i18n="save">Зберегти</button></div>
                </form>
                
                <!-- COMMENTS SECTION -->
                <div id="taskCommentsSection" class="comments-section hidden">
                    <!-- FILE ATTACHMENTS -->
                    <div class="task-files-section">
                        <div class="task-files-header">
                            <label class="form-label" style="margin:0;">
                                <i data-lucide="paperclip" class="icon icon-sm"></i>
                                <span data-i18n="attachments">Файли</span>
                                <span id="fileCount" style="background:var(--info);color:white;font-size:0.7rem;padding:0.1rem 0.4rem;border-radius:8px;font-weight:600;margin-left:4px;">0</span>
                            </label>
                        </div>
                        <div id="taskFilesList" class="task-files-list">
                            <!-- Files rendered here -->
                        </div>
                        <div id="fileUploadArea" class="file-upload-area" 
                             onclick="document.getElementById('fileInput').click()"
                             ondragover="event.preventDefault(); this.classList.add('dragover')"
                             ondragleave="this.classList.remove('dragover')"
                             ondrop="handleFileDrop(event); this.classList.remove('dragover')">
                            <div class="upload-icon"><i data-lucide="upload-cloud" class="icon icon-lg"></i></div>
                            <div>Натисніть або перетягніть файли сюди</div>
                            <div style="font-size:0.75rem;color:#9ca3af;margin-top:0.25rem;">Макс. 10 МБ на файл • PDF, DOC, XLS, зображення</div>
                        </div>
                        <input type="file" id="fileInput" multiple accept=".pdf,.doc,.docx,.xls,.xlsx,.png,.jpg,.jpeg,.gif,.webp,.zip,.txt,.csv" style="display:none" onchange="handleFileSelect(event)">
                        <div id="fileUploadProgress" class="file-upload-progress">
                            <div class="progress-bar"><div class="progress-fill" id="fileProgressFill" style="width:0%"></div></div>
                            <div class="progress-text" id="fileProgressText">Завантаження...</div>
                        </div>
                    </div>
                    
                    <div style="height:1rem;"></div>
                    <div class="comments-header">
                        <i data-lucide="message-circle" class="icon"></i>
                        <span data-i18n="comments">Коментарі</span>
                        <span id="commentCount" class="comment-count">0</span>
                    </div>
                    <div id="commentsList" class="comments-list">
                        <div class="comments-empty">
                            <div class="comments-empty-icon"><i data-lucide="message-circle" class="icon icon-xl"></i></div>
                            <span data-i18n="noComments">Ще немає коментарів</span>
                        </div>
                    </div>
                    <div class="comment-input-wrapper">
                        <textarea id="commentInput" class="comment-input" placeholder="Написати коментар..." rows="1" onkeydown="handleCommentKeydown(event)"></textarea>
                        <button type="button" class="comment-send-btn" onclick="sendComment()" id="sendCommentBtn">
                            <i data-lucide="send" class="icon"></i>
                        </button>
                    </div>
                </div>
                
                <!-- AUDIT LOG SECTION -->
                <div id="taskHistorySection" class="comments-section hidden" style="margin-top:0;">
                    <div class="comments-header" style="cursor:pointer;" onclick="toggleHistorySection()">
                        <i data-lucide="history" class="icon"></i>
                        <span>Історія змін</span>
                        <span id="historyCount" class="comment-count">0</span>
                        <i data-lucide="chevron-down" class="icon icon-sm" id="historyChevron" style="margin-left:auto;transition:transform 0.2s;"></i>
                    </div>
                    <div id="historyList" style="display:none;max-height:300px;overflow-y:auto;padding:0.5rem 0;">
                        <p style="color:var(--gray);text-align:center;font-size:0.85rem;padding:1rem;">Немає записів</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="functionModal" class="modal">
        <div class="modal-content">
            <div class="modal-header"><span class="close" onclick="closeModal('functionModal')">&times;</span><h2 id="functionModalTitle" data-i18n="newFunction">Нова функція</h2></div>
            <div class="modal-body">
                <form id="functionForm" onsubmit="saveFunction(event)">
                    <div class="form-grid">
                        <div class="form-group"><label class="form-label" data-i18n="title">Назва *</label><input type="text" id="functionName" class="form-input" required></div>
                        <div class="form-group"><label class="form-label"><i data-lucide="crown" class="icon icon-sm"></i> <span data-i18n="head">Головний *</span></label><select id="functionHead" class="form-select" required><option value="" data-i18n="select">Оберіть</option></select></div>
                        <div class="form-group full-width"><label class="form-label" data-i18n="description">Опис</label><textarea id="functionDescription" class="form-textarea"></textarea></div>
                        <div class="form-group full-width"><label class="form-label"><i data-lucide="users" class="icon icon-sm"></i> <span data-i18n="members">Учасники</span></label><div id="functionAssignees" style="display:flex;flex-wrap:wrap;gap:0.4rem;margin-top:0.4rem;"></div></div>
                    </div>
                    <div class="form-actions"><button type="button" class="btn" onclick="closeModal('functionModal')" data-i18n="cancel">Скасувати</button><button type="submit" class="btn btn-success" data-i18n="save">Зберегти</button></div>
                </form>
            </div>
        </div>
    </div>

    <!-- MERGE FUNCTIONS MODAL -->
    <div id="mergeFunctionsModal" class="modal">
        <div class="modal-content" style="max-width:500px;">
            <div class="modal-header">
                <span class="close" onclick="closeModal('mergeFunctionsModal')">&times;</span>
                <h2><i data-lucide="git-merge" class="icon"></i> <span data-i18n="mergeFunctions">Об'єднати функції</span></h2>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label" data-i18n="selectFunctionsToMerge">Оберіть функції для об'єднання (2-5):</label>
                    <div id="mergeFunctionsList" style="max-height:250px;overflow-y:auto;border:1px solid #e5e7eb;border-radius:8px;padding:0.5rem;"></div>
                </div>
                <div class="form-group">
                    <label class="form-label" data-i18n="newFunctionName">Назва об'єднаної функції *</label>
                    <input type="text" id="mergedFunctionName" class="form-input" placeholder="Введіть назву..." required>
                </div>
                <div id="mergePreview" style="display:none;background:#f0fdf4;border:1px solid #bbf7d0;border-radius:8px;padding:1rem;margin-top:1rem;">
                    <div style="font-weight:600;color:#16a34a;margin-bottom:0.5rem;"><i data-lucide="info" class="icon icon-sm"></i> Буде об'єднано:</div>
                    <div id="mergePreviewContent" style="font-size:0.9rem;color:#166534;"></div>
                </div>
                <div class="form-actions" style="margin-top:1.5rem;">
                    <button type="button" class="btn" onclick="closeModal('mergeFunctionsModal')" data-i18n="cancel">Скасувати</button>
                    <button type="button" class="btn btn-success" onclick="executeMergeFunctions()" id="executeMergeBtn" disabled>
                        <i data-lucide="git-merge" class="icon"></i> <span data-i18n="merge">Об'єднати</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- PROCESS TEMPLATES MODAL -->
    <div id="processTemplatesModal" class="modal">
        <div class="modal-content" style="max-width:700px;">
            <div class="modal-header">
                <span class="close" onclick="closeModal('processTemplatesModal')">&times;</span>
                <h2><i data-lucide="file-cog" class="icon"></i> <span data-i18n="processTemplates">Шаблони процесів</span></h2>
            </div>
            <div class="modal-body">
                <div style="display:flex;justify-content:flex-end;margin-bottom:1rem;">
                    <button class="btn btn-success" onclick="openEditTemplateModal()">
                        <i data-lucide="plus" class="icon"></i> <span data-i18n="newTemplate">Новий шаблон</span>
                    </button>
                </div>
                <div id="processTemplatesList" style="max-height:400px;overflow-y:auto;">
                    <!-- Templates list -->
                </div>
            </div>
        </div>
    </div>

    <!-- EDIT PROCESS TEMPLATE MODAL -->
    <div id="editProcessTemplateModal" class="modal">
        <div class="modal-content" style="max-width:600px;">
            <div class="modal-header">
                <span class="close" onclick="closeModal('editProcessTemplateModal')">&times;</span>
                <h2 id="editTemplateTitle"><i data-lucide="file-cog" class="icon"></i> <span data-i18n="newTemplate">Новий шаблон</span></h2>
            </div>
            <div class="modal-body">
                <form id="processTemplateForm" onsubmit="saveProcessTemplate(event)">
                    <input type="hidden" id="processTemplateId">
                    <div class="form-group">
                        <label class="form-label" data-i18n="templateName">Назва шаблону *</label>
                        <input type="text" id="processTemplateName" class="form-input" placeholder="Наприклад: Обробка замовлення" required>
                    </div>
                    <div class="form-group">
                        <label class="form-label" data-i18n="templateDescription">Опис</label>
                        <textarea id="processTemplateDescription" class="form-textarea" rows="2" placeholder="Короткий опис процесу"></textarea>
                    </div>
                    <div class="form-group">
                        <label class="form-label"><i data-lucide="git-branch" class="icon icon-sm"></i> <span data-i18n="processSteps">Етапи процесу</span></label>
                        <div id="templateStepsContainer" class="process-steps-builder">
                            <!-- Steps will be added here -->
                        </div>
                        <button type="button" class="add-step-btn" onclick="addTemplateStep()" style="margin-top:0.5rem;">
                            <i data-lucide="plus" class="icon icon-sm"></i> <span data-i18n="addStep">Додати етап</span>
                        </button>
                    </div>
                    <div class="form-actions">
                        <button type="button" class="btn" onclick="closeModal('editProcessTemplateModal')" data-i18n="cancel">Скасувати</button>
                        <button type="submit" class="btn btn-success" data-i18n="save">Зберегти</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- START PROCESS MODAL -->
    <div id="startProcessModal" class="modal">
        <div class="modal-content" style="max-width:500px;">
            <div class="modal-header">
                <span class="close" onclick="closeModal('startProcessModal')">&times;</span>
                <h2><i data-lucide="play" class="icon"></i> <span data-i18n="startProcess">Запустити процес</span></h2>
            </div>
            <div class="modal-body">
                <form id="startProcessForm" onsubmit="startProcess(event)">
                    <div class="form-group">
                        <label class="form-label" data-i18n="selectTemplate">Оберіть шаблон *</label>
                        <select id="startProcessTemplate" class="form-select" required onchange="updateStartProcessPreview()">
                            <option value="" data-i18n="select">Оберіть</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label" data-i18n="processName">Назва процесу *</label>
                        <input type="text" id="startProcessName" class="form-input" placeholder="Наприклад: Замовлення #127 - Клієнт Іванов" required>
                    </div>
                    <div class="form-group">
                        <label class="form-label"><i data-lucide="calendar" class="icon icon-sm"></i> <span data-i18n="deadline">Дедлайн</span> <span style="color:var(--gray);font-weight:normal;">(опціонально)</span></label>
                        <input type="date" id="startProcessDeadline" class="form-input">
                    </div>
                    <div id="startProcessPreview" style="display:none;margin-top:1rem;">
                        <label class="form-label"><i data-lucide="git-branch" class="icon icon-sm"></i> <span data-i18n="processFlow">Послідовність</span></label>
                        <div id="startProcessSteps" style="display:flex;flex-wrap:wrap;gap:0.5rem;align-items:center;padding:1rem;background:#f9fafb;border-radius:8px;"></div>
                    </div>
                    <div class="form-actions" style="margin-top:1.5rem;">
                        <button type="button" class="btn" onclick="closeModal('startProcessModal')" data-i18n="cancel">Скасувати</button>
                        <button type="submit" class="btn btn-success">
                            <i data-lucide="play" class="icon"></i> <span data-i18n="start">Запустити</span>
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- VIEW PROCESS MODAL -->
    <div id="viewProcessModal" class="modal">
        <div class="modal-content" style="max-width:600px;">
            <div class="modal-header">
                <span class="close" onclick="closeModal('viewProcessModal')">&times;</span>
                <h2 id="viewProcessTitle"><i data-lucide="git-branch" class="icon"></i> Процес</h2>
            </div>
            <div class="modal-body">
                <div id="viewProcessContent">
                    <!-- Process details will be here -->
                </div>
            </div>
        </div>
    </div>

    <div id="regularTaskModal" class="modal">
        <div class="modal-content">
            <div class="modal-header"><span class="close" onclick="closeModal('regularTaskModal')">&times;</span><h2 data-i18n="regularTask">Регулярне завдання</h2></div>
            <div class="modal-body">
                <form id="regularTaskForm" onsubmit="saveRegularTask(event)">
                    <div class="form-grid">
                        <div class="form-group full-width"><label class="form-label" data-i18n="title">Назва *</label><input type="text" id="regularTaskTitle" class="form-input" required></div>
                        <div class="form-group"><label class="form-label" data-i18n="function">Функція *</label><select id="regularTaskFunction" class="form-select" required><option value="" data-i18n="select">Оберіть</option></select></div>
                        <div class="form-group"><label class="form-label">Виконавець</label><select id="regularTaskAssignee" class="form-select"><option value="">З функції (авто)</option></select></div>
                        <div class="form-group"><label class="form-label" data-i18n="periodicity">Періодичність *</label><select id="regularTaskPeriod" class="form-select" onchange="updatePeriodOptions()"><option value="weekly" data-i18n="weekly">Щотижня</option><option value="monthly" data-i18n="monthly">Щомісяця</option><option value="quarterly" data-i18n="quarterly">Щокварталу</option></select></div>
                        <div class="form-group full-width" id="dayOfWeekGroup">
                            <label class="form-label" data-i18n="daysOfWeek">Дні тижня *</label>
                            <div style="display:flex;gap:0.5rem;margin-bottom:0.5rem;">
                                <button type="button" onclick="selectAllDays()" class="btn" style="padding:0.3rem 0.6rem;font-size:0.75rem;" data-i18n="selectAll">Всі дні</button>
                                <button type="button" onclick="selectWorkDays()" class="btn" style="padding:0.3rem 0.6rem;font-size:0.75rem;" data-i18n="workDays">Пн-Пт</button>
                                <button type="button" onclick="clearDays()" class="btn" style="padding:0.3rem 0.6rem;font-size:0.75rem;background:#f3f4f6;color:#374151;" data-i18n="clearDays">Очистити</button>
                            </div>
                            <div id="daysCheckboxes" style="display:flex;flex-wrap:wrap;gap:0.5rem;">
                                <label style="display:flex;align-items:center;gap:0.3rem;padding:0.4rem 0.7rem;background:#f9fafb;border:1px solid #e5e7eb;border-radius:8px;cursor:pointer;font-size:0.85rem;transition:all 0.2s;">
                                    <input type="checkbox" name="dayOfWeek" value="1" style="accent-color:var(--primary);"> <span data-i18n="mon">Пн</span>
                                </label>
                                <label style="display:flex;align-items:center;gap:0.3rem;padding:0.4rem 0.7rem;background:#f9fafb;border:1px solid #e5e7eb;border-radius:8px;cursor:pointer;font-size:0.85rem;transition:all 0.2s;">
                                    <input type="checkbox" name="dayOfWeek" value="2" style="accent-color:var(--primary);"> <span data-i18n="tue">Вт</span>
                                </label>
                                <label style="display:flex;align-items:center;gap:0.3rem;padding:0.4rem 0.7rem;background:#f9fafb;border:1px solid #e5e7eb;border-radius:8px;cursor:pointer;font-size:0.85rem;transition:all 0.2s;">
                                    <input type="checkbox" name="dayOfWeek" value="3" style="accent-color:var(--primary);"> <span data-i18n="wed">Ср</span>
                                </label>
                                <label style="display:flex;align-items:center;gap:0.3rem;padding:0.4rem 0.7rem;background:#f9fafb;border:1px solid #e5e7eb;border-radius:8px;cursor:pointer;font-size:0.85rem;transition:all 0.2s;">
                                    <input type="checkbox" name="dayOfWeek" value="4" style="accent-color:var(--primary);"> <span data-i18n="thu">Чт</span>
                                </label>
                                <label style="display:flex;align-items:center;gap:0.3rem;padding:0.4rem 0.7rem;background:#f9fafb;border:1px solid #e5e7eb;border-radius:8px;cursor:pointer;font-size:0.85rem;transition:all 0.2s;">
                                    <input type="checkbox" name="dayOfWeek" value="5" style="accent-color:var(--primary);"> <span data-i18n="fri">Пт</span>
                                </label>
                                <label style="display:flex;align-items:center;gap:0.3rem;padding:0.4rem 0.7rem;background:#f9fafb;border:1px solid #e5e7eb;border-radius:8px;cursor:pointer;font-size:0.85rem;transition:all 0.2s;">
                                    <input type="checkbox" name="dayOfWeek" value="6" style="accent-color:var(--primary);"> <span data-i18n="sat">Сб</span>
                                </label>
                                <label style="display:flex;align-items:center;gap:0.3rem;padding:0.4rem 0.7rem;background:#f9fafb;border:1px solid #e5e7eb;border-radius:8px;cursor:pointer;font-size:0.85rem;transition:all 0.2s;">
                                    <input type="checkbox" name="dayOfWeek" value="0" style="accent-color:var(--primary);"> <span data-i18n="sun">Нд</span>
                                </label>
                            </div>
                        </div>
                        <div class="form-group" id="dayOfMonthGroup" style="display:none;"><label class="form-label" data-i18n="dayOfMonth">День місяця *</label><select id="regularTaskDayOfMonth" class="form-select"><option value="1">1</option><option value="5">5</option><option value="10">10</option><option value="15">15</option><option value="20">20</option><option value="25">25</option><option value="last" data-i18n="lastDay">Останній день</option></select></div>
                        <div class="form-group"><label class="form-label">Початок *</label><input type="time" id="regularTaskTimeStart" class="form-input" value="10:00" required></div>
                        <div class="form-group"><label class="form-label" data-i18n="endDuration">Кінець / Тривалість</label>
                            <div style="display:flex;gap:8px;align-items:center;">
                                <select id="regularTaskTimeMode" class="form-select" style="width:auto;" onchange="toggleRegularTimeMode()">
                                    <option value="end" data-i18n="endTime">Час кінця</option>
                                    <option value="duration" data-i18n="duration">Тривалість</option>
                                </select>
                                <input type="time" id="regularTaskTimeEnd" class="form-input" value="11:00" style="flex:1;">
                                <select id="regularTaskDuration" class="form-select" style="flex:1;display:none;">
                                    <option value="15" data-i18n="min15">15 хв</option>
                                    <option value="30" data-i18n="min30">30 хв</option>
                                    <option value="45" data-i18n="min45">45 хв</option>
                                    <option value="60" selected data-i18n="hour1">1 год</option>
                                    <option value="90" data-i18n="hour1_5">1.5 год</option>
                                    <option value="120" data-i18n="hour2">2 год</option>
                                    <option value="180" data-i18n="hour3">3 год</option>
                                    <option value="240" data-i18n="hour4">4 год</option>
                                </select>
                            </div>
                        </div>
                        <div class="form-group"><label class="form-label" data-i18n="priority">Пріоритет</label><select id="regularTaskPriority" class="form-select"><option value="medium" data-i18n="normal">Звичайний</option><option value="high" data-i18n="high">Високий 🔴</option><option value="low" data-i18n="low">Низький</option></select></div>
                        <div class="form-group"><label class="form-label" style="display:flex;align-items:center;gap:0.5rem;"><input type="checkbox" id="regularTaskRequireReview" style="accent-color:var(--primary);width:18px;height:18px;"> <span data-i18n="requireReview">Потрібна перевірка</span></label></div>
                        <div class="form-group full-width"><label class="form-label" data-i18n="expectedResult">Очікуваний результат</label><textarea id="regularTaskExpectedResult" class="form-textarea" placeholder="Що конкретно має бути зроблено?"></textarea></div>
                        <div class="form-group full-width"><label class="form-label" data-i18n="reportFormat">Формат звіту</label><textarea id="regularTaskReportFormat" class="form-textarea" style="min-height:80px;resize:vertical;" placeholder="Скрін / Посилання / Фото / Документ"></textarea></div>
                        <div class="form-group full-width"><label class="form-label"><i data-lucide="file-text" class="icon icon-sm"></i> <span data-i18n="instruction">Інструкція (необов'язково)</span></label><textarea id="regularTaskInstruction" class="form-textarea" style="min-height:100px;" placeholder="Детальна інструкція як виконувати це завдання..."></textarea></div>
                        
                        <!-- Чекліст для регулярних -->
                        <div class="form-group full-width">
                            <label class="form-label"><i data-lucide="check-square" class="icon icon-sm"></i> Чекліст</label>
                            <div id="regularTaskChecklist" style="display:flex;flex-direction:column;gap:0.4rem;margin-bottom:0.5rem;"></div>
                            <div style="display:flex;gap:0.5rem;">
                                <input type="text" id="regularChecklistInput" class="form-input" placeholder="Новий пункт..." style="flex:1;" onkeydown="if(event.key==='Enter'){event.preventDefault();addRegularChecklistItem();}">
                                <button type="button" class="btn btn-success" onclick="addRegularChecklistItem()" style="padding:0.4rem 0.8rem;">+</button>
                            </div>
                        </div>
                        
                        <!-- Сповіщення про виконання -->
                        <div class="form-group full-width">
                            <label class="form-label">
                                <i data-lucide="bell" class="icon icon-sm"></i> 
                                <span data-i18n="notifyOnComplete">Сповістити про виконання</span>
                            </label>
                            <div id="regularTaskNotifyUsers" style="display:flex;flex-wrap:wrap;gap:0.5rem;margin-top:0.5rem;padding:0.75rem;background:#f9fafb;border-radius:8px;max-height:150px;overflow-y:auto;"></div>
                        </div>
                        
                        <div class="form-group full-width">
                            <div class="info-box" style="background:#e8f5e9;padding:0.75rem;border-radius:8px;font-size:0.85rem;">
                                <i data-lucide="lightbulb" class="icon icon-sm" style="color:#f59e0b;"></i> <span data-i18n="functionAssigneeHint">Виконавці беруться автоматично з обраної функції. Хто в функції — той і виконує.</span>
                            </div>
                        </div>
                    </div>
                    <div class="form-actions"><button type="button" class="btn" onclick="closeModal('regularTaskModal')" data-i18n="cancel">Скасувати</button><button type="submit" class="btn btn-success" data-i18n="save">Зберегти</button></div>
                </form>
            </div>
        </div>
    </div>

    <div id="inviteModal" class="modal">
        <div class="modal-content">
            <div class="modal-header"><span class="close" onclick="closeModal('inviteModal')">&times;</span><h2 data-i18n="inviteTitle">Запрошення</h2></div>
            <div class="modal-body">
                <form id="inviteForm" onsubmit="sendInvite(event)">
                    <div class="form-group">
                        <label class="form-label" data-i18n="employeeEmail">Email співробітника *</label>
                        <input type="email" id="inviteEmail" class="form-input" required>
                    </div>
                    <div class="form-group" style="margin-top:0.75rem;">
                        <label class="form-label" data-i18n="role">Роль</label>
                        <select id="inviteRole" class="form-select"><option value="employee" data-i18n="roleEmployee">Співробітник</option><option value="manager" data-i18n="roleManager">Менеджер</option></select>
                    </div>
                    <div id="inviteLink" style="margin-top:1rem;padding:1rem;background:#e3f2fd;border-radius:8px;display:none;">
                        <p style="font-size:0.85rem;margin-bottom:0.5rem;"><strong data-i18n="inviteLinkLabel">Посилання для входу:</strong></p>
                        <input type="text" id="inviteLinkText" class="form-input" readonly style="font-size:0.8rem;">
                        <button type="button" onclick="copyInviteLink()" class="btn btn-small" style="margin-top:0.5rem;"><i data-lucide="copy" class="icon icon-sm"></i> <span data-i18n="copy">Копіювати</span></button>
                    </div>
                    <div class="form-actions"><button type="button" class="btn" onclick="closeModal('inviteModal')" data-i18n="close">Закрити</button><button type="submit" class="btn btn-success"><i data-lucide="send" class="icon"></i> <span data-i18n="createInvite">Створити запрошення</span></button></div>
                </form>
            </div>
        </div>
    </div>

    <div id="userModal" class="modal">
        <div class="modal-content">
            <div class="modal-header"><span class="close" onclick="closeModal('userModal')">&times;</span><h2 id="userModalTitle" data-i18n="editEmployee">Редагувати співробітника</h2></div>
            <div class="modal-body">
                <form id="userForm" onsubmit="saveUser(event)">
                    <div class="form-grid">
                        <div class="form-group full-width">
                            <label class="form-label" data-i18n="name">Ім'я *</label>
                            <input type="text" id="userName" class="form-input" required>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Email</label>
                            <input type="email" id="userEmail" class="form-input" readonly style="background:#f0f0f0;">
                        </div>
                        <div class="form-group">
                            <label class="form-label" data-i18n="role">Роль</label>
                            <select id="userRole" class="form-select">
                                <option value="employee" data-i18n="roleEmployee">Співробітник</option>
                                <option value="manager" data-i18n="roleManager">Менеджер</option>
                            </select>
                        </div>
                        <div class="form-group full-width">
                            <label class="form-label" data-i18n="position">Посада</label>
                            <input type="text" id="userPosition" class="form-input" placeholder="Менеджер з продажу">
                        </div>
                        <div class="form-group full-width">
                            <label class="form-label" data-i18n="userFunctions">Функції співробітника</label>
                            <div id="userFunctions" style="display:flex;flex-wrap:wrap;gap:0.4rem;margin-top:0.4rem;padding:0.8rem;background:#f8f9fa;border-radius:8px;"></div>
                        </div>
                    </div>
                    <div class="form-actions">
                        <button type="button" class="btn" onclick="closeModal('userModal')" data-i18n="cancel">Скасувати</button>
                        <button type="submit" class="btn btn-success" data-i18n="save">Зберегти</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
    
    <!-- Profile Modal -->
    <div id="profileModal" class="modal">
        <div class="modal-content" style="max-width:500px;">
            <div class="modal-header">
                <h3><i data-lucide="user" class="icon"></i> Мій профіль</h3>
                <button class="close-btn" onclick="closeModal('profileModal')">&times;</button>
            </div>
            <div style="padding:1.5rem;">
                <!-- User Info -->
                <div style="display:flex;align-items:center;gap:1rem;margin-bottom:1.5rem;padding-bottom:1.5rem;border-bottom:1px solid #e5e7eb;">
                    <div style="width:60px;height:60px;background:linear-gradient(135deg, var(--primary), var(--primary-dark));border-radius:50%;display:flex;align-items:center;justify-content:center;color:white;font-size:1.5rem;font-weight:600;" id="profileAvatar">U</div>
                    <div>
                        <div style="font-weight:600;font-size:1.1rem;" id="profileName">Користувач</div>
                        <div style="color:var(--gray);font-size:0.9rem;" id="profileEmail"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="92f7fff3fbfed2f7eaf3ffe2fef7bcf1fdff">[email&#160;protected]</a></div>
                        <div style="margin-top:0.25rem;"><span class="status-badge" style="background:#e0e7ff;color:#4338ca;" id="profileRole">Роль</span></div>
                    </div>
                </div>
                
                <!-- Google Calendar Integration -->
                <div style="background:#f9fafb;border-radius:12px;padding:1rem;margin-bottom:1rem;">
                    <div style="display:flex;align-items:center;gap:0.75rem;margin-bottom:0.75rem;">
                        <div style="width:40px;height:40px;background:white;border-radius:8px;display:flex;align-items:center;justify-content:center;box-shadow:0 1px 3px rgba(0,0,0,0.1);">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
                                <path d="M18 4H6C4.9 4 4 4.9 4 6v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2z" fill="#4285F4"/>
                                <path d="M18 4H6C4.9 4 4 4.9 4 6v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2z" fill="none" stroke="#4285F4" stroke-width="0"/>
                                <rect x="6" y="8" width="12" height="2" fill="white"/>
                                <rect x="6" y="12" width="5" height="2" fill="#EA4335"/>
                                <rect x="13" y="12" width="5" height="2" fill="#FBBC04"/>
                                <rect x="6" y="16" width="5" height="2" fill="#34A853"/>
                                <rect x="13" y="16" width="5" height="2" fill="#4285F4"/>
                            </svg>
                        </div>
                        <div>
                            <div style="font-weight:600;">Google Calendar</div>
                            <div style="font-size:0.8rem;color:var(--gray);">Синхронізація завдань з календарем</div>
                        </div>
                    </div>
                    
                    <div id="gcalStatus">
                        <div id="gcalNotConnected">
                            <p style="font-size:0.85rem;color:#666;margin-bottom:0.75rem;">
                                Підключіть Google Calendar щоб бачити завдання у своєму календарі
                            </p>
                            <button class="btn btn-success" onclick="connectGoogleCalendar()" style="width:100%;">
                                <i data-lucide="link" class="icon"></i> Підключити Google Calendar
                            </button>
                        </div>
                        <div id="gcalConnected" style="display:none;">
                            <div style="display:flex;align-items:center;gap:0.5rem;padding:0.75rem;background:#ecfdf5;border-radius:8px;margin-bottom:0.75rem;">
                                <i data-lucide="check-circle" class="icon" style="color:#10b981;"></i>
                                <span style="color:#065f46;font-weight:500;">Календар підключено</span>
                            </div>
                            <p style="font-size:0.8rem;color:#666;margin-bottom:0.5rem;" id="gcalEmail"></p>
                            <button class="btn" onclick="disconnectGoogleCalendar()" style="width:100%;background:#fee2e2;color:#991b1b;">
                                <i data-lucide="unlink" class="icon"></i> Відключити
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Telegram Integration -->
                <div style="background:#f9fafb;border-radius:12px;padding:1rem;margin-bottom:1rem;">
                    <div style="display:flex;align-items:center;gap:0.75rem;margin-bottom:0.75rem;">
                        <div style="width:40px;height:40px;background:linear-gradient(135deg, #0088cc, #00aced);border-radius:8px;display:flex;align-items:center;justify-content:center;box-shadow:0 1px 3px rgba(0,0,0,0.1);">
                            <svg width="22" height="22" viewBox="0 0 24 24" fill="white">
                                <path d="M11.944 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0a12 12 0 0 0-.056 0zm4.962 7.224c.1-.002.321.023.465.14a.506.506 0 0 1 .171.325c.016.093.036.306.02.472-.18 1.898-.962 6.502-1.36 8.627-.168.9-.499 1.201-.82 1.23-.696.065-1.225-.46-1.9-.902-1.056-.693-1.653-1.124-2.678-1.8-1.185-.78-.417-1.21.258-1.91.177-.184 3.247-2.977 3.307-3.23.007-.032.014-.15-.056-.212s-.174-.041-.249-.024c-.106.024-1.793 1.14-5.061 3.345-.48.33-.913.49-1.302.48-.428-.008-1.252-.241-1.865-.44-.752-.245-1.349-.374-1.297-.789.027-.216.325-.437.893-.663 3.498-1.524 5.83-2.529 6.998-3.014 3.332-1.386 4.025-1.627 4.476-1.635z"/>
                            </svg>
                        </div>
                        <div>
                            <div style="font-weight:600;">Telegram сповіщення</div>
                            <div style="font-size:0.8rem;color:var(--gray);">Отримуйте сповіщення про завдання</div>
                        </div>
                    </div>
                    
                    <div id="telegramStatus">
                        <div id="telegramNotConnected">
                            <p style="font-size:0.85rem;color:#666;margin-bottom:0.75rem;">
                                Підключіть Telegram щоб отримувати сповіщення про нові завдання
                            </p>
                            <button class="btn" onclick="connectTelegram()" style="width:100%;background:linear-gradient(135deg, #0088cc, #00aced);color:white;">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="white" style="margin-right:0.5rem;"><path d="M11.944 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0a12 12 0 0 0-.056 0zm4.962 7.224c.1-.002.321.023.465.14a.506.506 0 0 1 .171.325c.016.093.036.306.02.472-.18 1.898-.962 6.502-1.36 8.627-.168.9-.499 1.201-.82 1.23-.696.065-1.225-.46-1.9-.902-1.056-.693-1.653-1.124-2.678-1.8-1.185-.78-.417-1.21.258-1.91.177-.184 3.247-2.977 3.307-3.23.007-.032.014-.15-.056-.212s-.174-.041-.249-.024c-.106.024-1.793 1.14-5.061 3.345-.48.33-.913.49-1.302.48-.428-.008-1.252-.241-1.865-.44-.752-.245-1.349-.374-1.297-.789.027-.216.325-.437.893-.663 3.498-1.524 5.83-2.529 6.998-3.014 3.332-1.386 4.025-1.627 4.476-1.635z"/></svg>
                                Підключити Telegram
                            </button>
                        </div>
                        <div id="telegramConnected" style="display:none;">
                            <div style="display:flex;align-items:center;gap:0.5rem;padding:0.75rem;background:#ecfdf5;border-radius:8px;margin-bottom:0.75rem;">
                                <i data-lucide="check-circle" class="icon" style="color:#10b981;"></i>
                                <span style="color:#065f46;font-weight:500;">Telegram підключено</span>
                            </div>
                            <button class="btn" onclick="disconnectTelegram()" style="width:100%;background:#fee2e2;color:#991b1b;">
                                <i data-lucide="unlink" class="icon"></i> Відключити
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Info -->
                <div style="font-size:0.8rem;color:#888;text-align:center;">
                    <i data-lucide="info" class="icon icon-sm"></i>
                    Нові завдання автоматично з'являться у вашому Google Calendar
                </div>
            </div>
        </div>
    </div>

    <a href="https://chatgpt.com/g/g-69382bfa841881918aff7b50aa25a4f9-talko-task-manager-support" target="_blank" class="support-btn">
        <i data-lucide="bot" class="icon"></i> <span data-i18n="aiSupport">AI Підтримка</span>
    </a>

    <footer class="footer">
        <p>Powered by <strong style="color:#3498db;">TALKO System</strong></p>
    </footer>

    <script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>
        // =====================
        // TRANSLATIONS
        // =====================
        const translations = {
            ua: {
                // Auth
                authSubtitle: 'Управління завданнями для бізнесу',
                signInGoogle: 'Увійти через Google',
                or: 'або',
                password: 'Пароль:',
                signIn: '<i data-lucide="log-in" class="icon icon-sm"></i> Увійти',
                forgotPassword: 'Забули пароль?',
                noAccess: 'Немає доступу?',
                contactUs: "Зв'яжіться з нами",
                noAccessTitle: '<i data-lucide="ban" class="icon icon-sm"></i> Доступ відсутній',
                noAccessText: "Ваш email не зареєстровано в системі.<br>Зверніться до адміністратора для отримання доступу.",
                contactSupport: "<i data-lucide=\"phone\" class=\"icon icon-sm\"></i> Зв'язатися з підтримкою",
                tryAnotherEmail: 'Спробувати інший email',
                haveInvite: 'Перший вхід?',
                registerBtn: 'Активувати доступ',
                registerHint: 'Тільки для власників при першому вході. Далі використовуйте "Увійти".',
                howToLogin: 'Як увійти?',
                forOwners: 'Для власників:',
                ownersInstruction: 'Перший раз → "Активувати доступ". Далі → "Увійти" з email та паролем',
                forEmployees: 'Для співробітників:',
                employeesInstruction: 'Перейдіть за посиланням від керівника. Увійдіть через Google з робочим email',
                registerTitle: 'Активація доступу',
                createPassword: 'Придумайте пароль:',
                confirmPassword: 'Підтвердіть пароль:',
                registerSubmit: 'Зареєструватися',
                backToLogin: '← Повернутися до входу',
                logout: 'Вийти',
                
                // Tabs
                tabMyDay: 'Мій день',
                myDay: 'Мій день',
                tabTasks: 'Завдання',
                tabControl: 'Контроль',
                tabRegular: 'Регулярні',
                tabFunctions: 'Функції',
                tabTeam: 'Команда',
                tabAdmin: 'Адмін',
                
                // Tasks
                addTask: '+ Завдання',
                allStatuses: 'Всі статуси',
                allFunctions: 'Всі функції',
                allDates: 'Всі дати',
                today: 'Сьогодні',
                thisWeek: 'Цей тиждень',
                customPeriod: 'Обрати період',
                overdue: 'Прострочені',
                all: 'Всі',
                newTask: 'Нове завдання',
                editTask: 'Редагувати',
                title: 'Назва *',
                function: 'Функція',
                noFunction: 'Без функції',
                assignee: 'Виконавець *',
                select: 'Оберіть',
                deadlineDate: 'Дедлайн (дата) *',
                deadlineTime: 'Дедлайн (час) *',
                estimatedTime: 'Орієнтовний час',
                notSpecified: 'Не вказано',
                expectedResult: 'Очікуваний результат',
                reportFormat: 'Формат звіту',
                reminders: 'Нагадування до дедлайну',
                escalation: 'Ескалація при простроченні',
                notifyOnReminder: 'Контроль (хто отримає нагадування)',
                notifyOnComplete: 'Сповістити про виконання',
                reminder1hour: 'За 1 год',
                reminder30min: 'За 30 хв',
                reminder15min: 'За 15 хв',
                createRepeatTask: 'Створити повторну задачу',
                afterTime: 'через',
                min15: '15 хв',
                min30: '30 хв',
                min45: '45 хв',
                hour1: '1 год',
                hour1_5: '1.5 год',
                hour2: '2 год',
                hour3: '3 год',
                hour4: '4 год',
                hour8: '8 год',
                endDuration: 'Кінець / Тривалість',
                endTime: 'Час кінця',
                duration: 'Тривалість',
                priority: 'Пріоритет',
                status: 'Статус',
                description: 'Опис',
                cancel: 'Скасувати',
                save: 'Зберегти',
                close: 'Закрити',
                
                // Comments
                comments: 'Коментарі',
                noComments: 'Ще немає коментарів',
                writeComment: 'Написати коментар...',
                
                // Statuses
                statusNew: 'Нове',
                statusProgress: 'В роботі',
                statusReview: 'Перевірка',
                statusDone: 'Готово',
                hideCompleted: 'Приховати виконані',
                coExecutors: 'Співвиконавці',
                observers: 'Спостерігачі',
                startDate: 'Дата початку',
                requireReview: 'Перевірка після виконання',
                allowDeadlineChange: 'Виконавець може змінювати строки',
                checklist: 'Чеклист',
                addChecklistItem: 'Додати пункт',
                deadlineLocked: 'Зміна строків заблокована постановником',
                timeTracking: 'Облік часу',
                planned: 'Запланований',
                actual: 'Фактичний',
                startTimer: 'Старт',
                stopTimer: 'Стоп',
                addTimeManually: 'Додати час вручну',
                
                // Priorities
                priorityLow: 'Низький',
                priorityMedium: 'Середній',
                priorityHigh: 'Високий',
                
                // Control
                controlPanel: 'Панель контролю',
                critical: 'Критичні',
                attention: 'Увага',
                active: 'Активні',
                completed: 'Готово',
                workload: 'Навантаження',
                noActiveTasks: 'Немає активних завдань',
                
                // Regular
                addRegular: '+ Регулярне',
                regularTask: 'Регулярне завдання',
                regularTasks: 'Регулярні завдання',
                week: 'Тиждень',
                day: 'День',
                month: 'Місяць',
                list: 'Список',
                add: 'Додати',
                noTime: 'Без часу',
                periodicity: 'Періодичність *',
                weekly: 'Щотижня',
                monthly: 'Щомісяця',
                quarterly: 'Щокварталу',
                daysOfWeek: 'Дні тижня *',
                selectAll: 'Всі дні',
                workDays: 'Пн-Пт',
                clearDays: 'Очистити',
                mon: 'Пн',
                tue: 'Вт',
                wed: 'Ср',
                thu: 'Чт',
                fri: 'Пт',
                sat: 'Сб',
                sun: 'Нд',
                dayOfMonth: 'День місяця *',
                timeOfDay: 'Час виконання *',
                lastDay: 'Останній день',
                monday: 'Понеділок',
                tuesday: 'Вівторок',
                wednesday: 'Середа',
                thursday: 'Четвер',
                friday: "П'ятниця",
                saturday: 'Субота',
                sunday: 'Неділя',
                instruction: 'Інструкція (необов\'язково)',
                allPeriods: 'Всі періоди',
                assignees: 'Виконавці',
                selectFunctionFirst: 'Спочатку оберіть функцію',
                noMembers: 'Немає учасників',
                create: 'Створити',
                radarAI: 'Керівник',
                techAI: 'Помічник',
                
                // Functions
                addFunction: '+ Функція',
                newFunction: 'Нова функція',
                head: 'Головний *',
                members: 'Учасники',
                tasks: 'завдань',
                mergeFunctions: 'Об\'єднати',
                selectFunctionsToMerge: 'Оберіть функції для об\'єднання (2-5):',
                newFunctionName: 'Назва об\'єднаної функції *',
                merge: 'Об\'єднати',
                willBeMerged: 'Буде об\'єднано',
                tasksCount: 'завдань',
                regularTasksCount: 'регулярних',
                assigneesCount: 'виконавців',
                mergeSuccess: 'Функції успішно об\'єднано',
                mergeSelectMinTwo: 'Оберіть мінімум 2 функції',
                mergeSelectMaxFive: 'Максимум 5 функцій',
                mergeEnterName: 'Введіть назву об\'єднаної функції',
                mergedFrom: 'Об\'єднано з',
                
                // Team
                invite: 'Запросити',
                inviteTitle: 'Запрошення',
                employeeEmail: 'Email співробітника *',
                role: 'Роль',
                roleOwner: 'Власник',
                roleManager: 'Менеджер',
                roleEmployee: 'Співробітник',
                inviteLinkLabel: 'Посилання для входу:',
                copy: 'Копіювати',
                createInvite: 'Створити запрошення',
                
                // Admin
                adminPanel: 'Адмін-панель TALKO',
                createCompany: 'Створити нову компанію',
                ownerEmail: 'Email власника *',
                passwordLabel: 'Пароль *',
                ownerName: "Ім'я власника *",
                companyName: 'Назва компанії *',
                createCompanyBtn: 'Створити компанію та Owner',
                allCompanies: 'Всі компанії',
                users: 'користувачів',
                
                // Empty states
                noTasks: 'Завдань немає',
                createFirstTask: 'Створіть перше завдання',
                noFunctions: 'Функцій немає',
                functionAssigneeHint: 'Виконавці беруться автоматично з обраної функції. Хто в функції — той і виконує.',
                people: 'осіб',
                createFirstFunction: 'Створіть першу функцію',
                noRegular: 'Регулярних завдань немає',
                noRegularForDay: 'На цей день регулярних завдань немає',
                todaysTasks: 'Мої на сьогодні',
                allDays: 'Всі дні',
                createRegular: 'Створіть регулярне завдання',
                noUsers: 'Немає користувачів',
                noCompanies: 'Немає компаній',
                
                // Other
                support: 'Підтримка',
                footerSupport: '<i data-lucide="life-buoy" class="icon icon-sm"></i> Підтримка',
                notAssigned: 'Не призначено',
                deleteConfirm: 'Видалити?',
                error: 'Помилка',
                created: 'створено',
                copied: 'Посилання скопійовано!',
                
                // New filters & analytics
                clear: 'Очистити',
                allTasks: 'Всі завдання',
                myTasks: 'Мої завдання',
                createdByMe: 'Створені мною',
                statuses: 'Статуси',
                functions: 'Функції',
                task: 'Завдання',
                createdBy: 'Створив',
                deadline: 'Дедлайн',
                type: 'Тип',
                actions: 'Дії',
                schedule: 'Розклад',
                statusPeriod: 'Статус',
                createAgain: 'Створити ще раз',
                markDone: 'Позначити виконаним',
                noTasksFound: 'Завдань не знайдено',
                changeFilters: 'Змініть фільтри або додайте нове завдання',
                edit: 'Редагувати',
                delete: 'Видалити',
                
                // Control panel
                controlPanelTitle: 'Панель контролю завдань',
                assigneeLabel: 'Виконавець:',
                functionLabel: 'Функція:',
                periodLabel: 'Період:',
                allAssignees: 'Всі виконавці',
                allTime: 'Весь час',
                thisMonth: 'Цей місяць',
                overdueLabel: 'Прострочені',
                todayTomorrow: 'Сьогодні-завтра',
                inWork: 'В роботі',
                completedLabel: 'Завершені',
                viewLabel: 'Перегляд:',
                employeeWorkload: 'Навантаження співробітників',
                byFunctions: 'По функціях',
                
                // Processes
                tabProcesses: 'Процеси',
                processes: 'Бізнес-процеси',
                allProcesses: 'Всі процеси',
                showCompleted: 'Архів',
                templates: 'Шаблони',
                startProcess: 'Запустити',
                aiAssistant: 'AI-асистент',
                processTemplates: 'Шаблони процесів',
                newTemplate: 'Новий шаблон',
                templateName: 'Назва шаблону *',
                templateDescription: 'Опис',
                processSteps: 'Етапи процесу',
                addStep: 'Додати етап',
                selectTemplate: 'Оберіть шаблон *',
                processName: 'Назва процесу *',
                processFlow: 'Послідовність',
                start: 'Запустити',
                noProcesses: 'Немає активних процесів',
                createProcessTemplate: 'Створіть шаблон процесу та запустіть перший процес',
                createTemplate: 'Створити шаблон',
                editTemplate: 'Редагувати шаблон',
                deleteTemplate: 'Видалити шаблон',
                stepFunction: 'Функція етапу',
                stepTitle: 'Назва етапу',
                stepResult: 'Очікуваний результат',
                completeStep: 'Завершити етап',
                processHistory: 'Історія процесу',
                currentStep: 'Поточний етап',
                noTemplates: 'Немає шаблонів процесів',
                createFirstTemplate: 'Створіть перший шаблон',
                activeProcesses: 'активних',
                templateSaved: 'Шаблон збережено',
                processStarted: 'Процес запущено',
                stepCompleted: 'Етап завершено',
                
                // Analytics
                tabAnalytics: 'Аналітика',
                analytics: 'Аналітика',
                totalTasks: 'Всього завдань',
                completedTasks: 'Виконано',
                completionRate: 'Виконання %',
                avgTime: 'Сер. час',
                byStatus: 'По статусах',
                topPerformers: 'Топ виконавців',
                noCompletedTasks: 'Немає виконаних завдань',
                
                // Users
                tabUsers: 'Співробітники',
                addEmployee: '+ Додати співробітника',
                editEmployee: 'Редагувати співробітника',
                name: "Ім'я *",
                position: 'Посада',
                userFunctions: 'Функції співробітника',
                inviteFirst: 'Запросіть першого співробітника',
                noEmployees: 'Немає співробітників',
                
                // Regular
                addRegularTask: '+ Регулярне завдання',
                
                // Mobile menu
                menu: 'Меню',
                aiAssistants: 'AI Асистенти',
                aiManager: 'Керівник',
                aiTechnical: 'Технічний',
                aiSupport: 'AI Помічник (Підтримка)',
                profile: 'Профіль',
                enableNotifications: 'Увімкнути сповіщення',
                disableNotifications: 'Вимкнути сповіщення',
                loadDemoData: 'Завантажити демо-дані',
                // Review (перевірка)
                taskSentForReview: 'Відправлено на перевірку',
                taskOnReview: 'Завдання на перевірці',
                acceptTask: 'Прийняти',
                rejectTask: 'На доопрацювання',
                taskAccepted: 'Завдання прийнято',
                taskRejected: 'Повернуто на доопрацювання',
                reviewByCreator: 'Очікує перевірки постановником',
                rejectReasonPlaceholder: 'Причина повернення (необовʼязково)',

                // Dynamic strings (previously hardcoded)
                inviteNotFound: 'Запрошення не знайдено або застаріло',
                enterEmail: 'Введіть email',
                passwordMinLength: 'Пароль має бути мінімум 6 символів',
                passwordsMismatch: 'Паролі не співпадають',
                registering: 'Реєстрація...',
                emailMismatchInvite: 'Email не співпадає з запрошенням',
                registerSuccess: 'Успішно зареєстровано!',
                registerError: 'Помилка реєстрації',
                emailAlreadyRegistered: 'Цей email вже зареєстровано. Спробуйте увійти.',
                invalidEmail: 'Невірний формат email',
                weakPassword: 'Занадто простий пароль',
                enterEmailAndPassword: 'Введіть email і пароль',
                loginError: 'Помилка входу',
                userNotFound: 'Користувача не знайдено',
                wrongPassword: 'Невірний пароль',
                invalidCredentials: 'Невірний email або пароль',
                enterEmailForReset: 'Введіть email для відновлення пароля',
                resetLinkSentTo: 'Посилання надіслано на ',
                adminRole: '(Адміністратор)',
                inviteAlreadyUsed: 'Це запрошення вже використано. Увійдіть з вашим email та паролем.',
                inviteNotFoundEmail: 'Запрошення не знайдено. Введіть email з якого вас запрошували.',
                employeeRole: 'Співробітник',
                taskCompleted: 'Завдання виконано!',
                fromProcess: 'З бізнес-процесу',
                regularTaskLabel: 'Регулярне завдання',
                newTaskLabel: 'Нове завдання',
                restoreFromArchive: 'Відновити завдання з архіву?',
                taskRestored: 'Завдання відновлено',
                overdueStatus: 'Прострочено',
                moreItems: 'ще',
                forToday: 'На сьогодні',
                newFromProcesses: 'Нові з процесів',
                greeting: 'Вітаю',
                yourTasksToday: 'Ваші завдання на сьогодні',
                startWork: 'Почати роботу',
                viewTask: 'Перегляд завдання',
                tooManyRequests: 'Забагато запитів. Зачекайте хвилину.',
                howManyMinutes: 'Скільки хвилин витрачено?',
                checklistItemPlaceholder: 'Пункт чеклисту...',
                noTasksLabel: 'Немає завдань',
                awaitingReview: 'Чекає перевірки постановником',
                noTimeLabel: 'Без часу',
                overdueLabel2: 'Прострочені',
                todayLabel: 'Сьогодні',
                tomorrowLabel: 'Завтра',
                thisWeekLabel: 'Цей тиждень',
                laterLabel: 'Пізніше',
                noDateLabel: 'Без дати',
                reviewLabel: 'Перевірка',
                showMore: 'Показати ще',
                deleteProcess: 'Видалити процес',
                minTwoSteps: 'Додайте мінімум 2 етапи',
                deleteTemplateConfirm: 'Видалити шаблон? Активні процеси залишаться.',
                templateDeleted: 'Шаблон процесу було видалено',
                templateNotFound: 'Шаблон процесу не знайдено',
                onlyFunctionMembers: 'Тільки члени функції можуть завершити цей етап',
                systemUser: 'Система',
                selectAssigneeOrFunction: 'Оберіть виконавця або функцію з виконавцями',
                selectAtLeastOneDay: 'Оберіть хоча б один день тижня',
                noExecutorsInFunction: 'В функції немає виконавців',
                createdLabel: 'Створено',
                tasksWord: 'завдань',
                daily: 'Щодня',
                monFri: 'Пн-Пт',
                instructionLabel: 'Інструкція',
                completedStatus: 'Виконано',
                inProgressStatus: 'В роботі',
                pendingStatus: 'Очікує',
                monthlyTasks: 'Щомісячні завдання',
                lastDayLabel: 'Останній день',
                dayOfMonthLabel: '-го числа',
                quarterlyTasks: 'Щоквартальні завдання',
                oncePerQuarter: 'Раз на квартал',
                companyDeleted: 'Компанію видалено',
                deleteError: 'Помилка видалення: ',
                creating: 'Створюємо...',
                viewBtn: 'Переглянути',
                editBtn: 'Редагувати',
                demoDataLoaded: 'Демо-дані успішно завантажено!',
                loadError: 'Помилка завантаження: ',
                noTasksToday: 'Немає завдань на сьогодні!',
                hourShort: ' год ',
                minShort: ' хв',
                taskFromProcess: 'Завдання з процесу',
                noTasksForToday: 'На сьогодні завдань немає',
                timeToRest: 'Час відпочити або взяти нові завдання',
                allTasksDone: 'Всі завдання виконано!',
                greatJob: 'Чудова робота! Час на перерву.',
                doneToday: 'Виконано сьогодні',
                toDo: 'До виконання',
                onReview: 'На перевірці',
                regularType: 'регулярне',
                oneTimeType: 'разове',
                daySun: 'Нд',
                dayMon: 'Пн',
                dayTue: 'Вт',
                dayWed: 'Ср',
                dayThu: 'Чт',
                dayFri: 'Пт',
                daySat: 'Сб',
                statusesLabel: 'Статуси',
                deleteConfirmProcess: 'Видалити цей процес?',
                stepSkipConfirm: 'Пропустити цей етап?',
                processStepTaskCreated: 'Автоматично створено завдання для наступного етапу',

                deleteProcessConfirm: 'Видалити цей процес?',
                systemAuto: 'Автоматично',
                cannotDeleteOwner: 'Неможливо видалити власника',
                noAssigneesInFunc: 'В функції немає виконавців',
                loadDemoConfirm: 'Завантажити демо-дані? Існуючі дані не будуть видалені.',

                taskLimitWarning: 'Завантажено {n} завдань. Старіші завдання приховані. Рекомендуємо архівувати виконані.',
                restorePartial: 'Відновлено {ok} з {total}. {fail} не вдалось відновити.',
                restoreSuccess: 'Відновлено {n} елемент(ів)',
                rejectedTaskMsg: 'повернув завдання',

                functionsNotFound: 'Функції не знайдено',
                functionNotExists: 'Функція "{name}" не існує. Оновіть шаблон.',
                functionNoExecutors: 'Функція "{name}" не має виконавців. Додайте виконавців перед запуском.',
                skipStepConfirm: 'Є незавершене завдання "{title}" для цього кроку. Все одно перейти на наступний крок?',
                functionNoExecutorsWarning: 'Увага: функція "{name}" не має виконавців. Завдання не створено.',
                inviteCreated: 'Запрошення створено!\n\nНадішліть посилання співробітнику.',
                deleteCompanyConfirm: 'Видалити компанію "{name}"?\n\nБуде видалено:\n• {users} користувачів\n• {tasks} завдань\n• Всі функції та регулярні завдання\n\nЦю дію неможливо скасувати!',
                deleteCompanyConfirm2: 'Точно видалити "{name}"? Введіть "так" для підтвердження:',
                companyCreated: 'Компанія "{name}" створена!\n\nEmail: {email}\nПароль: {password}\n\nНадішліть клієнту:\n1. Посилання: taskmanagerai-vert.vercel.app\n2. Email та пароль\n3. Інструкція: "Активувати доступ" → ввести дані',
                createCompanyFirst: 'Спочатку створіть компанію в адмін-панелі, потім завантажуйте демо-дані.',

                projectActive: 'Активний',
                projectCompleted: 'Завершено',
                projectPaused: 'Пауза',

                functionNameRequired: 'Назва функції обовʼязкова',
                functionNameTooLong: 'Назва занадто довга (макс. 200 символів)',
                functionNameDuplicate: 'Функція з такою назвою вже існує',
                functionHeadRequired: 'Головний обовʼязковий',
                logoutConfirm: 'Вийти з акаунту?',
                reopen: 'Відновити',
                completeTask: 'Завершити',
                taskReopened: 'Завдання повернуто в роботу',
                newProject: 'Новий проєкт',

                signInFirst: 'Спочатку увійдіть в акаунт',
                fillAllFields: 'Заповніть всі поля',
                createError: 'Помилка створення',
                taskNotFoundArchive: 'Завдання не знайдено в архіві',
                restoreError: 'Помилка відновлення',
                deadlineExceedsProject: '⚠️ Дедлайн задачі ({taskDate}) виходить за дедлайн проєкту "{projName}" ({projDate})',
                noTasksForExport: 'Немає завдань для експорту',
                deadlineUpdated: 'Дедлайн оновлено',
                taskModifiedByOther: 'Це завдання було змінено іншим користувачем. Зберегти ваші зміни?',
                taskCompleted: 'Завдання виконано',
                taskReturnedForRevision: 'Повернуто на доопрацювання',
                taskForReview: 'Завдання на перевірку',
                processAdvancedShort: 'Процес просунувся',
                processCompletedShort: 'Процес завершено',
                newTask: 'Нове завдання',
                regularTaskLabel: 'Регулярне завдання',
                processTask: 'Завдання з процесу',
                fromFunctionAuto: 'З функції (авто)',
                deleteProjectWithTasks: 'Видалити проєкт? {total} завдань ({undone} незавершених) залишаться в загальному списку.',
                deleteEmptyProject: 'Видалити порожній проєкт?',
                tasksUnlinked: '{n} завдань відвʼязано від проєкту',
                projectStatusChanged: 'Проєкт "{name}" → {status}',
                confirmProjectComplete: 'В проєкті {n} незавершених завдань. Все одно позначити як "Завершено"?',
                processAdvanced: 'Процес "{name}" → крок {step}/{total}: {stepName}',
                processNoExecutors: 'Функція "{func}" без виконавців — завдання не створено',
                processCompleted: 'Процес "{name}" завершено!',
                confirmCompanyAction: '{action} цю компанію?',
                companyBlocked: 'Компанію заблоковано',
                companyUnblocked: 'Компанію розблоковано',
                browserNoNotifications: 'Ваш браузер не підтримує сповіщення',
                notificationsDenied: 'Дозвіл на сповіщення не надано. Перевірте налаштування браузера.',
                googleApiNotLoaded: 'Google API не завантажено. Спробуйте оновити сторінку.',
                googleAuthError: 'Помилка авторизації Google',
                googleCalendarConnected: 'Google Calendar успішно підключено!',
                saveError: 'Помилка збереження',
                disconnectGoogleCalendar: 'Відключити Google Calendar? Синхронізація завдань буде зупинена.',
                googleCalendarDisconnected: 'Google Calendar відключено',
                notAuthorized: 'Помилка: не авторизовано',
                disconnectTelegram: 'Відключити Telegram? Ви перестанете отримувати сповіщення.',
                telegramDisconnected: 'Telegram відключено',
                superAdminOnly: 'Доступно тільки для SuperAdmin',
                textMismatch: 'Текст не співпадає. Скасовано.',
                deletingData: 'Видалення даних...',
                deletedNRecords: 'Видалено {n} записів',
                commentSendError: 'Помилка відправки коментаря',
                escalationCritical: '🚨 КРИТИЧНО: {n} задач прострочено 7+ днів!',
                escalationWarning: '⚠️ {n} задач прострочено 3+ дні',
                noPermissionTask: 'Недостатньо прав для зміни цієї задачі',
                deadlineChangeError: 'Помилка зміни дедлайну',
                deleteFileConfirm: 'Видалити файл?',
                fileDeleted: 'Файл видалено',
                fileDeleteError: 'Помилка видалення файлу',
                saveTaskBeforeFiles: 'Збережіть завдання перед додаванням файлів',
                fileTooBig: 'Файл "{name}" перевищує 10 МБ',
                fileTypeNotSupported: 'Тип файлу .{ext} не підтримується',
                filesUploaded: 'Завантажено {n} файл(ів)',
                fileUploadError: 'Помилка завантаження файлу',
                sentForReview: 'Відправлено на перевірку',
                editProject: 'Редагувати проєкт',
            },
            ru: {
                // Auth
                authSubtitle: 'Управление задачами для бизнеса',
                signInGoogle: 'Войти через Google',
                or: 'или',
                password: 'Пароль:',
                signIn: '<i data-lucide="log-in" class="icon icon-sm"></i> Войти',
                forgotPassword: 'Забыли пароль?',
                noAccess: 'Нет доступа?',
                contactUs: 'Свяжитесь с нами',
                noAccessTitle: '<i data-lucide="ban" class="icon icon-sm"></i> Доступ отсутствует',
                noAccessText: 'Ваш email не зарегистрирован в системе.<br>Обратитесь к администратору для получения доступа.',
                contactSupport: '<i data-lucide="phone" class="icon icon-sm"></i> Связаться с поддержкой',
                tryAnotherEmail: 'Попробовать другой email',
                haveInvite: 'Первый вход?',
                registerBtn: 'Активировать доступ',
                registerHint: 'Только для владельцев при первом входе. Далее используйте "Войти".',
                howToLogin: 'Как войти?',
                forOwners: 'Для владельцев:',
                ownersInstruction: 'Первый раз → "Активировать доступ". Далее → "Войти" с email и паролем',
                forEmployees: 'Для сотрудников:',
                employeesInstruction: 'Перейдите по ссылке от руководителя. Войдите через Google с рабочим email',
                registerTitle: 'Активация доступа',
                createPassword: 'Придумайте пароль:',
                confirmPassword: 'Подтвердите пароль:',
                registerSubmit: 'Зарегистрироваться',
                backToLogin: '← Вернуться ко входу',
                logout: 'Выйти',
                
                // Tabs
                tabMyDay: 'Мой день',
                myDay: 'Мой день',
                tabTasks: 'Задачи',
                tabControl: 'Контроль',
                tabRegular: 'Регулярные',
                tabFunctions: 'Функции',
                tabTeam: 'Команда',
                tabAdmin: 'Админ',
                
                // Tasks
                addTask: '+ Задача',
                allStatuses: 'Все статусы',
                allFunctions: 'Все функции',
                allDates: 'Все даты',
                today: 'Сегодня',
                thisWeek: 'Эта неделя',
                customPeriod: 'Выбрать период',
                overdue: 'Просроченные',
                all: 'Все',
                newTask: 'Новая задача',
                editTask: 'Редактировать',
                title: 'Название *',
                function: 'Функция',
                noFunction: 'Без функции',
                assignee: 'Исполнитель *',
                select: 'Выберите',
                deadlineDate: 'Дедлайн (дата) *',
                deadlineTime: 'Дедлайн (время) *',
                estimatedTime: 'Ориентировочное время',
                notSpecified: 'Не указано',
                expectedResult: 'Ожидаемый результат',
                reportFormat: 'Формат отчета',
                notifyOnComplete: 'Уведомить о выполнении',
                reminders: 'Напоминание до дедлайна',
                escalation: 'Эскалация при просрочке',
                notifyOnReminder: 'Контроль (кто получит напоминание)',
                reminder1hour: 'За 1 час',
                reminder30min: 'За 30 мин',
                reminder15min: 'За 15 мин',
                createRepeatTask: 'Создать повторную задачу',
                afterTime: 'через',
                min15: '15 мин',
                min30: '30 мин',
                min45: '45 мин',
                hour1: '1 час',
                hour1_5: '1.5 часа',
                hour2: '2 часа',
                hour3: '3 часа',
                hour4: '4 часа',
                hour8: '8 часов',
                endDuration: 'Конец / Длительность',
                endTime: 'Время конца',
                duration: 'Длительность',
                priority: 'Приоритет',
                status: 'Статус',
                description: 'Описание',
                cancel: 'Отмена',
                save: 'Сохранить',
                close: 'Закрыть',
                
                // Comments
                comments: 'Комментарии',
                noComments: 'Пока нет комментариев',
                writeComment: 'Написать комментарий...',
                
                // Statuses
                statusNew: 'Новое',
                statusProgress: 'В работе',
                statusReview: 'Проверка',
                statusDone: 'Готово',
                hideCompleted: 'Скрыть выполненные',
                coExecutors: 'Соисполнители',
                observers: 'Наблюдатели',
                startDate: 'Дата начала',
                requireReview: 'Проверка после выполнения',
                allowDeadlineChange: 'Исполнитель может менять сроки',
                checklist: 'Чеклист',
                addChecklistItem: 'Добавить пункт',
                deadlineLocked: 'Изменение сроков заблокировано постановщиком',
                timeTracking: 'Учет времени',
                planned: 'Запланировано',
                actual: 'Фактически',
                startTimer: 'Старт',
                stopTimer: 'Стоп',
                addTimeManually: 'Добавить время вручную',
                
                // Priorities
                priorityLow: 'Низкий',
                priorityMedium: 'Средний',
                priorityHigh: 'Высокий',
                
                // Control
                controlPanel: 'Панель контроля',
                critical: 'Критические',
                attention: 'Внимание',
                active: 'Активные',
                completed: 'Готово',
                workload: 'Нагрузка',
                noActiveTasks: 'Нет активных задач',
                
                // Regular
                addRegular: '+ Регулярное',
                regularTask: 'Регулярная задача',
                regularTasks: 'Регулярные задачи',
                week: 'Неделя',
                day: 'День',
                month: 'Месяц',
                list: 'Список',
                add: 'Добавить',
                noTime: 'Без времени',
                periodicity: 'Периодичность *',
                weekly: 'Еженедельно',
                monthly: 'Ежемесячно',
                quarterly: 'Ежеквартально',
                daysOfWeek: 'Дни недели *',
                selectAll: 'Все дни',
                workDays: 'Пн-Пт',
                clearDays: 'Очистить',
                mon: 'Пн',
                tue: 'Вт',
                wed: 'Ср',
                thu: 'Чт',
                fri: 'Пт',
                sat: 'Сб',
                sun: 'Вс',
                dayOfMonth: 'День месяца *',
                timeOfDay: 'Время выполнения *',
                lastDay: 'Последний день',
                monday: 'Понедельник',
                tuesday: 'Вторник',
                wednesday: 'Среда',
                thursday: 'Четверг',
                friday: 'Пятница',
                saturday: 'Суббота',
                sunday: 'Воскресенье',
                instruction: 'Инструкция (необязательно)',
                allPeriods: 'Все периоды',
                assignees: 'Исполнители',
                selectFunctionFirst: 'Сначала выберите функцию',
                noMembers: 'Нет участников',
                create: 'Создать',
                radarAI: 'Руководитель',
                techAI: 'Помощник',
                
                // Functions
                addFunction: '+ Функция',
                newFunction: 'Новая функция',
                head: 'Главный *',
                members: 'Участники',
                tasks: 'задач',
                mergeFunctions: 'Объединить',
                selectFunctionsToMerge: 'Выберите функции для объединения (2-5):',
                newFunctionName: 'Название объединённой функции *',
                merge: 'Объединить',
                willBeMerged: 'Будет объединено',
                tasksCount: 'задач',
                regularTasksCount: 'регулярных',
                assigneesCount: 'исполнителей',
                mergeSuccess: 'Функции успешно объединены',
                mergeSelectMinTwo: 'Выберите минимум 2 функции',
                mergeSelectMaxFive: 'Максимум 5 функций',
                mergeEnterName: 'Введите название объединённой функции',
                mergedFrom: 'Объединено из',
                
                // Team
                invite: 'Пригласить',
                inviteTitle: 'Приглашение',
                employeeEmail: 'Email сотрудника *',
                role: 'Роль',
                roleOwner: 'Владелец',
                roleManager: 'Менеджер',
                roleEmployee: 'Сотрудник',
                inviteLinkLabel: 'Ссылка для входа:',
                copy: 'Копировать',
                createInvite: 'Создать приглашение',
                
                // Admin
                adminPanel: 'Админ-панель TALKO',
                createCompany: 'Создать новую компанию',
                ownerEmail: 'Email владельца *',
                passwordLabel: 'Пароль *',
                ownerName: 'Имя владельца *',
                companyName: 'Название компании *',
                createCompanyBtn: 'Создать компанию и Owner',
                allCompanies: 'Все компании',
                users: 'пользователей',
                
                // Empty states
                noTasks: 'Задач нет',
                createFirstTask: 'Создайте первую задачу',
                noFunctions: 'Функций нет',
                functionAssigneeHint: 'Исполнители берутся автоматически из выбранной функции. Кто в функции — тот и выполняет.',
                people: 'чел.',
                createFirstFunction: 'Создайте первую функцию',
                noRegular: 'Регулярных задач нет',
                noRegularForDay: 'На этот день регулярных задач нет',
                todaysTasks: 'Мои на сегодня',
                allDays: 'Все дни',
                createRegular: 'Создайте регулярную задачу',
                noUsers: 'Нет пользователей',
                noCompanies: 'Нет компаний',
                
                // Other
                support: 'Поддержка',
                footerSupport: '<i data-lucide="life-buoy" class="icon icon-sm"></i> Поддержка',
                notAssigned: 'Не назначено',
                deleteConfirm: 'Удалить?',
                error: 'Ошибка',
                created: 'создано',
                copied: 'Ссылка скопирована!',
                
                // New filters & analytics
                clear: 'Очистить',
                allTasks: 'Все задачи',
                myTasks: 'Мои задачи',
                createdByMe: 'Созданные мной',
                statuses: 'Статусы',
                functions: 'Функции',
                task: 'Задача',
                createdBy: 'Создал',
                deadline: 'Дедлайн',
                type: 'Тип',
                actions: 'Действия',
                schedule: 'Расписание',
                statusPeriod: 'Статус',
                createAgain: 'Создать ещё раз',
                markDone: 'Отметить выполненным',
                noTasksFound: 'Задач не найдено',
                changeFilters: 'Измените фильтры или добавьте новую задачу',
                edit: 'Редактировать',
                delete: 'Удалить',
                
                // Control panel
                controlPanelTitle: 'Панель контроля задач',
                assigneeLabel: 'Исполнитель:',
                functionLabel: 'Функция:',
                periodLabel: 'Период:',
                allAssignees: 'Все исполнители',
                allTime: 'Все время',
                thisMonth: 'Этот месяц',
                overdueLabel: 'Просроченные',
                todayTomorrow: 'Сегодня-завтра',
                inWork: 'В работе',
                completedLabel: 'Завершенные',
                viewLabel: 'Просмотр:',
                employeeWorkload: 'Нагрузка сотрудников',
                byFunctions: 'По функциям',
                
                // Processes
                tabProcesses: 'Процессы',
                processes: 'Бизнес-процессы',
                allProcesses: 'Все процессы',
                showCompleted: 'Архив',
                templates: 'Шаблоны',
                startProcess: 'Запустить',
                aiAssistant: 'AI-ассистент',
                processTemplates: 'Шаблоны процессов',
                newTemplate: 'Новый шаблон',
                templateName: 'Название шаблона *',
                templateDescription: 'Описание',
                processSteps: 'Этапы процесса',
                addStep: 'Добавить этап',
                selectTemplate: 'Выберите шаблон *',
                processName: 'Название процесса *',
                processFlow: 'Последовательность',
                start: 'Запустить',
                noProcesses: 'Нет активных процессов',
                createProcessTemplate: 'Создайте шаблон процесса и запустите первый процесс',
                createTemplate: 'Создать шаблон',
                editTemplate: 'Редактировать шаблон',
                deleteTemplate: 'Удалить шаблон',
                stepFunction: 'Функция этапа',
                stepTitle: 'Название этапа',
                stepResult: 'Ожидаемый результат',
                completeStep: 'Завершить этап',
                processHistory: 'История процесса',
                currentStep: 'Текущий этап',
                noTemplates: 'Нет шаблонов процессов',
                createFirstTemplate: 'Создайте первый шаблон',
                activeProcesses: 'активных',
                templateSaved: 'Шаблон сохранён',
                processStarted: 'Процесс запущен',
                stepCompleted: 'Этап завершён',
                
                // Analytics
                tabAnalytics: 'Аналитика',
                analytics: 'Аналитика',
                totalTasks: 'Всего задач',
                completedTasks: 'Выполнено',
                completionRate: 'Выполнение %',
                avgTime: 'Сред. время',
                byStatus: 'По статусам',
                topPerformers: 'Топ исполнителей',
                noCompletedTasks: 'Нет выполненных задач',
                
                // Users
                tabUsers: 'Сотрудники',
                addEmployee: '+ Добавить сотрудника',
                editEmployee: 'Редактировать сотрудника',
                name: 'Имя *',
                position: 'Должность',
                userFunctions: 'Функции сотрудника',
                inviteFirst: 'Пригласите первого сотрудника',
                noEmployees: 'Нет сотрудников',
                
                // Regular
                addRegularTask: '+ Регулярная задача',
                
                // Mobile menu
                menu: 'Меню',
                aiAssistants: 'AI Ассистенты',
                aiManager: 'Руководитель',
                aiTechnical: 'Технический',
                aiSupport: 'AI Помощник (Поддержка)',
                profile: 'Профиль',
                enableNotifications: 'Включить уведомления',
                disableNotifications: 'Отключить уведомления',
                loadDemoData: 'Загрузить демо-данные',
                // Review (проверка)
                taskSentForReview: 'Отправлено на проверку',
                taskOnReview: 'Задача на проверке',
                acceptTask: 'Принять',
                rejectTask: 'На доработку',
                taskAccepted: 'Задача принята',
                taskRejected: 'Возвращено на доработку',
                reviewByCreator: 'Ожидает проверки постановщиком',
                rejectReasonPlaceholder: 'Причина возврата (необязательно)',

                // Dynamic strings (previously hardcoded)
                inviteNotFound: 'Приглашение не найдено или устарело',
                enterEmail: 'Введите email',
                passwordMinLength: 'Пароль должен быть минимум 6 символов',
                passwordsMismatch: 'Пароли не совпадают',
                registering: 'Регистрация...',
                emailMismatchInvite: 'Email не совпадает с приглашением',
                registerSuccess: 'Успешно зарегистрировано!',
                registerError: 'Ошибка регистрации',
                emailAlreadyRegistered: 'Этот email уже зарегистрирован. Попробуйте войти.',
                invalidEmail: 'Неверный формат email',
                weakPassword: 'Слишком простой пароль',
                enterEmailAndPassword: 'Введите email и пароль',
                loginError: 'Ошибка входа',
                userNotFound: 'Пользователь не найден',
                wrongPassword: 'Неверный пароль',
                invalidCredentials: 'Неверный email или пароль',
                enterEmailForReset: 'Введите email для восстановления пароля',
                resetLinkSentTo: 'Ссылка отправлена на ',
                adminRole: '(Администратор)',
                inviteAlreadyUsed: 'Это приглашение уже использовано. Войдите с вашим email и паролем.',
                inviteNotFoundEmail: 'Приглашение не найдено. Введите email с которого вас приглашали.',
                employeeRole: 'Сотрудник',
                taskCompleted: 'Задача выполнена!',
                fromProcess: 'Из бизнес-процесса',
                regularTaskLabel: 'Регулярная задача',
                newTaskLabel: 'Новая задача',
                restoreFromArchive: 'Восстановить задачу из архива?',
                taskRestored: 'Задача восстановлена',
                overdueStatus: 'Просрочено',
                moreItems: 'еще',
                forToday: 'На сегодня',
                newFromProcesses: 'Новые из процессов',
                greeting: 'Привет',
                yourTasksToday: 'Ваши задачи на сегодня',
                startWork: 'Начать работу',
                viewTask: 'Просмотр задачи',
                tooManyRequests: 'Слишком много запросов. Подождите минуту.',
                howManyMinutes: 'Сколько минут потрачено?',
                checklistItemPlaceholder: 'Пункт чеклиста...',
                noTasksLabel: 'Нет задач',
                awaitingReview: 'Ожидает проверки постановщиком',
                noTimeLabel: 'Без времени',
                overdueLabel2: 'Просроченные',
                todayLabel: 'Сегодня',
                tomorrowLabel: 'Завтра',
                thisWeekLabel: 'Эта неделя',
                laterLabel: 'Позже',
                noDateLabel: 'Без даты',
                reviewLabel: 'Проверка',
                showMore: 'Показать ещё',
                deleteProcess: 'Удалить процесс',
                minTwoSteps: 'Добавьте минимум 2 этапа',
                deleteTemplateConfirm: 'Удалить шаблон? Активные процессы останутся.',
                templateDeleted: 'Шаблон процесса был удалён',
                templateNotFound: 'Шаблон процесса не найден',
                onlyFunctionMembers: 'Только члены функции могут завершить этот этап',
                systemUser: 'Система',
                selectAssigneeOrFunction: 'Выберите исполнителя или функцию с исполнителями',
                selectAtLeastOneDay: 'Выберите хотя бы один день недели',
                noExecutorsInFunction: 'В функции нет исполнителей',
                createdLabel: 'Создано',
                tasksWord: 'задач',
                daily: 'Ежедневно',
                monFri: 'Пн-Пт',
                instructionLabel: 'Инструкция',
                completedStatus: 'Выполнено',
                inProgressStatus: 'В работе',
                pendingStatus: 'Ожидает',
                monthlyTasks: 'Ежемесячные задачи',
                lastDayLabel: 'Последний день',
                dayOfMonthLabel: '-го числа',
                quarterlyTasks: 'Ежеквартальные задачи',
                oncePerQuarter: 'Раз в квартал',
                companyDeleted: 'Компания удалена',
                deleteError: 'Ошибка удаления: ',
                creating: 'Создаем...',
                viewBtn: 'Просмотреть',
                editBtn: 'Редактировать',
                demoDataLoaded: 'Демо-данные успешно загружены!',
                loadError: 'Ошибка загрузки: ',
                noTasksToday: 'Нет задач на сегодня!',
                hourShort: ' ч ',
                minShort: ' мин',
                taskFromProcess: 'Задача из процесса',
                noTasksForToday: 'На сегодня задач нет',
                timeToRest: 'Время отдохнуть или взять новые задачи',
                allTasksDone: 'Все задачи выполнены!',
                greatJob: 'Отличная работа! Время на перерыв.',
                doneToday: 'Выполнено сегодня',
                toDo: 'К выполнению',
                onReview: 'На проверке',
                regularType: 'регулярное',
                oneTimeType: 'разовое',
                daySun: 'Вс',
                dayMon: 'Пн',
                dayTue: 'Вт',
                dayWed: 'Ср',
                dayThu: 'Чт',
                dayFri: 'Пт',
                daySat: 'Сб',
                statusesLabel: 'Статусы',
                deleteConfirmProcess: 'Удалить этот процесс?',
                stepSkipConfirm: 'Пропустить этот этап?',
                processStepTaskCreated: 'Автоматически создана задача для следующего этапа',

                deleteProcessConfirm: 'Удалить этот процесс?',
                systemAuto: 'Автоматически',
                cannotDeleteOwner: 'Невозможно удалить владельца',
                noAssigneesInFunc: 'В функции нет исполнителей',
                loadDemoConfirm: 'Загрузить демо-данные? Существующие данные не будут удалены.',

                taskLimitWarning: 'Загружено {n} задач. Старые задачи скрыты. Рекомендуем архивировать выполненные.',
                restorePartial: 'Восстановлено {ok} из {total}. {fail} не удалось восстановить.',
                restoreSuccess: 'Восстановлено {n} элемент(ов)',
                rejectedTaskMsg: 'вернул задачу',

                functionsNotFound: 'Функции не найдены',
                functionNotExists: 'Функция "{name}" не существует. Обновите шаблон.',
                functionNoExecutors: 'Функция "{name}" не имеет исполнителей. Добавьте исполнителей перед запуском.',
                skipStepConfirm: 'Есть незавершённая задача "{title}" для этого шага. Всё равно перейти?',
                functionNoExecutorsWarning: 'Внимание: функция "{name}" не имеет исполнителей. Задача не создана.',
                inviteCreated: 'Приглашение создано!\n\nОтправьте ссылку сотруднику.',
                deleteCompanyConfirm: 'Удалить компанию "{name}"?\n\nБудет удалено:\n• {users} пользователей\n• {tasks} задач\n• Все функции и регулярные задачи\n\nЭто действие нельзя отменить!',
                deleteCompanyConfirm2: 'Точно удалить "{name}"? Введите "да" для подтверждения:',
                companyCreated: 'Компания "{name}" создана!\n\nEmail: {email}\nПароль: {password}\n\nОтправьте клиенту:\n1. Ссылка: taskmanagerai-vert.vercel.app\n2. Email и пароль\n3. Инструкция: "Активировать доступ" → ввести данные',
                createCompanyFirst: 'Сначала создайте компанию в админ-панели, потом загружайте демо-данные.',

                projectActive: 'Активный',
                projectCompleted: 'Завершён',
                projectPaused: 'Пауза',
                functionNameRequired: 'Название функции обязательно',
                functionNameTooLong: 'Название слишком длинное (макс. 200 символов)',
                functionNameDuplicate: 'Функция с таким названием уже существует',
                functionHeadRequired: 'Руководитель обязателен',
                logoutConfirm: 'Выйти из аккаунта?',
                reopen: 'Восстановить',
                completeTask: 'Завершить',
                taskReopened: 'Задача возвращена в работу',
                newProject: 'Новый проект',

                signInFirst: 'Сначала войдите в аккаунт',
                fillAllFields: 'Заполните все поля',
                createError: 'Ошибка создания',
                taskNotFoundArchive: 'Задача не найдена в архиве',
                restoreError: 'Ошибка восстановления',
                deadlineExceedsProject: '⚠️ Дедлайн задачи ({taskDate}) выходит за дедлайн проекта "{projName}" ({projDate})',
                noTasksForExport: 'Нет задач для экспорта',
                deadlineUpdated: 'Дедлайн обновлён',
                taskModifiedByOther: 'Эта задача была изменена другим пользователем. Сохранить изменения?',
                taskCompleted: 'Задача выполнена',
                taskReturnedForRevision: 'Возвращено на доработку',
                taskForReview: 'Задача на проверку',
                processAdvancedShort: 'Процесс продвинулся',
                processCompletedShort: 'Процесс завершён',
                newTask: 'Новая задача',
                regularTaskLabel: 'Регулярная задача',
                processTask: 'Задача из процесса',
                fromFunctionAuto: 'Из функции (авто)',
                deleteProjectWithTasks: 'Удалить проект? {total} задач ({undone} незавершённых) останутся в общем списке.',
                deleteEmptyProject: 'Удалить пустой проект?',
                tasksUnlinked: '{n} задач отвязано от проекта',
                projectStatusChanged: 'Проект "{name}" → {status}',
                confirmProjectComplete: 'В проекте {n} незавершённых задач. Всё равно пометить как "Завершено"?',
                processAdvanced: 'Процесс "{name}" → шаг {step}/{total}: {stepName}',
                processNoExecutors: 'Функция "{func}" без исполнителей — задача не создана',
                processCompleted: 'Процесс "{name}" завершён!',
                confirmCompanyAction: '{action} эту компанию?',
                companyBlocked: 'Компания заблокирована',
                companyUnblocked: 'Компания разблокирована',
                browserNoNotifications: 'Ваш браузер не поддерживает уведомления',
                notificationsDenied: 'Разрешение на уведомления не предоставлено. Проверьте настройки браузера.',
                googleApiNotLoaded: 'Google API не загружено. Попробуйте обновить страницу.',
                googleAuthError: 'Ошибка авторизации Google',
                googleCalendarConnected: 'Google Calendar успешно подключён!',
                saveError: 'Ошибка сохранения',
                disconnectGoogleCalendar: 'Отключить Google Calendar? Синхронизация задач будет остановлена.',
                googleCalendarDisconnected: 'Google Calendar отключён',
                notAuthorized: 'Ошибка: не авторизован',
                disconnectTelegram: 'Отключить Telegram? Вы перестанете получать уведомления.',
                telegramDisconnected: 'Telegram отключён',
                superAdminOnly: 'Доступно только для SuperAdmin',
                textMismatch: 'Текст не совпадает. Отменено.',
                deletingData: 'Удаление данных...',
                deletedNRecords: 'Удалено {n} записей',
                commentSendError: 'Ошибка отправки комментария',
                escalationCritical: '🚨 КРИТИЧНО: {n} задач просрочено 7+ дней!',
                escalationWarning: '⚠️ {n} задач просрочено 3+ дня',
                noPermissionTask: 'Недостаточно прав для изменения этой задачи',
                deadlineChangeError: 'Ошибка изменения дедлайна',
                deleteFileConfirm: 'Удалить файл?',
                fileDeleted: 'Файл удалён',
                fileDeleteError: 'Ошибка удаления файла',
                saveTaskBeforeFiles: 'Сохраните задачу перед добавлением файлов',
                fileTooBig: 'Файл "{name}" превышает 10 МБ',
                fileTypeNotSupported: 'Тип файла .{ext} не поддерживается',
                filesUploaded: 'Загружено {n} файл(ов)',
                fileUploadError: 'Ошибка загрузки файла',
                sentForReview: 'Отправлено на проверку',
                editProject: 'Редактировать проект',
            },
            pl: {
                // Auth
                authSubtitle: 'Zarządzanie zadaniami dla biznesu',
                signInGoogle: 'Zaloguj przez Google',
                or: 'lub',
                password: 'Hasło:',
                signIn: '<i data-lucide="log-in" class="icon icon-sm"></i> Zaloguj',
                forgotPassword: 'Zapomniałeś hasła?',
                noAccess: 'Brak dostępu?',
                contactUs: 'Skontaktuj się z nami',
                noAccessTitle: '<i data-lucide="ban" class="icon icon-sm"></i> Brak dostępu',
                noAccessText: 'Twój email nie jest zarejestrowany w systemie.<br>Skontaktuj się z administratorem w celu uzyskania dostępu.',
                contactSupport: '<i data-lucide="phone" class="icon icon-sm"></i> Kontakt z pomocą techniczną',
                tryAnotherEmail: 'Spróbuj inny email',
                haveInvite: 'Pierwsze logowanie?',
                registerBtn: 'Aktywuj dostęp',
                registerHint: 'Tylko dla właścicieli przy pierwszym logowaniu. Później użyj "Zaloguj".',
                howToLogin: 'Jak się zalogować?',
                forOwners: 'Dla właścicieli:',
                ownersInstruction: 'Pierwszy raz → "Aktywuj dostęp". Później → "Zaloguj" z emailem i hasłem',
                forEmployees: 'Dla pracowników:',
                employeesInstruction: 'Przejdź pod link od kierownika. Zaloguj przez Google z firmowym emailem',
                registerTitle: 'Aktywacja dostępu',
                createPassword: 'Wymyśl hasło:',
                confirmPassword: 'Potwierdź hasło:',
                registerSubmit: 'Zarejestruj się',
                backToLogin: '← Powrót do logowania',
                logout: 'Wyloguj',
                
                // Tabs
                tabMyDay: 'Mój dzień',
                myDay: 'Mój dzień',
                tabTasks: 'Zadania',
                tabControl: 'Kontrola',
                tabRegular: 'Regularne',
                tabFunctions: 'Funkcje',
                tabTeam: 'Zespół',
                tabAdmin: 'Admin',
                
                // Tasks
                addTask: '+ Zadanie',
                allStatuses: 'Wszystkie statusy',
                allFunctions: 'Wszystkie funkcje',
                allDates: 'Wszystkie daty',
                today: 'Dzisiaj',
                thisWeek: 'Ten tydzień',
                thisMonth: 'Ten miesiąc',
                customPeriod: 'Wybierz okres',
                overdue: 'Zaległe',
                all: 'Wszystkie',
                newTask: 'Nowe zadanie',
                editTask: 'Edytuj',
                title: 'Nazwa *',
                function: 'Funkcja',
                noFunction: 'Bez funkcji',
                assignee: 'Wykonawca *',
                select: 'Wybierz',
                deadlineDate: 'Termin (data) *',
                deadlineTime: 'Termin (czas) *',
                estimatedTime: 'Szacowany czas',
                notSpecified: 'Nie określono',
                expectedResult: 'Oczekiwany rezultat',
                reportFormat: 'Format raportu',
                reminders: 'Przypomnienia przed terminem',
                escalation: 'Eskalacja przy opóźnieniu',
                notifyOnReminder: 'Kontrola (kto otrzyma przypomnienie)',
                notifyOnComplete: 'Powiadom o wykonaniu',
                reminder1hour: 'Za 1 godz',
                reminder30min: 'Za 30 min',
                reminder15min: 'Za 15 min',
                createRepeatTask: 'Utwórz powtórne zadanie',
                afterTime: 'po',
                min15: '15 min',
                min30: '30 min',
                min45: '45 min',
                hour1: '1 godz',
                hour1_5: '1.5 godz',
                hour2: '2 godz',
                hour3: '3 godz',
                hour4: '4 godz',
                hour8: '8 godz',
                endDuration: 'Koniec / Czas trwania',
                endTime: 'Czas zakończenia',
                duration: 'Czas trwania',
                priority: 'Priorytet',
                status: 'Status',
                description: 'Opis',
                cancel: 'Anuluj',
                save: 'Zapisz',
                close: 'Zamknij',
                
                // Comments
                comments: 'Komentarze',
                noComments: 'Brak komentarzy',
                writeComment: 'Napisz komentarz...',
                
                // Statuses
                statusNew: 'Nowe',
                statusProgress: 'W toku',
                statusReview: 'Weryfikacja',
                statusDone: 'Gotowe',
                hideCompleted: 'Ukryj wykonane',
                coExecutors: 'Współwykonawcy',
                observers: 'Obserwatorzy',
                startDate: 'Data rozpoczęcia',
                requireReview: 'Weryfikacja po wykonaniu',
                allowDeadlineChange: 'Wykonawca może zmieniać terminy',
                checklist: 'Checklist',
                addChecklistItem: 'Dodaj punkt',
                deadlineLocked: 'Zmiana terminów zablokowana przez zleceniodawcę',
                timeTracking: 'Śledzenie czasu',
                planned: 'Planowany',
                actual: 'Rzeczywisty',
                startTimer: 'Start',
                stopTimer: 'Stop',
                addTimeManually: 'Dodaj czas ręcznie',
                
                // Priorities
                priorityLow: 'Niski',
                priorityMedium: 'Średni',
                priorityHigh: 'Wysoki',
                
                // Control
                controlPanel: 'Panel kontroli',
                critical: 'Krytyczne',
                attention: 'Uwaga',
                active: 'Aktywne',
                completed: 'Gotowe',
                workload: 'Obciążenie',
                noActiveTasks: 'Brak aktywnych zadań',
                
                // Regular
                addRegular: '+ Regularne',
                regularTask: 'Zadanie regularne',
                regularTasks: 'Zadania regularne',
                week: 'Tydzień',
                day: 'Dzień',
                month: 'Miesiąc',
                list: 'Lista',
                add: 'Dodaj',
                noTime: 'Bez czasu',
                periodicity: 'Częstotliwość *',
                weekly: 'Co tydzień',
                monthly: 'Co miesiąc',
                quarterly: 'Co kwartał',
                daysOfWeek: 'Dni tygodnia *',
                selectAll: 'Wszystkie dni',
                workDays: 'Pn-Pt',
                clearDays: 'Wyczyść',
                mon: 'Pn',
                tue: 'Wt',
                wed: 'Śr',
                thu: 'Czw',
                fri: 'Pt',
                sat: 'Sob',
                sun: 'Nd',
                dayOfMonth: 'Dzień miesiąca *',
                timeOfDay: 'Czas wykonania *',
                lastDay: 'Ostatni dzień',
                monday: 'Poniedziałek',
                tuesday: 'Wtorek',
                wednesday: 'Środa',
                thursday: 'Czwartek',
                friday: 'Piątek',
                saturday: 'Sobota',
                sunday: 'Niedziela',
                instruction: 'Instrukcja (opcjonalnie)',
                allPeriods: 'Wszystkie okresy',
                assignees: 'Wykonawcy',
                selectFunctionFirst: 'Najpierw wybierz funkcję',
                noMembers: 'Brak uczestników',
                create: 'Utwórz',
                radarAI: 'Kierownik',
                techAI: 'Asystent',
                
                // Functions
                addFunction: '+ Funkcja',
                newFunction: 'Nowa funkcja',
                head: 'Kierownik *',
                members: 'Uczestnicy',
                tasks: 'zadań',
                mergeFunctions: 'Połącz',
                selectFunctionsToMerge: 'Wybierz funkcje do połączenia (2-5):',
                newFunctionName: 'Nazwa połączonej funkcji *',
                merge: 'Połącz',
                willBeMerged: 'Zostanie połączono',
                tasksCount: 'zadań',
                regularTasksCount: 'regularnych',
                assigneesCount: 'wykonawców',
                mergeSuccess: 'Funkcje zostały połączone',
                mergeSelectMinTwo: 'Wybierz minimum 2 funkcje',
                mergeSelectMaxFive: 'Maksimum 5 funkcji',
                mergeEnterName: 'Wprowadź nazwę połączonej funkcji',
                mergedFrom: 'Połączono z',
                
                // Team
                invite: 'Zaproś',
                inviteTitle: 'Zaproszenie',
                employeeEmail: 'Email pracownika *',
                role: 'Rola',
                roleOwner: 'Właściciel',
                roleManager: 'Menedżer',
                roleEmployee: 'Pracownik',
                inviteLinkLabel: 'Link do logowania:',
                copy: 'Kopiuj',
                createInvite: 'Utwórz zaproszenie',
                
                // Admin
                adminPanel: 'Panel admina TALKO',
                createCompany: 'Utwórz nową firmę',
                ownerEmail: 'Email właściciela *',
                passwordLabel: 'Hasło *',
                ownerName: 'Imię właściciela *',
                companyName: 'Nazwa firmy *',
                createCompanyBtn: 'Utwórz firmę i właściciela',
                allCompanies: 'Wszystkie firmy',
                users: 'użytkowników',
                
                // Empty states
                noTasks: 'Brak zadań',
                createFirstTask: 'Utwórz pierwsze zadanie',
                noFunctions: 'Brak funkcji',
                functionAssigneeHint: 'Wykonawcy są pobierani automatycznie z wybranej funkcji. Kto jest w funkcji — ten wykonuje.',
                people: 'osób',
                createFirstFunction: 'Utwórz pierwszą funkcję',
                noRegular: 'Brak zadań regularnych',
                noRegularForDay: 'Na ten dzień brak zadań regularnych',
                todaysTasks: 'Moje na dzisiaj',
                allDays: 'Wszystkie dni',
                createRegular: 'Utwórz zadanie regularne',
                noUsers: 'Brak użytkowników',
                noCompanies: 'Brak firm',
                
                // Other
                support: 'Pomoc',
                aiSupport: 'AI Pomoc',
                footerSupport: '<i data-lucide="life-buoy" class="icon icon-sm"></i> Pomoc',
                notAssigned: 'Nie przypisano',
                deleteConfirm: 'Usunąć?',
                error: 'Błąd',
                created: 'utworzono',
                copied: 'Link skopiowany!',
                
                // New filters & analytics
                clear: 'Wyczyść',
                allTasks: 'Wszystkie zadania',
                myTasks: 'Moje zadania',
                createdByMe: 'Utworzone przeze mnie',
                statuses: 'Statusy',
                functions: 'Funkcje',
                task: 'Zadanie',
                createdBy: 'Utworzył',
                deadline: 'Termin',
                type: 'Typ',
                actions: 'Akcje',
                schedule: 'Harmonogram',
                statusPeriod: 'Status',
                createAgain: 'Utwórz ponownie',
                markDone: 'Oznacz jako wykonane',
                noTasksFound: 'Nie znaleziono zadań',
                changeFilters: 'Zmień filtry lub dodaj nowe zadanie',
                edit: 'Edytuj',
                delete: 'Usuń',
                
                // Control panel
                controlPanelTitle: 'Panel kontroli zadań',
                assigneeLabel: 'Wykonawca:',
                functionLabel: 'Funkcja:',
                periodLabel: 'Okres:',
                allAssignees: 'Wszyscy wykonawcy',
                allTime: 'Cały czas',
                overdueLabel: 'Zaległe',
                todayTomorrow: 'Dzisiaj-jutro',
                inWork: 'W toku',
                completedLabel: 'Zakończone',
                viewLabel: 'Widok:',
                employeeWorkload: 'Obciążenie pracowników',
                byFunctions: 'Wg funkcji',
                
                // Processes
                tabProcesses: 'Procesy',
                processes: 'Procesy biznesowe',
                allProcesses: 'Wszystkie procesy',
                showCompleted: 'Archiwum',
                templates: 'Szablony',
                startProcess: 'Uruchom',
                aiAssistant: 'AI-asystent',
                processTemplates: 'Szablony procesów',
                newTemplate: 'Nowy szablon',
                templateName: 'Nazwa szablonu *',
                templateDescription: 'Opis',
                processSteps: 'Etapy procesu',
                addStep: 'Dodaj etap',
                selectTemplate: 'Wybierz szablon *',
                processName: 'Nazwa procesu *',
                processFlow: 'Kolejność',
                start: 'Uruchom',
                noProcesses: 'Brak aktywnych procesów',
                createProcessTemplate: 'Utwórz szablon procesu i uruchom pierwszy proces',
                createTemplate: 'Utwórz szablon',
                editTemplate: 'Edytuj szablon',
                deleteTemplate: 'Usuń szablon',
                stepFunction: 'Funkcja etapu',
                stepTitle: 'Nazwa etapu',
                stepResult: 'Oczekiwany rezultat',
                completeStep: 'Zakończ etap',
                processHistory: 'Historia procesu',
                currentStep: 'Bieżący etap',
                noTemplates: 'Brak szablonów procesów',
                createFirstTemplate: 'Utwórz pierwszy szablon',
                activeProcesses: 'aktywnych',
                templateSaved: 'Szablon zapisany',
                processStarted: 'Proces uruchomiony',
                stepCompleted: 'Etap zakończony',
                
                // Analytics
                tabAnalytics: 'Analityka',
                analytics: 'Analityka',
                totalTasks: 'Razem zadań',
                completedTasks: 'Wykonano',
                completionRate: 'Wykonanie %',
                avgTime: 'Śr. czas',
                byStatus: 'Wg statusów',
                topPerformers: 'Top wykonawców',
                noCompletedTasks: 'Brak wykonanych zadań',
                
                // Users
                tabUsers: 'Pracownicy',
                addEmployee: '+ Dodaj pracownika',
                editEmployee: 'Edytuj pracownika',
                name: 'Imię *',
                position: 'Stanowisko',
                userFunctions: 'Funkcje pracownika',
                inviteFirst: 'Zaproś pierwszego pracownika',
                noEmployees: 'Brak pracowników',
                
                // Regular
                addRegularTask: '+ Zadanie regularne',
                
                // Mobile menu
                menu: 'Menu',
                aiAssistants: 'Asystenci AI',
                aiManager: 'Kierownik',
                aiTechnical: 'Techniczny',
                profile: 'Profil',
                enableNotifications: 'Włącz powiadomienia',
                disableNotifications: 'Wyłącz powiadomienia',
                loadDemoData: 'Załaduj dane demo',
                
                // Review
                taskSentForReview: 'Wysłano do weryfikacji',
                taskOnReview: 'Zadanie w weryfikacji',
                acceptTask: 'Akceptuj',
                rejectTask: 'Do poprawy',
                taskAccepted: 'Zadanie zaakceptowane',
                taskRejected: 'Zwrócono do poprawy',
                reviewByCreator: 'Oczekuje weryfikacji zleceniodawcy',
                rejectReasonPlaceholder: 'Powód zwrotu (opcjonalnie)',

                // Dynamic strings
                inviteNotFound: 'Zaproszenie nie znalezione lub przeterminowane',
                enterEmail: 'Wprowadź email',
                passwordMinLength: 'Hasło musi mieć minimum 6 znaków',
                passwordsMismatch: 'Hasła nie pasują',
                registering: 'Rejestracja...',
                emailMismatchInvite: 'Email nie pasuje do zaproszenia',
                registerSuccess: 'Zarejestrowano pomyślnie!',
                registerError: 'Błąd rejestracji',
                emailAlreadyRegistered: 'Ten email jest już zarejestrowany. Spróbuj się zalogować.',
                invalidEmail: 'Nieprawidłowy format email',
                weakPassword: 'Zbyt proste hasło',
                enterEmailAndPassword: 'Wprowadź email i hasło',
                loginError: 'Błąd logowania',
                userNotFound: 'Nie znaleziono użytkownika',
                wrongPassword: 'Nieprawidłowe hasło',
                invalidCredentials: 'Nieprawidłowy email lub hasło',
                enterEmailForReset: 'Wprowadź email do odzyskania hasła',
                resetLinkSentTo: 'Link wysłany na ',
                adminRole: '(Administrator)',
                inviteAlreadyUsed: 'To zaproszenie zostało już wykorzystane. Zaloguj się emailem i hasłem.',
                inviteNotFoundEmail: 'Zaproszenie nie znalezione. Wprowadź email, na który otrzymałeś zaproszenie.',
                employeeRole: 'Pracownik',
                taskCompleted: 'Zadanie wykonane!',
                fromProcess: 'Z procesu biznesowego',
                regularTaskLabel: 'Zadanie regularne',
                newTaskLabel: 'Nowe zadanie',
                restoreFromArchive: 'Przywrócić zadanie z archiwum?',
                taskRestored: 'Zadanie przywrócone',
                overdueStatus: 'Zaległe',
                moreItems: 'więcej',
                forToday: 'Na dzisiaj',
                newFromProcesses: 'Nowe z procesów',
                greeting: 'Cześć',
                yourTasksToday: 'Twoje zadania na dzisiaj',
                startWork: 'Rozpocznij pracę',
                viewTask: 'Podgląd zadania',
                tooManyRequests: 'Za dużo żądań. Poczekaj minutę.',
                howManyMinutes: 'Ile minut poświęcono?',
                checklistItemPlaceholder: 'Punkt checklisty...',
                noTasksLabel: 'Brak zadań',
                awaitingReview: 'Oczekuje weryfikacji zleceniodawcy',
                noTimeLabel: 'Bez czasu',
                overdueLabel2: 'Zaległe',
                todayLabel: 'Dzisiaj',
                tomorrowLabel: 'Jutro',
                thisWeekLabel: 'Ten tydzień',
                laterLabel: 'Później',
                noDateLabel: 'Bez daty',
                reviewLabel: 'Weryfikacja',
                showMore: 'Pokaż więcej',
                deleteProcess: 'Usuń proces',
                minTwoSteps: 'Dodaj minimum 2 etapy',
                deleteTemplateConfirm: 'Usunąć szablon? Aktywne procesy pozostaną.',
                templateDeleted: 'Szablon procesu został usunięty',
                templateNotFound: 'Szablon procesu nie znaleziony',
                onlyFunctionMembers: 'Tylko członkowie funkcji mogą zakończyć ten etap',
                systemUser: 'System',
                selectAssigneeOrFunction: 'Wybierz wykonawcę lub funkcję z wykonawcami',
                selectAtLeastOneDay: 'Wybierz przynajmniej jeden dzień tygodnia',
                noExecutorsInFunction: 'W funkcji nie ma wykonawców',
                createdLabel: 'Utworzono',
                tasksWord: 'zadań',
                daily: 'Codziennie',
                monFri: 'Pn-Pt',
                instructionLabel: 'Instrukcja',
                completedStatus: 'Wykonano',
                inProgressStatus: 'W toku',
                pendingStatus: 'Oczekuje',
                monthlyTasks: 'Zadania miesięczne',
                lastDayLabel: 'Ostatni dzień',
                dayOfMonthLabel: '-go dnia',
                quarterlyTasks: 'Zadania kwartalne',
                oncePerQuarter: 'Raz na kwartał',
                companyDeleted: 'Firma usunięta',
                deleteError: 'Błąd usuwania: ',
                creating: 'Tworzenie...',
                viewBtn: 'Podgląd',
                editBtn: 'Edytuj',
                demoDataLoaded: 'Dane demo załadowane pomyślnie!',
                loadError: 'Błąd ładowania: ',
                noTasksToday: 'Brak zadań na dzisiaj!',
                hourShort: ' godz ',
                minShort: ' min',
                taskFromProcess: 'Zadanie z procesu',
                noTasksForToday: 'Na dzisiaj brak zadań',
                timeToRest: 'Czas na odpoczynek lub nowe zadania',
                allTasksDone: 'Wszystkie zadania wykonane!',
                greatJob: 'Świetna robota! Czas na przerwę.',
                doneToday: 'Wykonano dzisiaj',
                toDo: 'Do wykonania',
                onReview: 'W weryfikacji',
                regularType: 'regularne',
                oneTimeType: 'jednorazowe',
                daySun: 'Nd',
                dayMon: 'Pn',
                dayTue: 'Wt',
                dayWed: 'Śr',
                dayThu: 'Czw',
                dayFri: 'Pt',
                daySat: 'Sob',
                statusesLabel: 'Statusy',
                deleteConfirmProcess: 'Usunąć ten proces?',
                stepSkipConfirm: 'Pominąć ten etap?',
                processStepTaskCreated: 'Automatycznie utworzono zadanie dla następnego etapu',

                deleteProcessConfirm: 'Usunąć ten proces?',
                systemAuto: 'Automatycznie',
                cannotDeleteOwner: 'Nie można usunąć właściciela',
                noAssigneesInFunc: 'W funkcji nie ma wykonawców',
                loadDemoConfirm: 'Załadować dane demo? Istniejące dane nie zostaną usunięte.',

                taskLimitWarning: 'Załadowano {n} zadań. Starsze zadania są ukryte. Zalecamy archiwizację wykonanych.',
                restorePartial: 'Przywrócono {ok} z {total}. {fail} nie udało się przywrócić.',
                restoreSuccess: 'Przywrócono {n} element(ów)',
                rejectedTaskMsg: 'zwrócił zadanie',

                functionsNotFound: 'Nie znaleziono funkcji',
                functionNotExists: 'Funkcja "{name}" nie istnieje. Zaktualizuj szablon.',
                functionNoExecutors: 'Funkcja "{name}" nie ma wykonawców. Dodaj wykonawców przed uruchomieniem.',
                skipStepConfirm: 'Istnieje niedokończone zadanie "{title}" dla tego kroku. Czy na pewno przejść dalej?',
                functionNoExecutorsWarning: 'Uwaga: funkcja "{name}" nie ma wykonawców. Zadanie nie zostało utworzone.',
                inviteCreated: 'Zaproszenie utworzone!\n\nWyślij link pracownikowi.',
                deleteCompanyConfirm: 'Usunąć firmę "{name}"?\n\nZostanie usunięte:\n• {users} użytkowników\n• {tasks} zadań\n• Wszystkie funkcje i zadania regularne\n\nTej akcji nie można cofnąć!',
                deleteCompanyConfirm2: 'Na pewno usunąć "{name}"? Wpisz "tak" aby potwierdzić:',
                companyCreated: 'Firma "{name}" utworzona!\n\nEmail: {email}\nHasło: {password}\n\nWyślij klientowi:\n1. Link: taskmanagerai-vert.vercel.app\n2. Email i hasło\n3. Instrukcja: "Aktywuj dostęp" → wprowadź dane',
                createCompanyFirst: 'Najpierw utwórz firmę w panelu admina, potem załaduj dane demo.',

                projectActive: 'Aktywny',
                projectCompleted: 'Zakończony',
                projectPaused: 'Pauza',

                functionNameRequired: 'Nazwa funkcji jest wymagana',
                functionNameTooLong: 'Nazwa za długa (maks. 200 znaków)',
                functionNameDuplicate: 'Funkcja o takiej nazwie już istnieje',
                functionHeadRequired: 'Kierownik jest wymagany',
                logoutConfirm: 'Wylogować się?',
                reopen: 'Przywróć',
                completeTask: 'Zakończ',
                taskReopened: 'Zadanie przywrócone do pracy',
                newProject: 'Nowy projekt',

                signInFirst: 'Najpierw zaloguj się',
                fillAllFields: 'Wypełnij wszystkie pola',
                createError: 'Błąd tworzenia',
                taskNotFoundArchive: 'Zadanie nie znalezione w archiwum',
                restoreError: 'Błąd przywracania',
                deadlineExceedsProject: '⚠️ Termin zadania ({taskDate}) wykracza poza termin projektu "{projName}" ({projDate})',
                noTasksForExport: 'Brak zadań do eksportu',
                deadlineUpdated: 'Termin zaktualizowany',
                taskModifiedByOther: 'To zadanie zostało zmienione przez innego użytkownika. Zapisać zmiany?',
                taskCompleted: 'Zadanie wykonane',
                taskReturnedForRevision: 'Zwrócone do poprawki',
                taskForReview: 'Zadanie do weryfikacji',
                processAdvancedShort: 'Proces przesunięty',
                processCompletedShort: 'Proces zakończony',
                newTask: 'Nowe zadanie',
                regularTaskLabel: 'Zadanie regularne',
                processTask: 'Zadanie z procesu',
                fromFunctionAuto: 'Z funkcji (auto)',
                deleteProjectWithTasks: 'Usunąć projekt? {total} zadań ({undone} niezakończonych) pozostanie na liście.',
                deleteEmptyProject: 'Usunąć pusty projekt?',
                tasksUnlinked: '{n} zadań odłączono od projektu',
                projectStatusChanged: 'Projekt "{name}" → {status}',
                confirmProjectComplete: 'W projekcie jest {n} niezakończonych zadań. Oznaczyć jako "Zakończone"?',
                processAdvanced: 'Proces "{name}" → krok {step}/{total}: {stepName}',
                processNoExecutors: 'Funkcja "{func}" bez wykonawców — zadanie nie utworzone',
                processCompleted: 'Proces "{name}" zakończony!',
                confirmCompanyAction: '{action} tę firmę?',
                companyBlocked: 'Firma zablokowana',
                companyUnblocked: 'Firma odblokowana',
                browserNoNotifications: 'Twoja przeglądarka nie obsługuje powiadomień',
                notificationsDenied: 'Brak zgody na powiadomienia. Sprawdź ustawienia przeglądarki.',
                googleApiNotLoaded: 'Google API nie załadowane. Spróbuj odświeżyć stronę.',
                googleAuthError: 'Błąd autoryzacji Google',
                googleCalendarConnected: 'Google Calendar pomyślnie podłączony!',
                saveError: 'Błąd zapisu',
                disconnectGoogleCalendar: 'Odłączyć Google Calendar? Synchronizacja zadań zostanie wstrzymana.',
                googleCalendarDisconnected: 'Google Calendar odłączony',
                notAuthorized: 'Błąd: nie autoryzowano',
                disconnectTelegram: 'Odłączyć Telegram? Przestaniesz otrzymywać powiadomienia.',
                telegramDisconnected: 'Telegram odłączony',
                superAdminOnly: 'Dostępne tylko dla SuperAdmin',
                textMismatch: 'Tekst nie pasuje. Anulowano.',
                deletingData: 'Usuwanie danych...',
                deletedNRecords: 'Usunięto {n} rekordów',
                commentSendError: 'Błąd wysyłania komentarza',
                escalationCritical: '🚨 KRYTYCZNIE: {n} zadań przeterminowanych 7+ dni!',
                escalationWarning: '⚠️ {n} zadań przeterminowanych 3+ dni',
                noPermissionTask: 'Brak uprawnień do zmiany tego zadania',
                deadlineChangeError: 'Błąd zmiany terminu',
                deleteFileConfirm: 'Usunąć plik?',
                fileDeleted: 'Plik usunięty',
                fileDeleteError: 'Błąd usuwania pliku',
                saveTaskBeforeFiles: 'Zapisz zadanie przed dodaniem plików',
                fileTooBig: 'Plik "{name}" przekracza 10 MB',
                fileTypeNotSupported: 'Typ pliku .{ext} nie jest obsługiwany',
                filesUploaded: 'Przesłano {n} plik(ów)',
                fileUploadError: 'Błąd przesyłania pliku',
                sentForReview: 'Wysłano do weryfikacji',
                editProject: 'Edytuj projekt',
            },
        };

        let currentLang = localStorage.getItem('talko_lang') || 'ua';

        // Ініціалізуємо переклади при завантаженні сторінки
        document.addEventListener('DOMContentLoaded', () => {
            // Оновлюємо кнопки мови
            document.getElementById('langUA')?.classList.toggle('active', currentLang === 'ua');
            document.getElementById('langRU')?.classList.toggle('active', currentLang === 'ru');
            document.getElementById('langPL')?.classList.toggle('active', currentLang === 'pl');
            document.getElementById('mLangUA')?.classList.toggle('active', currentLang === 'ua');
            document.getElementById('mLangRU')?.classList.toggle('active', currentLang === 'ru');
            document.getElementById('mLangPL')?.classList.toggle('active', currentLang === 'pl');
            
            // Оновлюємо всі тексти з data-i18n
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (translations[currentLang] && translations[currentLang][key]) {
                    if (el.tagName === 'INPUT' && el.type !== 'text' && el.type !== 'email') {
                        el.value = translations[currentLang][key];
                    } else {
                        el.innerHTML = translations[currentLang][key];
                    }
                }
            });
        });

        function t(key) {
            return translations[currentLang][key] || translations['ua'][key] || key;
        }

        
        function getLocale() {
            const locales = { ua: 'uk-UA', ru: 'ru-RU', pl: 'pl-PL' };
            return locales[currentLang] || 'uk-UA';
        }
        
        function getMonthNames() {
            const months = {
                ua: ['Січ', 'Лют', 'Бер', 'Кві', 'Тра', 'Чер', 'Лип', 'Сер', 'Вер', 'Жов', 'Лис', 'Гру'],
                ru: ['Янв', 'Фев', 'Мар', 'Апр', 'Май', 'Июн', 'Июл', 'Авг', 'Сен', 'Окт', 'Ноя', 'Дек'],
                pl: ['Sty', 'Lut', 'Mar', 'Kwi', 'Maj', 'Cze', 'Lip', 'Sie', 'Wrz', 'Paź', 'Lis', 'Gru']
            };
            return months[currentLang] || months['ua'];
        }
        function setLanguage(lang) {
            currentLang = lang;
            localStorage.setItem('talko_lang', lang);
            
            // Оновлюємо масиви днів і місяців
            dayNames = getDayNames();
            dayNamesShort = getDayNamesShort();
            monthNames = getMonthNames();
            
            // Update desktop buttons
            document.getElementById('langUA')?.classList.toggle('active', lang === 'ua');
            document.getElementById('langRU')?.classList.toggle('active', lang === 'ru');
            
            // Update mobile buttons
            document.getElementById('mLangUA')?.classList.toggle('active', lang === 'ua');
            document.getElementById('mLangRU')?.classList.toggle('active', lang === 'ru');
            
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (translations[lang] && translations[lang][key]) {
                    if (el.tagName === 'INPUT' && el.type !== 'text' && el.type !== 'email') {
                        el.value = translations[lang][key];
                    } else {
                        el.innerHTML = translations[lang][key];
                    }
                }
            });
            
            // Refresh lucide icons after i18n innerHTML updates
            refreshIcons();
            if (currentCompany || isSuperAdmin) {
                // Find active tab from either desktop tabs or bottom nav
                let tabName = 'tasks';
                const activeBottomBtn = document.querySelector('.bottom-nav-btn.active');
                const activeTabBtn = document.querySelector('.tab-btn.active');
                
                if (activeBottomBtn && activeBottomBtn.dataset.tab) {
                    tabName = activeBottomBtn.dataset.tab;
                } else if (activeTabBtn) {
                    const match = activeTabBtn.getAttribute('onclick')?.match(/switchTab\('(\w+)'\)/);
                    if (match) tabName = match[1];
                }
                
                switchTab(tabName);
            }
        }

        // =====================
        // FIREBASE CONFIG
        // =====================
        const firebaseConfig = {
            apiKey: "AIzaSyD1oBJuuFiVVo4HHjjeb81IhGEt1oz4Ydc",
            authDomain: "task-manager-44e84.firebaseapp.com",
            projectId: "task-manager-44e84",
            storageBucket: "task-manager-44e84.firebasestorage.app",
            messagingSenderId: "181519398491",
            appId: "1:181519398491:web:baa17a9a88f637ee94717e"
        };

        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
        const storage = firebase.storage();
        const googleProvider = new firebase.auth.GoogleAuthProvider();

        // =====================
        // APP STATE
        // =====================
        const SUPERADMIN_EMAIL = 'management.talco@gmail.com';
        let currentUser = null;
        let currentCompany = null;
        let currentUserData = null;
        let isSuperAdmin = false;
        let tasks = [];
        let users = [];
        let functions = [];
        let regularTasks = [];
        let projects = [];
        let editingId = null;
        
        // Race condition protection
        let isLoading = false;
        let isSaving = false;
        let loadingVersion = 0; // Tracks which load operation is current
        
        // Debounce utility
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        // Debounced render functions for performance
        const debouncedRenderMyDay = debounce(() => renderMyDay(), 100);
        const debouncedRenderTasks = debounce(() => renderTasks(), 100);
        const debouncedRenderCalendar = debounce(() => renderCalendar(), 100);
        
        // ═══ COALESCED RENDER — batches all render calls into single RAF ═══
        let _coalescePending = false;
        let _coalesceMyDay = false;
        let _coalesceView = false;
        
        function scheduleRender(myDay = true, view = true) {
            if (myDay) _coalesceMyDay = true;
            if (view) _coalesceView = true;
            if (_coalescePending) return;
            _coalescePending = true;
            requestAnimationFrame(() => {
                _coalescePending = false;
                if (_coalesceMyDay) { _coalesceMyDay = false; renderMyDay(); }
                if (_coalesceView) { _coalesceView = false; refreshCurrentView(); }
            });
        }
        
        // =====================
        // GOOGLE CALENDAR CONFIG
        // =====================
        const GOOGLE_CLIENT_ID = '373376418182-1bc6pfp3qo54n2rt8l0sqjtqaqj6ari3.apps.googleusercontent.com';
        const GOOGLE_SCOPES = 'https://www.googleapis.com/auth/calendar.events https://www.googleapis.com/auth/userinfo.email';
        let googleAccessToken = null;
        let tokenClient = null;

        // =====================
        // AUTH FUNCTIONS
        // =====================
        function showAuthMessage(msg, type = 'info') {
            const el = document.getElementById('authMessage');
            el.textContent = msg;
            el.className = 'auth-message ' + type;
            el.style.display = 'block';
        }

        function hideAuthMessage() {
            document.getElementById('authMessage').style.display = 'none';
        }

        function togglePassword(inputId, btn) {
            const input = document.getElementById(inputId);
            if (input.type === 'password') {
                input.type = 'text';
                btn.innerHTML = '<i data-lucide="eye-off" class="icon icon-sm"></i>';
            } else {
                input.type = 'password';
                btn.innerHTML = '<i data-lucide="eye" class="icon icon-sm"></i>';
            }
            refreshIcons();
        }

        async function selfRegisterCompany() {
            const user = auth.currentUser;
            if (!user) { alert(t('signInFirst')); return; }
            
            const companyName = document.getElementById('selfRegCompanyName')?.value?.trim();
            const ownerName = document.getElementById('selfRegOwnerName')?.value?.trim();
            
            if (!companyName || !ownerName) {
                alert(t('fillAllFields'));
                return;
            }
            
            const btn = document.getElementById('selfRegBtn');
            if (btn) { btn.disabled = true; btn.textContent = 'Створення...'; }
            
            try {
                const companyId = companyName.toLowerCase().replace(/[^a-zа-яіїєґ0-9]/g, '_').substring(0, 30) + '_' + Date.now().toString(36);
                
                const batch = db.batch();
                
                // 1. Company doc
                batch.set(db.collection('companies').doc(companyId), {
                    name: companyName,
                    ownerName: ownerName,
                    ownerEmail: user.email.toLowerCase(),
                    ownerId: user.uid,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    disabled: false
                });
                
                // 2. User in company
                batch.set(db.collection('companies').doc(companyId).collection('users').doc(user.uid), {
                    name: ownerName,
                    email: user.email.toLowerCase(),
                    role: 'owner',
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // 3. Global user mapping
                batch.set(db.collection('users').doc(user.uid), {
                    email: user.email.toLowerCase(),
                    companyId: companyId,
                    role: 'owner'
                });
                
                await batch.commit();
                
                // Reload — onAuthStateChanged знайде companyId і зайде
                window.location.reload();
                
            } catch (error) {
                console.error('Self registration error:', error);
                alert(t('createError') + ': ' + error.message);
                if (btn) { btn.disabled = false; btn.innerHTML = '<i data-lucide="rocket" class="icon"></i> Створити компанію'; }
            }
        }
        
        function showNoAccess() {
            document.getElementById('loginForm').style.display = 'none';
            document.getElementById('registerForm').style.display = 'none';
            document.getElementById('noAccessCard').style.display = 'block';
        }

        let currentInviteData = null; // Дані поточного інвайту з URL
        
        // Перевірка інвайту в URL
        async function checkInviteUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            const inviteId = urlParams.get('invite');
            
            if (!inviteId) {
                currentInviteData = null;
                return false;
            }
            
            try {
                const inviteDoc = await db.collection('invites').doc(inviteId).get();
                
                if (!inviteDoc.exists) {
                    showAuthMessage(t('inviteNotFound'), 'error');
                    currentInviteData = null;
                    return false;
                }
                
                const invite = inviteDoc.data();
                
                if (invite.accepted) {
                    currentInviteData = null;
                    // Не показуємо помилку тут - покажемо форму входу з підказкою
                    return 'already_used';
                }
                
                currentInviteData = { id: inviteId, ...invite };
                return true;
            } catch (e) {
                console.error('Error checking invite:', e);
                currentInviteData = null;
                return false;
            }
        }
        
        function showLoginForm() {
            document.getElementById('loginForm').style.display = 'block';
            document.getElementById('registerForm').style.display = 'none';
            document.getElementById('noAccessCard').style.display = 'none';
            hideAuthMessage();
            
            // Скидаємо поля реєстрації
            const emailField = document.getElementById('registerEmail');
            emailField.value = '';
            emailField.readOnly = false;
            emailField.style.background = '';
            document.getElementById('registerPassword').value = '';
            document.getElementById('registerPasswordConfirm').value = '';
        }
        
        function toggleAuthHelp() {
            const content = document.getElementById('authHelpContent');
            const arrow = document.getElementById('authHelpArrow');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                arrow.style.transform = 'rotate(180deg)';
            } else {
                content.style.display = 'none';
                arrow.style.transform = 'rotate(0deg)';
            }
        }
        
        function showRegisterForm() {
            document.getElementById('loginForm').style.display = 'none';
            document.getElementById('registerForm').style.display = 'block';
            document.getElementById('noAccessCard').style.display = 'none';
            hideAuthMessage();
            
            // Скидаємо поля входу
            document.getElementById('loginEmail').value = '';
            document.getElementById('loginPassword').value = '';
            
            const emailField = document.getElementById('registerEmail');
            
            // Якщо є інвайт в URL — автозаповнюємо email
            if (currentInviteData && currentInviteData.email) {
                emailField.value = currentInviteData.email;
                emailField.readOnly = true;
                emailField.style.background = '#f0f0f0';
            } else {
                emailField.value = '';
                emailField.readOnly = false;
                emailField.style.background = '';
            }
        }
        
        // Реєстрація за запрошенням
        async function registerWithInvite() {
            const email = document.getElementById('registerEmail').value.trim().toLowerCase();
            const password = document.getElementById('registerPassword').value;
            const passwordConfirm = document.getElementById('registerPasswordConfirm').value;
            
            // Валідація
            if (!email) {
                showAuthMessage(t('enterEmail'), 'error');
                return;
            }
            
            if (!password || password.length < 6) {
                showAuthMessage(t('passwordMinLength'), 'error');
                return;
            }
            
            if (password !== passwordConfirm) {
                showAuthMessage(t('passwordsMismatch'), 'error');
                return;
            }
            
            try {
                showAuthMessage(t('registering'), 'info');
                
                // КРОК 1: Спочатку створюємо Auth акаунт
                // (потрібен для доступу до Firestore — invites вимагають авторизацію)
                console.log('[Register] Creating auth account for:', email);
                const userCredential = await auth.createUserWithEmailAndPassword(email, password);
                const user = userCredential.user;
                console.log('[Register] Auth account created, UID:', user.uid);
                
                // КРОК 2: Тепер авторизовані — шукаємо invite
                // (onAuthStateChanged спрацює автоматично і викличе findUserCompany,
                //  який знайде invite і прив'яже юзера до компанії)
                
                // Якщо є currentInviteData з URL — перевіряємо відповідність
                if (currentInviteData && currentInviteData.email.toLowerCase() !== email.toLowerCase()) {
                    showAuthMessage(t('emailMismatchInvite'), 'error');
                    return;
                }
                
                // Очищаємо URL від параметра invite
                window.history.replaceState({}, document.title, window.location.pathname);
                currentInviteData = null;
                
                console.log('[Register] Success! Waiting for onAuthStateChanged...');
                showAuthMessage(t('registerSuccess'), 'success');
                
            } catch (e) {
                console.error('[Register] Error:', e.code, e.message);
                let msg = t('registerError');
                if (e.code === 'auth/email-already-in-use') {
                    msg = t('emailAlreadyRegistered');
                }
                if (e.code === 'auth/invalid-email') {
                    msg = t('invalidEmail');
                }
                if (e.code === 'auth/weak-password') {
                    msg = t('weakPassword');
                }
                showAuthMessage(msg, 'error');
            }
        }

        // Google Sign-In
        async function signInWithGoogle() {
            try {
                // На мобільних використовуємо redirect замість popup
                const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                if (isMobile) {
                    await auth.signInWithRedirect(googleProvider);
                } else {
                    await auth.signInWithPopup(googleProvider);
                }
            } catch (e) {
                showAuthMessage(t('error') + ': ' + e.message, 'error');
            }
        }
        
        // Обробка результату redirect
        auth.getRedirectResult().then((result) => {
            if (result.user) {
                // Користувач увійшов через redirect
                console.log('Redirect login success');
            }
        }).catch((e) => {
            if (e.code) {
                showAuthMessage(t('error') + ': ' + e.message, 'error');
            }
        });

        // Email + Password Sign In
        async function signInWithEmail() {
            const email = document.getElementById('loginEmail').value.trim();
            const password = document.getElementById('loginPassword').value;
            
            if (!email || !password) {
                showAuthMessage(t('enterEmailAndPassword'), 'error');
                return;
            }
            
            try {
                await auth.signInWithEmailAndPassword(email, password);
            } catch (e) {
                let msg = t('loginError');
                if (e.code === 'auth/user-not-found') msg = t('userNotFound');
                if (e.code === 'auth/wrong-password') msg = t('wrongPassword');
                if (e.code === 'auth/invalid-email') msg = t('invalidEmail');
                if (e.code === 'auth/invalid-credential') msg = t('invalidCredentials');
                showAuthMessage(msg, 'error');
            }
        }

        // Password Reset
        async function resetPassword() {
            const email = document.getElementById('loginEmail').value.trim();
            if (!email) {
                showAuthMessage(t('enterEmailForReset'), 'error');
                return;
            }
            
            try {
                await auth.sendPasswordResetEmail(email);
                showAuthMessage(t('resetLinkSentTo') + email, 'success');
            } catch (e) {
                showAuthMessage(t('error') + ': ' + e.message, 'error');
            }
        }

        async function findUserCompany(userId, email) {
            try {
                const userDoc = await db.collection('users').doc(userId).get();
                if (userDoc.exists) {
                    return userDoc.data().companyId;
                }
                
                const invitesQuery = await db.collection('invites')
                    .where('email', '==', email.toLowerCase())
                    .where('accepted', '==', false)
                    .limit(1)
                    .get();
                
                if (!invitesQuery.empty) {
                    const invite = invitesQuery.docs[0];
                    const inviteData = invite.data();
                    const companyId = inviteData.companyId;
                    const isOwnerInvite = inviteData.role === 'owner';
                    
                    // Batch write — все або нічого (атомарно)
                    const batch = db.batch();
                    
                    // 1. Додаємо юзера в компанію
                    const companyUserRef = db.collection('companies').doc(companyId).collection('users').doc(userId);
                    batch.set(companyUserRef, {
                        name: inviteData.ownerName || inviteData.name || email.split('@')[0],
                        email: email.toLowerCase(),
                        role: inviteData.role || 'employee',
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    
                    // 2. Глобальний маппінг userId → companyId
                    const globalUserRef = db.collection('users').doc(userId);
                    batch.set(globalUserRef, {
                        email: email.toLowerCase(),
                        companyId: companyId,
                        role: inviteData.role || 'employee'
                    });
                    
                    // 3. Якщо Owner — оновлюємо компанію
                    if (isOwnerInvite) {
                        const companyRef = db.collection('companies').doc(companyId);
                        batch.update(companyRef, { ownerId: userId });
                    }
                    
                    // 4. Позначаємо invite як використаний
                    batch.update(invite.ref, { 
                        accepted: true, 
                        acceptedAt: firebase.firestore.FieldValue.serverTimestamp(),
                        acceptedBy: userId
                    });
                    
                    // Один запит — все атомарно
                    await batch.commit();
                    console.log('[findUserCompany] Batch commit success, role:', inviteData.role);
                    
                    return companyId;
                }
                
                return null;
            } catch (error) {
                console.error('[findUserCompany] Error:', error);
                return null;
            }
        }

        // Централізована очистка всіх listeners та intervals
        function cleanupAllListeners() {
            if (tasksUnsubscribe) {
                tasksUnsubscribe();
                tasksUnsubscribe = null;
            }
            if (completedTasksUnsubscribe) {
                completedTasksUnsubscribe();
                completedTasksUnsubscribe = null;
            }
            if (reviewTasksUnsubscribe) {
                reviewTasksUnsubscribe();
                reviewTasksUnsubscribe = null;
            }
            if (rejectedTasksUnsubscribe) {
                rejectedTasksUnsubscribe();
                rejectedTasksUnsubscribe = null;
            }
            try {
                if (commentsUnsubscribe) {
                    commentsUnsubscribe();
                    commentsUnsubscribe = null;
                }
            } catch(e) {}
            if (timeTrackerInterval) {
                clearInterval(timeTrackerInterval);
                timeTrackerInterval = null;
                timeTrackerStart = null;
            }
            if (typeof notificationCheckInterval !== 'undefined' && notificationCheckInterval) {
                clearInterval(notificationCheckInterval);
                notificationCheckInterval = null;
            }
            if (typeof infiniteScrollObserver !== 'undefined' && infiniteScrollObserver) {
                infiniteScrollObserver.disconnect();
                infiniteScrollObserver = null;
            }
            // Clear page title interval
            if (typeof _pageTitleInterval !== 'undefined' && _pageTitleInterval) {
                clearInterval(_pageTitleInterval);
                _pageTitleInterval = null;
            }
            // Clear undo timers
            if (typeof undoTimerInterval !== 'undefined' && undoTimerInterval) {
                clearInterval(undoTimerInterval);
                undoTimerInterval = null;
            }
            if (typeof undoTimeout !== 'undefined' && undoTimeout) {
                clearTimeout(undoTimeout);
                undoTimeout = null;
            }
        }
        
        function logout() {
            cleanupAllListeners();
            
            // Очищаємо стан
            currentCompany = null;
            currentUserData = null;
            tasks = [];
            regularTasks = [];
            functions = [];
            users = [];
            processes = [];
            processTemplates = [];
            projects = [];
            openProjectId = null;
            
            auth.signOut().then(() => {
                showLoginForm();
                hideAuthMessage();
            });
        }

        // =====================
        // AUTH STATE LISTENER
        // =====================
        auth.onAuthStateChanged(async (user) => {
            if (user) {
                currentUser = user;
                isSuperAdmin = user.email.toLowerCase() === SUPERADMIN_EMAIL.toLowerCase();
                
                // Очищаємо попередні listeners перед ініціалізацією нової сесії
                cleanupAllListeners();
                
                if (isSuperAdmin) {
                    document.getElementById('adminTabBtn').style.display = 'block';
                }
                
                const companyId = await findUserCompany(user.uid, user.email);
                
                if (!companyId && !isSuperAdmin) {
                    document.getElementById('loadingPage').style.display = 'none';
                    document.getElementById('authPage').style.display = 'flex';
                    document.getElementById('mainInterface').style.display = 'none';
                    showNoAccess();
                    return;
                }
                
                if (!companyId && isSuperAdmin) {
                    currentCompany = null;
                    currentUserData = { id: user.uid, email: user.email, role: 'superadmin', name: 'Super Admin' };
                    document.getElementById('currentUserName').textContent = 'Super Admin';
                    document.getElementById('currentUserRole').textContent = t('adminRole');
                    document.getElementById('companyBadge').textContent = 'TALKO System';
                    document.getElementById('companyBadge').style.display = 'inline';
                    showMainInterface();
                    return;
                }
                
                currentCompany = companyId;
                
                const userDoc = await db.collection('companies').doc(companyId).collection('users').doc(user.uid).get();
                currentUserData = userDoc.exists ? { id: user.uid, ...userDoc.data() } : { id: user.uid, email: user.email, role: 'employee' };
                
                const companyDoc = await db.collection('companies').doc(companyId).get();
                const companyData = companyDoc.data();
                
                // Перевірка чи компанія заблокована
                if (companyData?.disabled && !isSuperAdmin) {
                    document.getElementById('authPage').style.display = 'flex';
                    document.getElementById('mainInterface').style.display = 'none';
                    const authErr = document.getElementById('authError') || document.createElement('p');
                    authErr.id = 'authError';
                    authErr.style.cssText = 'color:#dc2626;text-align:center;padding:1rem;font-weight:600;';
                    authErr.textContent = 'Доступ до цієї компанії заблоковано. Зверніться до адміністратора.';
                    const authBox = document.querySelector('.auth-box');
                    if (authBox && !document.getElementById('authError')) authBox.appendChild(authErr);
                    await auth.signOut();
                    return;
                }
                
                document.getElementById('currentUserName').textContent = currentUserData.name || user.displayName || user.email;
                document.getElementById('currentUserRole').textContent = `(${getRoleText(currentUserData.role)})`;
                document.getElementById('companyBadge').textContent = companyData?.name || '';
                document.getElementById('companyBadge').style.display = 'inline';
                
                if (currentUserData.role === 'employee') {
                    document.getElementById('inviteBtn').style.display = 'none';
                    document.getElementById('demoDataBtn').style.display = 'none';
                    // Ховаємо адмін-вкладки для співробітників
                    document.querySelectorAll('.tab-btn').forEach(btn => {
                        const tab = btn.getAttribute('onclick')?.match(/switchTab\('(\w+)'\)/)?.[1];
                        if (['users', 'functions'].includes(tab)) btn.style.display = 'none';
                    });
                }
                
                // Show demo data button ONLY for superadmin (by email, not role)
                if (isSuperAdmin) {
                    document.getElementById('demoDataBtnDesktop').style.display = 'flex';
                    document.getElementById('demoDataBtn').style.display = 'flex';
                } else {
                    document.getElementById('demoDataBtnDesktop').style.display = 'none';
                    document.getElementById('demoDataBtn').style.display = 'none';
                }
                
                showMainInterface();
                initCalendar();
                initRegularView();
                initGoogleCalendar();
                loadAllData();
                
                // Show FAB (було окремим onAuthStateChanged — об'єднано)
                const fab = document.getElementById('fabAdd');
                if (fab) fab.style.display = 'flex';
                
                // Real-time listener для нових завдань з процесів
                initTasksListener();
            } else {
                document.getElementById('loadingPage').style.display = 'none';
                document.getElementById('authPage').style.display = 'flex';
                document.getElementById('mainInterface').style.display = 'none';
                document.getElementById('logoutBtn').style.display = 'none';
                document.getElementById('adminTabBtn').style.display = 'none';
                document.getElementById('notificationBell').style.display = 'none';
                notifications = [];
                
                // Hide FAB on logout
                const fab = document.getElementById('fabAdd');
                if (fab) fab.style.display = 'none';
                
                // Перевіряємо чи є інвайт в URL
                const urlParams = new URLSearchParams(window.location.search);
                const inviteId = urlParams.get('invite');
                
                if (inviteId) {
                    // Є invite в URL — перевіряємо валідність і показуємо форму реєстрації
                    checkInviteUrl().then(result => {
                        if (result === true) {
                            showRegisterForm(); // Тепер currentInviteData вже заповнено
                        } else if (result === 'already_used') {
                            showLoginForm();
                            showAuthMessage(t('inviteAlreadyUsed'), 'info');
                        } else {
                            showRegisterForm(); // Показуємо форму все одно, нехай вводить email вручну
                            showAuthMessage(t('inviteNotFoundEmail'), 'error');
                        }
                    });
                } else {
                    showLoginForm();
                }
            }
        });

        function showMainInterface() {
            document.getElementById('loadingPage').style.display = 'none';
            document.getElementById('authPage').style.display = 'none';
            document.getElementById('mainInterface').style.display = 'block';
            document.getElementById('logoutBtn').style.display = 'block';
            document.getElementById('currentUserInfo').style.display = 'flex';
            document.getElementById('notificationBell').style.display = 'flex';
            // Відновлюємо стан кнопки "Приховати виконані"
            const hideBtn = document.getElementById('hideCompletedBtn');
            if (hideBtn && hideCompletedTasks) hideBtn.classList.add('active');
        }

        function getRoleText(role) {
            const roleKeys = { owner: 'roleOwner', manager: 'roleManager', employee: 'roleEmployee', superadmin: 'adminRole' };
            return roleKeys[role] ? t(roleKeys[role]) : role;
        }

        // =====================
        // DATA LOADING
        // =====================
        async function loadAllData() {
            if (!currentCompany) return;
            if (isLoading) {
                console.log('loadAllData: already loading, skipping...');
                return;
            }
            
            isLoading = true;
            const thisLoadVersion = ++loadingVersion;
            const startTime = performance.now();
            
            // Показуємо skeleton якщо контент ще порожній
            showSkeletonLoading();
            
            try {
                // Паралельне завантаження ВСЬОГО для швидкості (6 запитів одночасно замість 6 послідовних)
                const base = db.collection('companies').doc(currentCompany);
                
                let processQuery = base.collection('processes');
                if (!showCompletedProcesses) {
                    processQuery = processQuery.where('status', '==', 'active');
                }
                
                const TASKS_LOAD_LIMIT = 5000;
                const isEmployeeRole = currentUserData?.role === 'employee';
                const uid = currentUser.uid;
                
                // Employee: load only THEIR tasks (assigned + created + coExecutor + observer)
                // Owner/Manager: load ALL tasks
                let tasksPromise;
                if (isEmployeeRole) {
                    tasksPromise = Promise.all([
                        base.collection('tasks').where('assigneeId', '==', uid).orderBy('createdAt', 'desc').limit(1000).get(),
                        base.collection('tasks').where('creatorId', '==', uid).orderBy('createdAt', 'desc').limit(500).get(),
                        base.collection('tasks').where('coExecutorIds', 'array-contains', uid).limit(500).get()
                            .catch(() => ({ docs: [] })), // Fallback if index missing
                        base.collection('tasks').where('observerIds', 'array-contains', uid).limit(500).get()
                            .catch(() => ({ docs: [] }))  // Fallback if index missing
                    ]).then(snaps => {
                        const taskMap = new Map();
                        snaps.forEach(snap => snap.docs.forEach(doc => {
                            if (!taskMap.has(doc.id)) taskMap.set(doc.id, doc);
                        }));
                        return { docs: Array.from(taskMap.values()), size: taskMap.size, _merged: true };
                    });
                } else {
                    tasksPromise = base.collection('tasks').orderBy('createdAt', 'desc').limit(TASKS_LOAD_LIMIT).get();
                }
                
                const [usersSnap, funcsSnap, tasksSnap, regSnap, templatesSnap, processesSnap, projectsSnap] = await Promise.all([
                    base.collection('users').get(),
                    base.collection('functions').get(),
                    tasksPromise,
                    base.collection('regularTasks').get(),
                    base.collection('processTemplates').orderBy('name').get(),
                    processQuery.get(),
                    base.collection('projects').orderBy('createdAt', 'desc').get()
                ]);
                
                // Попередження якщо досягнуто ліміт
                const taskCount = tasksSnap._merged ? tasksSnap.size : tasksSnap.docs.length;
                if (!tasksSnap._merged && taskCount >= TASKS_LOAD_LIMIT) {
                    console.warn(`[loadAllData] Task limit reached: ${taskCount}/${TASKS_LOAD_LIMIT}`);
                    showToast(t('taskLimitWarning').replace('{n}', TASKS_LOAD_LIMIT), 'warning');
                }
                console.log(`[loadAllData] ${isEmployeeRole ? 'Employee' : 'Manager'} mode: ${taskCount} tasks`);
                
                // Перевіряємо чи це ще актуальний запит
                if (thisLoadVersion !== loadingVersion) {
                    console.log('loadAllData: newer load started, discarding results');
                    return;
                }
                
                // Атомарно оновлюємо всі дані
                users = usersSnap.docs.map(d => ({ id: d.id, ...d.data() }));
                functions = funcsSnap.docs.map(d => ({ id: d.id, ...d.data() }));
                tasks = tasksSnap.docs.map(d => ({ id: d.id, ...d.data() }));
                regularTasks = regSnap.docs.map(d => ({ id: d.id, ...d.data() }));
                processTemplates = templatesSnap.docs.map(d => ({ id: d.id, ...d.data() }));
                processes = processesSnap.docs.map(d => ({ id: d.id, ...d.data() }));
                projects = projectsSnap.docs.map(d => ({ id: d.id, ...d.data() }));
                
                updateSelects();
                updateProcessTemplateFilter();
                updateProjectSelects();
                
                // Авто-генерація регулярних завдань при вході
                await autoGenerateRegularTasks();
                
                // Одноразова міграція: задачі з deadline (Timestamp) без deadlineDate
                const migrateKey = `migrated_${currentCompany}`;
                if (!localStorage.getItem(migrateKey)) {
                    migrateDeadlineFields(base);
                    localStorage.setItem(migrateKey, '1');
                }
                
                // Ще раз перевіряємо актуальність
                if (thisLoadVersion !== loadingVersion) return;
                
                // Employee: автоматично ставимо фільтр "Мої" при завантаженні
                if (currentUserData?.role === 'employee' && currentUser) {
                    const calAf = document.getElementById('calendarAssigneeFilter');
                    if (calAf) calAf.value = currentUser.uid;
                }
                
                // Render My Day (головний екран)
                renderMyDay();
                
                // Render based on current view
                if (currentCalendarView === 'list') {
                    renderTasks();
                } else if (currentCalendarView === 'kanban' || currentCalendarView === 'deadlines') {
                    renderKanbanBoard(currentCalendarView);
                } else {
                    renderCalendar();
                }
                
                // Render regular tasks view
                if (currentRegularView === 'list') {
                    renderRegularTasks();
                } else {
                    renderRegularWeekView();
                }
                
                // Показуємо попап "Мій день" при першому завантаженні
                if (!sessionStorage.getItem('myDayShown')) {
                    showMyDayPopup();
                    sessionStorage.setItem('myDayShown', '1');
                }
                
                // Зберігаємо для offline — deferred to idle
                if ('requestIdleCallback' in window) {
                    requestIdleCallback(() => saveOfflineData(), { timeout: 5000 });
                } else {
                    setTimeout(saveOfflineData, 2000);
                }
                
                // Архівація в фоні (non-blocking) — не чекаємо результату
                autoArchiveDoneTasks().then(() => {
                    // Якщо щось заархівувалось — перерендерити
                    // (tasks[] вже оновлений всередині autoArchiveDoneTasks)
                }).catch(() => {});
                
                console.log(`[loadAllData] Done in ${Math.round(performance.now() - startTime)}ms, tasks: ${tasks.length}`);
                if (currentUserData?.role === 'employee') {
                    const visible = tasks.filter(t => isTaskVisibleToUser(t)).length;
                    console.log(`[Visibility] Employee "${currentUserData.name}" sees ${visible}/${tasks.length} tasks`);
                }
                
            } catch (error) {
                console.error('loadAllData error:', error);
            } finally {
                if (thisLoadVersion === loadingVersion) {
                    isLoading = false;
                    // Check escalations after data is loaded
                    checkEscalations();
                }
                hideSkeletonLoading();
            }
        }
        
        // =====================
        // NOTIFICATIONS (Sound, Badge, Title)
        // =====================
        let tasksUnsubscribe = null;
        let lastTaskCount = 0;
        
        function initTasksListener() {
            if (!currentCompany || !currentUser) return;
            
            // Відписуємось від попереднього listener
            if (tasksUnsubscribe) {
                tasksUnsubscribe();
            }
            
            // Зберігаємо ID завдань які вже бачили
            let knownTaskIds = new Set();
            let isFirstLoad = true;
            
            // Real-time listener на завдання користувача
            tasksUnsubscribe = db.collection('companies').doc(currentCompany)
                .collection('tasks')
                .where('assigneeId', '==', currentUser.uid)
                .where('status', '==', 'new')
                .onSnapshot(snapshot => {
                    const currentTaskIds = new Set(snapshot.docs.map(d => d.id));
                    
                    // При першому завантаженні просто запам'ятовуємо
                    if (isFirstLoad) {
                        knownTaskIds = currentTaskIds;
                        isFirstLoad = false;
                        lastTaskCount = snapshot.docs.length;
                        updatePageTitle();
                        return;
                    }
                    
                    // Знаходимо нові завдання (яких не було раніше)
                    const newTaskDocs = snapshot.docs.filter(doc => !knownTaskIds.has(doc.id));
                    
                    if (newTaskDocs.length > 0) {
                        // Визначаємо тип завдання для правильного повідомлення
                        const newTasks = newTaskDocs.map(doc => ({
                            id: doc.id,
                            ...doc.data()
                        }));
                        
                        // Фільтруємо завдання створені НЕ поточним користувачем
                        // (не показуємо сповіщення коли ставиш завдання сам собі)
                        const externalTasks = newTasks.filter(t => t.creatorId !== currentUser.uid);
                        
                        if (externalTasks.length > 0) {
                            const processTasks = externalTasks.filter(t => t.processId);
                            const regularTasksNew = externalTasks.filter(t => t.regularTaskId);
                            const normalTasks = externalTasks.filter(t => !t.processId && !t.regularTaskId);
                            
                            playNotificationSound();
                            
                            // Показуємо відповідний toast
                            if (processTasks.length > 0) {
                                showNewTaskToast('process', processTasks.length, processTasks[0].title);
                            } else if (regularTasksNew.length > 0) {
                                showNewTaskToast('regular', regularTasksNew.length, regularTasksNew[0].title);
                            } else if (normalTasks.length > 0) {
                                showNewTaskToast('task', normalTasks.length, normalTasks[0].title);
                            }
                        }
                        
                        // Інкрементальне оновлення — додаємо нові задачі в масив замість повного рефетчу
                        for (const newTask of newTasks) {
                            // Skip tasks being deleted (prevent race condition)
                            if (pendingDeleteIds.has(newTask.id)) continue;
                            const existingIdx = tasks.findIndex(t => t.id === newTask.id);
                            if (existingIdx >= 0) {
                                tasks[existingIdx] = newTask;
                            } else {
                                tasks.unshift(newTask);
                            }
                        }
                        
                        // Точковий ререндер — coalesced
                        scheduleRender();
                    }
                    
                    knownTaskIds = currentTaskIds;
                    lastTaskCount = snapshot.docs.length;
                    updatePageTitle();
                }, error => {
                    console.error('Tasks listener error:', error);
                });
            
            // ═══ REQUIRED FIRESTORE COMPOSITE INDEXES ═══
            // Create these in Firebase Console → Firestore → Indexes:
            // 1. tasks: assigneeId ASC, createdAt DESC
            // 2. tasks: creatorId ASC, createdAt DESC  
            // 3. tasks: assigneeId ASC, status ASC (for snapshot listeners)
            // 4. tasks: creatorId ASC, status ASC (for review listener)
            // 5. tasks: notifyOnComplete ARRAY, status ASC
            // 6. tasks: deadlineDate ASC, autoGenerated ASC
            // 7. tasks: coExecutorIds ARRAY (single-field, auto-created)
            // 8. tasks: observerIds ARRAY (single-field, auto-created)
            
            // Listener для виконаних завдань (сповіщення спостерігачам)
            initCompletedTasksListener();
            
            // Listener для завдань на перевірці (сповіщення постановнику)
            initReviewTasksListener();
            
            // Listener для повернених на доопрацювання завдань
            initRejectedTasksListener();
        }
        
        let completedTasksUnsubscribe = null;
        let knownCompletedTaskIds = new Set();
        
        function initCompletedTasksListener() {
            if (!currentCompany || !currentUser) return;
            
            if (completedTasksUnsubscribe) {
                completedTasksUnsubscribe();
            }
            
            let isFirstLoad = true;
            
            // Слухаємо завдання де поточний користувач в списку notifyOnComplete
            // УВАГА: Потрібен складений індекс в Firebase:
            // Collection: tasks, Fields: notifyOnComplete (Arrays), status (Ascending)
            completedTasksUnsubscribe = db.collection('companies').doc(currentCompany)
                .collection('tasks')
                .where('notifyOnComplete', 'array-contains', currentUser.uid)
                .where('status', '==', 'done')
                .onSnapshot(snapshot => {
                    const currentIds = new Set(snapshot.docs.map(d => d.id));
                    
                    if (isFirstLoad) {
                        knownCompletedTaskIds = currentIds;
                        isFirstLoad = false;
                        return;
                    }
                    
                    // Знаходимо нові виконані завдання
                    const newlyCompleted = snapshot.docs.filter(doc => !knownCompletedTaskIds.has(doc.id));
                    
                    if (newlyCompleted.length > 0) {
                        newlyCompleted.forEach(doc => {
                            const task = doc.data();
                            // Не сповіщаємо якщо сам виконав
                            if (task.assigneeId !== currentUser.uid) {
                                playNotificationSound();
                                showCompletedTaskToast(task);
                            }
                            // Інкрементальне оновлення — оновлюємо статус локально
                            const idx = tasks.findIndex(t => t.id === doc.id);
                            if (idx >= 0) {
                                tasks[idx] = { ...tasks[idx], ...task, id: doc.id };
                            }
                        });
                        
                        scheduleRender();
                    }
                    
                    knownCompletedTaskIds = currentIds;
                }, error => {
                    console.error('Completed tasks listener error:', error);
                });
        }
        
        function showCompletedTaskToast(task) {
            // Add to notification center
            const assignee = task.assigneeName || 'Співробітник';
            addNotification('completed', t('taskCompleted') || 'Завдання виконано', assignee + ': ' + (task.title || ''), task.id || null);
            
            const existingToast = document.getElementById('completedTaskToast');
            if (existingToast) existingToast.remove();
            
            const assigneeName = task.assigneeName || (t('employeeRole'));
            const title = task.title || '';
            const shortTitle = title.length > 25 ? title.substring(0, 25) + '...' : title;
            
            const toast = document.createElement('div');
            toast.id = 'completedTaskToast';
            toast.style.cssText = `
                position: fixed;
                top: 80px;
                right: 20px;
                background: linear-gradient(135deg, #10b981, #059669);
                color: white;
                padding: 1rem 1.5rem;
                border-radius: 12px;
                box-shadow: 0 10px 40px rgba(16, 185, 129, 0.4);
                z-index: 10001;
                display: flex;
                align-items: center;
                gap: 0.75rem;
                animation: slideInRight 0.3s ease;
                cursor: pointer;
                max-width: 350px;
            `;
            toast.innerHTML = `
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
                    <polyline points="22 4 12 14.01 9 11.01"/>
                </svg>
                <div style="flex:1;min-width:0;">
                    <div style="font-weight:600;">${t('taskCompleted')}</div>
                    <div style="font-size:0.85rem;opacity:0.9;">${esc(assigneeName)}: ${esc(shortTitle)}</div>
                </div>
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="opacity:0.7;flex-shrink:0;">
                    <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
                </svg>
            `;
            toast.onclick = () => toast.remove();
            
            document.body.appendChild(toast);
            
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.style.animation = 'slideInRight 0.3s reverse';
                    setTimeout(() => toast.remove(), 300);
                }
            }, 6000);
        }
        
        function showNewTaskToast(type, count, title) {
            // Add to notification center
            const typeMap = { process: 'process', regular: 'new_task', task: 'new_task' };
            const labelMap = { process: 'Завдання з процесу', regular: 'Регулярне завдання', task: 'Нове завдання' };
            addNotification(typeMap[type] || 'new_task', labelMap[type] || 'Нове завдання', title || '', null);
            
            // Видаляємо попередній toast якщо є
            const existingToast = document.getElementById('newTaskToast');
            if (existingToast) existingToast.remove();
            
            // Налаштування для різних типів
            const config = {
                process: {
                    gradient: 'linear-gradient(135deg, #8b5cf6, #6366f1)',
                    shadow: 'rgba(139, 92, 246, 0.4)',
                    icon: '<line x1="6" y1="3" x2="6" y2="15"/><circle cx="18" cy="6" r="3"/><circle cx="6" cy="18" r="3"/><path d="M18 9a9 9 0 0 1-9 9"/>',
                    label: t('fromProcess')
                },
                regular: {
                    gradient: 'linear-gradient(135deg, #f59e0b, #d97706)',
                    shadow: 'rgba(245, 158, 11, 0.4)',
                    icon: '<path d="M17 2.1l4 4-4 4"/><path d="M3 12.2v-2a4 4 0 0 1 4-4h12.8M7 21.9l-4-4 4-4"/><path d="M21 11.8v2a4 4 0 0 1-4 4H4.2"/>',
                    label: t('regularTaskLabel')
                },
                task: {
                    gradient: 'linear-gradient(135deg, #22c55e, #16a34a)',
                    shadow: 'rgba(34, 197, 94, 0.4)',
                    icon: '<path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/>',
                    label: t('newTaskLabel')
                }
            };
            
            const cfg = config[type] || config.task;
            const shortTitle = title && title.length > 30 ? title.substring(0, 30) + '...' : title;
            
            const toast = document.createElement('div');
            toast.id = 'newTaskToast';
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${cfg.gradient};
                color: white;
                padding: 1rem 1.5rem;
                border-radius: 12px;
                box-shadow: 0 10px 40px ${cfg.shadow};
                z-index: 10001;
                display: flex;
                align-items: center;
                gap: 0.75rem;
                animation: slideInRight 0.3s ease;
                cursor: pointer;
                max-width: 350px;
            `;
            toast.innerHTML = `
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    ${cfg.icon}
                </svg>
                <div style="flex:1;min-width:0;">
                    <div style="font-weight:600;display:flex;align-items:center;gap:0.5rem;">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align:-2px;"><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"/><path d="M13.73 21a2 2 0 0 1-3.46 0"/></svg> ${cfg.label}${count > 1 ? ` (${count})` : ''}
                    </div>
                    ${shortTitle ? `<div style="font-size:0.85rem;opacity:0.9;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${esc(shortTitle)}</div>` : ''}
                </div>
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="opacity:0.7;flex-shrink:0;">
                    <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
                </svg>
            `;
            toast.onclick = () => {
                toast.remove();
                switchTab('tasks');
            };
            
            document.body.appendChild(toast);
            
            // Додаємо анімацію (тільки раз)
            if (!document.getElementById('toastAnimationStyle')) {
                const style = document.createElement('style');
                style.id = 'toastAnimationStyle';
                style.textContent = `
                    @keyframes slideInRight { from { opacity: 0; transform: translateX(100px); } to { opacity: 1; transform: translateX(0); } }
                `;
                document.head.appendChild(style);
            }
            
            // Автоматично ховаємо через 5 секунд
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.style.animation = 'slideInRight 0.3s reverse';
                    setTimeout(() => toast.remove(), 300);
                }
            }, 5000);
        }
        
        function playNotificationSound() {
            try {
                // Створюємо простий beep звук через Web Audio API
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 800;
                oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3);
            } catch (e) {
                console.log('Sound not supported');
            }
        }
        
        function updatePageTitle() {
            const myTasks = tasks.filter(t => t.assigneeId === currentUser?.uid && t.status !== 'done');
            const newCount = myTasks.filter(t => t.status === 'new').length;
            
            if (newCount > 0) {
                document.title = `(${newCount}) TALKO System`;
            } else {
                document.title = 'TALKO System - Таск Менеджер Pro';
            }
        }
        
        // Оновлюємо title при зміні завдань
        let _pageTitleInterval = setInterval(updatePageTitle, 30000);
        
        // Multi-tab sync: reload data when tab becomes visible after being hidden
        let _lastVisibleTime = Date.now();
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) return;
            const elapsed = Date.now() - _lastVisibleTime;
            _lastVisibleTime = Date.now();
            // If tab was hidden for >60s and user is logged in, refresh data
            if (elapsed > 60000 && currentUser && currentCompany) {
                console.log('[MultiTab] Tab restored after', Math.round(elapsed/1000), 's — refreshing');
                loadAllData();
            }
        });
        
        // =====================
        // AUTO-GENERATE REGULAR TASKS
        // =====================
        let myDayPopupShown = false;
        
        // Хелпер: перевірка чи регулярне завдання заплановане на певний день
        function isRegularTaskDay(rt, date) {
            const day = date.getDay(); // 0-6
            const dateNum = date.getDate(); // 1-31
            
            if (rt.period === 'daily') return true;
            
            if (rt.period === 'weekly') {
                if (rt.daysOfWeek && Array.isArray(rt.daysOfWeek)) {
                    return rt.daysOfWeek.includes(day.toString());
                }
                return rt.dayOfWeek === day.toString();
            }
            
            if (rt.period === 'monthly') {
                if (rt.dayOfMonth === 'last') {
                    const lastDay = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
                    return dateNum === lastDay;
                }
                return dateNum === parseInt(rt.dayOfMonth);
            }
            
            if (rt.period === 'quarterly') {
                const quarterStartMonth = Math.floor(date.getMonth() / 3) * 3;
                if (date.getMonth() !== quarterStartMonth) return false;
                if (rt.dayOfMonth === 'last') {
                    const lastDay = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
                    return dateNum === lastDay;
                }
                return dateNum === parseInt(rt.dayOfMonth);
            }
            
            return false;
        }
        
        // =====================
        // AUTO-ARCHIVE DONE TASKS (> 30 days)
        // =====================
        async function autoArchiveDoneTasks() {
            if (!currentCompany) return;
            
            // Run once per day max
            const lastArchiveKey = `lastArchive_${currentCompany}`;
            const lastArchive = localStorage.getItem(lastArchiveKey);
            const today = getLocalDateStr();
            if (lastArchive === today) return;
            
            try {
                const thirtyDaysAgo = new Date();
                thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
                
                const base = db.collection('companies').doc(currentCompany);
                
                // Filter done tasks from already-loaded local array
                // This avoids: 1) composite index requirement 2) Timestamp vs string type mismatch
                const oldDoneTasks = tasks.filter(t => {
                    if (t.status !== 'done') return false;
                    // Check createdAt - can be Firestore Timestamp, ISO string, or Date
                    let created;
                    if (t.createdAt?.toDate) {
                        created = t.createdAt.toDate();
                    } else if (t.createdAt) {
                        created = new Date(t.createdAt);
                    } else {
                        return false;
                    }
                    return created < thirtyDaysAgo;
                });
                
                if (oldDoneTasks.length === 0) {
                    localStorage.setItem(lastArchiveKey, today);
                    return;
                }
                
                // Firestore batch limit = 500 operations. Each task = 2 ops (set+delete) → max 250/batch
                const BATCH_SIZE = 250;
                const committedIds = new Set();
                
                for (let i = 0; i < oldDoneTasks.length; i += BATCH_SIZE) {
                    const chunk = oldDoneTasks.slice(i, i + BATCH_SIZE);
                    const batch = db.batch();
                    
                    chunk.forEach(task => {
                        const archiveRef = base.collection('tasksArchive').doc(task.id);
                        const taskRef = base.collection('tasks').doc(task.id);
                        
                        const archiveData = {};
                        Object.keys(task).forEach(key => {
                            if (key !== 'id') archiveData[key] = task[key];
                        });
                        archiveData.archivedAt = firebase.firestore.FieldValue.serverTimestamp();
                        
                        batch.set(archiveRef, archiveData);
                        batch.delete(taskRef);
                    });
                    
                    try {
                        await batch.commit();
                        chunk.forEach(t => committedIds.add(t.id));
                    } catch (batchError) {
                        console.error(`[autoArchive] Batch ${i / BATCH_SIZE + 1} failed:`, batchError);
                        break; // Зупиняємо подальші batch, не втрачаємо дані
                    }
                }
                
                if (committedIds.size > 0) {
                    console.log(`[autoArchive] Archived ${committedIds.size} done tasks older than 30 days`);
                    tasks = tasks.filter(t => !committedIds.has(t.id));
                }
                
                localStorage.setItem(lastArchiveKey, today);
            } catch (error) {
                console.error('autoArchiveDoneTasks error:', error);
                // Non-critical — don't block UI, just log
            }
        }
        
        // =====================
        // ARCHIVE UI
        // =====================
        let isArchiveView = false;
        let archiveTasks = [];
        let archiveLastDoc = null;
        const ARCHIVE_PAGE_SIZE = 50;
        
        function toggleArchiveView() {
            isArchiveView = !isArchiveView;
            
            const tasksContainer = document.getElementById('tasksContainer');
            const archiveContainer = document.getElementById('archiveContainer');
            const listContainer = tasksContainer?.closest('.list-container');
            const filtersRow = listContainer?.querySelector('.filters-row');
            const mobileFilterBar = document.getElementById('mobileFilterBar');
            const totalTimeInfo = document.getElementById('totalTimeInfo');
            const archiveBtn = document.getElementById('archiveToggleBtn');
            
            if (isArchiveView) {
                tasksContainer.style.display = 'none';
                if (filtersRow) filtersRow.style.display = 'none';
                if (mobileFilterBar) mobileFilterBar.style.display = 'none';
                if (totalTimeInfo) totalTimeInfo.style.display = 'none';
                archiveContainer.style.display = 'block';
                archiveBtn.style.background = 'var(--primary)';
                archiveBtn.innerHTML = '<i data-lucide="arrow-left" class="icon"></i> <span>Завдання</span>';
                
                archiveTasks = [];
                archiveLastDoc = null;
                loadArchiveTasks();
            } else {
                tasksContainer.style.display = '';
                if (filtersRow) filtersRow.style.display = '';
                if (mobileFilterBar) mobileFilterBar.style.display = '';
                if (totalTimeInfo) totalTimeInfo.style.display = '';
                archiveContainer.style.display = 'none';
                archiveBtn.style.background = '#6b7280';
                archiveBtn.innerHTML = '<i data-lucide="archive" class="icon"></i> <span>Архів</span>';
            }
            refreshIcons();
        }
        
        async function loadArchiveTasks() {
            if (!currentCompany) return;
            
            const listEl = document.getElementById('archiveTasksList');
            if (archiveTasks.length === 0) {
                listEl.innerHTML = '<div style="text-align:center;padding:2rem;color:#9ca3af;"><div class="spinner"></div> Завантаження...</div>';
            }
            
            try {
                const base = db.collection('companies').doc(currentCompany);
                let query = base.collection('tasksArchive')
                    .orderBy('archivedAt', 'desc')
                    .limit(ARCHIVE_PAGE_SIZE);
                
                if (archiveLastDoc) {
                    query = query.startAfter(archiveLastDoc);
                }
                
                const snap = await query.get();
                
                if (snap.empty && archiveTasks.length === 0) {
                    listEl.innerHTML = `
                        <div style="text-align:center;padding:3rem;color:#9ca3af;">
                            <i data-lucide="archive" class="icon icon-xl" style="color:#d1d5db;margin-bottom:0.5rem;"></i>
                            <p>Архів порожній</p>
                            <p style="font-size:0.8rem;">Завершені завдання старші 30 днів з'являться тут автоматично</p>
                        </div>`;
                    refreshIcons();
                    return;
                }
                
                const newTasks = snap.docs.map(d => ({ id: d.id, ...d.data() }));
                archiveTasks = archiveTasks.concat(newTasks);
                
                if (snap.docs.length > 0) {
                    archiveLastDoc = snap.docs[snap.docs.length - 1];
                }
                
                renderArchiveTasks();
                
                // Show/hide load more
                const loadMoreEl = document.getElementById('archiveLoadMore');
                loadMoreEl.style.display = snap.docs.length >= ARCHIVE_PAGE_SIZE ? 'block' : 'none';
                
            } catch (error) {
                console.error('loadArchiveTasks error:', error);
                listEl.innerHTML = '<div style="text-align:center;padding:2rem;color:#ef4444;">Помилка завантаження архіву</div>';
            }
        }
        
        function loadMoreArchive() {
            loadArchiveTasks();
        }
        
        function renderArchiveTasks() {
            const listEl = document.getElementById('archiveTasksList');
            const countEl = document.getElementById('archiveCount');
            
            countEl.textContent = `${archiveTasks.length} записів`;
            
            const st = { new: t('statusNew'), progress: t('statusProgress'), review: t('statusReview'), done: t('statusDone') };
            
            // Desktop table
            let html = `
                <table class="tasks-table" style="table-layout:fixed;">
                    <thead>
                        <tr>
                            <th>${t('task')}</th>
                            <th>${t('assignee')}</th>
                            <th>${t('deadline')}</th>
                            <th>${t('type')}</th>
                            <th>Архівовано</th>
                            <th>Дії</th>
                        </tr>
                    </thead>
                    <tbody>`;
            
            archiveTasks.forEach(task => {
                const taskDeadline = task.deadlineDate || '';
                const archivedDate = task.archivedAt?.toDate ? 
                    task.archivedAt.toDate().toLocaleDateString('uk-UA') : 
                    (task.archivedAt ? new Date(task.archivedAt).toLocaleDateString('uk-UA') : '-');
                
                html += `
                    <tr style="opacity:0.8;">
                        <td class="task-title-cell">
                            <span class="task-title-text">${esc(task.title)}</span>
                        </td>
                        <td>${esc(task.assigneeName) || '-'}</td>
                        <td>${taskDeadline ? formatDateShort(taskDeadline) : '-'}</td>
                        <td>${esc(task.function) || '-'}</td>
                        <td style="font-size:0.8rem;color:#9ca3af;">${archivedDate}</td>
                        <td>
                            <button class="action-btn" onclick="restoreFromArchive('${escId(task.id)}')" title="Відновити">
                                <i data-lucide="rotate-ccw" class="icon icon-sm" style="color:var(--primary);"></i>
                            </button>
                        </td>
                    </tr>`;
            });
            
            html += `</tbody></table>`;
            
            // Mobile cards
            html += `<div class="mobile-tasks-list">`;
            archiveTasks.forEach(task => {
                const archivedDate = task.archivedAt?.toDate ? 
                    task.archivedAt.toDate().toLocaleDateString('uk-UA') : '-';
                
                html += `
                <div class="mobile-task-card status-done" style="opacity:0.85;">
                    <div class="mobile-task-content">
                        <div class="mobile-task-header">
                            <div class="mobile-task-title">${esc(task.title)}</div>
                            <span class="status-badge status-done">${st.done}</span>
                        </div>
                        <div class="mobile-task-meta">
                            ${task.assigneeName ? `<div class="mobile-task-meta-item"><i data-lucide="user" class="icon icon-sm"></i> ${esc(task.assigneeName)}</div>` : ''}
                            ${task.function ? `<div class="mobile-task-meta-item"><i data-lucide="tag" class="icon icon-sm"></i> ${esc(task.function)}</div>` : ''}
                            <div class="mobile-task-meta-item"><i data-lucide="archive" class="icon icon-sm"></i> ${archivedDate}</div>
                        </div>
                        <div class="mobile-task-actions">
                            <button class="mobile-action-btn edit" onclick="restoreFromArchive('${escId(task.id)}')">
                                <i data-lucide="rotate-ccw" class="icon icon-sm"></i> ${t('reopen')}
                            </button>
                        </div>
                    </div>
                </div>`;
            });
            html += `</div>`;
            
            listEl.innerHTML = html;
            refreshIcons();
        }
        
        async function restoreFromArchive(taskId) {
            if (!confirm(t('restoreFromArchive'))) return;
            
            try {
                const base = db.collection('companies').doc(currentCompany);
                const archiveDoc = await base.collection('tasksArchive').doc(taskId).get();
                
                if (!archiveDoc.exists) {
                    showToast(t('taskNotFoundArchive'), 'error');
                    return;
                }
                
                const data = archiveDoc.data();
                delete data.archivedAt;
                
                // Restore to tasks + remove from archive
                const batch = db.batch();
                batch.set(base.collection('tasks').doc(taskId), data);
                batch.delete(base.collection('tasksArchive').doc(taskId));
                await batch.commit();
                
                // Update local arrays
                archiveTasks = archiveTasks.filter(t => t.id !== taskId);
                if (!tasks.find(t => t.id === taskId)) {
                    tasks.unshift({ id: taskId, ...data });
                }
                
                renderArchiveTasks();
                showToast(t('taskRestored'), 'success');
            } catch (error) {
                console.error('restoreFromArchive error:', error);
                showToast(t('restoreError'), 'error');
            }
        }
        
        async function autoGenerateRegularTasks() {
            if (!currentUser || !currentCompany) return;
            
            const today = new Date();
            const todayStr = getLocalDateStr(today);
            
            // Skip if already generated today (avoids extra Firestore query on tab refresh)
            const autoGenKey = `autoGen_${currentCompany}_${currentUser.uid}`;
            if (localStorage.getItem(autoGenKey) === todayStr) return;
            
            const base = db.collection('companies').doc(currentCompany).collection('tasks');
            
            // Серверна перевірка: які regularTaskId вже мають завдання на сьогодні
            // Це захищає від дублів коли 2+ таби відкриті одночасно
            let existingRegularIds = new Set();
            try {
                const existingSnap = await base
                    .where('deadlineDate', '==', todayStr)
                    .where('autoGenerated', '==', true)
                    .get();
                existingSnap.docs.forEach(doc => {
                    const d = doc.data();
                    if (d.regularTaskId && d.assigneeId) {
                        existingRegularIds.add(`${d.regularTaskId}_${d.assigneeId}`);
                    }
                });
            } catch (err) {
                console.warn('[AutoGenerate] Server check failed, falling back to local:', err);
                // Fallback: локальна перевірка
                tasks.forEach(t => {
                    if (t.regularTaskId && t.deadlineDate === todayStr && t.autoGenerated) {
                        existingRegularIds.add(`${t.regularTaskId}_${t.assigneeId}`);
                    }
                });
            }
            
            // Збираємо завдання для створення
            const tasksToCreate = [];
            
            for (const rt of regularTasks) {
                if (!isRegularTaskDay(rt, today)) continue;
                
                let assigneeIds;
                if (rt.assigneeId) {
                    // Прямий виконавець з регулярного завдання
                    assigneeIds = [rt.assigneeId];
                } else {
                    const func = functions.find(f => f.name === rt.function);
                    assigneeIds = func?.assigneeIds || [];
                }
                if (assigneeIds.length === 0) continue;
                
                for (const assigneeId of assigneeIds) {
                    const key = `${rt.id}_${assigneeId}`;
                    if (existingRegularIds.has(key)) continue;
                    
                    // Одразу додаємо в set щоб не створити дублі в рамках одного batch
                    existingRegularIds.add(key);
                    
                    const assignee = users.find(u => u.id === assigneeId);
                    tasksToCreate.push({
                        title: rt.title,
                        function: rt.function,
                        assigneeId: assigneeId,
                        assigneeName: assignee?.name || assignee?.email || '',
                        deadlineDate: todayStr,
                        deadlineTime: rt.timeStart || rt.time || '18:00',
                        deadline: todayStr + 'T' + (rt.timeStart || rt.time || '18:00'),
                        expectedResult: rt.expectedResult || '',
                        reportFormat: rt.reportFormat || '',
                        description: rt.instruction || '',
                        status: 'new',
                        priority: rt.priority || 'medium',
                        requireReview: rt.requireReview || false,
                        checklist: (rt.checklist || []).map(c => ({ text: c.text || c, done: false })),
                        pinned: false,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                        createdDate: todayStr,
                        creatorId: currentUser.uid,
                        creatorName: t('systemUser'),
                        regularTaskId: rt.id,
                        notifyOnComplete: rt.notifyOnComplete || [],
                        autoGenerated: true
                    });
                }
            }
            
            if (tasksToCreate.length === 0) return;
            
            try {
                // Batch write — до 500 операцій за раз (Firestore ліміт)
                const batchSize = 500;
                for (let i = 0; i < tasksToCreate.length; i += batchSize) {
                    const batch = db.batch();
                    const chunk = tasksToCreate.slice(i, i + batchSize);
                    const localTasks = [];
                    
                    for (const taskData of chunk) {
                        const newRef = base.doc();
                        batch.set(newRef, taskData);
                        localTasks.push({ id: newRef.id, ...taskData });
                    }
                    
                    await batch.commit();
                    
                    // Додаємо в локальний масив ПІСЛЯ успішного commit
                    localTasks.forEach(t => tasks.unshift(t));
                }
                
                console.log(`[AutoGenerate] Created ${tasksToCreate.length} tasks in batch`);
                localStorage.setItem(autoGenKey, todayStr);
            } catch (err) {
                console.error('[AutoGenerate] Batch error:', err);
            }
        }
        
        // =====================
        // MY DAY POPUP
        // =====================
        function showMyDayPopup() {
            // Показуємо тільки раз за сесію і тільки якщо є завдання
            if (myDayPopupShown) return;
            myDayPopupShown = true;
            
            const today = getLocalDateStr();
            const myTasks = tasks.filter(t => t.assigneeId === currentUser?.uid);
            
            // Завдання на сьогодні
            const todayTasks = myTasks.filter(t => t.deadlineDate === today && t.status !== 'done');
            
            // Прострочені
            const overdueTasks = myTasks.filter(t => t.deadlineDate < today && t.status !== 'done' && t.status !== 'review');
            
            // Нові завдання з процесів (створені сьогодні)
            const processTasksNew = myTasks.filter(t => 
                t.processId && 
                t.status === 'new' && 
                t.createdDate === today
            );
            
            // Якщо нічого немає - не показуємо
            if (todayTasks.length === 0 && overdueTasks.length === 0 && processTasksNew.length === 0) return;
            
            // Звуковий сигнал якщо є нові завдання з процесів
            if (processTasksNew.length > 0) {
                playNotificationSound();
            }
            
            // Оновлюємо title вкладки
            updatePageTitle();
            
            // Створюємо попап
            const popup = document.createElement('div');
            popup.id = 'myDayPopup';
            popup.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                animation: fadeIn 0.3s;
            `;
            
            const overdueHtml = overdueTasks.length > 0 ? `
                <div style="background:#fef2f2;border:1px solid #fecaca;border-radius:12px;padding:1rem;margin-bottom:1rem;">
                    <div style="display:flex;align-items:center;gap:0.5rem;color:#dc2626;font-weight:600;margin-bottom:0.5rem;">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>
                        ${t('overdueStatus')}: ${overdueTasks.length}
                    </div>
                    <div style="font-size:0.85rem;color:#7f1d1d;">
                        ${overdueTasks.slice(0, 3).map(t => `• ${esc(t.title)}`).join('<br>')}
                        ${overdueTasks.length > 3 ? `<br><i>+${overdueTasks.length - 3} ${t('moreItems')}...</i>` : ''}
                    </div>
                </div>
            ` : '';
            
            const todayHtml = todayTasks.length > 0 ? `
                <div style="background:#f0fdf4;border:1px solid #bbf7d0;border-radius:12px;padding:1rem;margin-bottom:1rem;">
                    <div style="display:flex;align-items:center;gap:0.5rem;color:#16a34a;font-weight:600;margin-bottom:0.5rem;">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
                        ${t('forToday')}: ${todayTasks.length}
                    </div>
                    <div style="font-size:0.85rem;color:#166534;">
                        ${todayTasks.slice(0, 5).map(t => `• ${esc(t.title)}`).join('<br>')}
                        ${todayTasks.length > 5 ? `<br><i>+${todayTasks.length - 5} ${t('moreItems')}...</i>` : ''}
                    </div>
                </div>
            ` : '';
            
            // Нові завдання з процесів
            const processHtml = processTasksNew.length > 0 ? `
                <div style="background:#f5f3ff;border:1px solid #c4b5fd;border-radius:12px;padding:1rem;margin-bottom:1rem;">
                    <div style="display:flex;align-items:center;gap:0.5rem;color:#7c3aed;font-weight:600;margin-bottom:0.5rem;">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="6" y1="3" x2="6" y2="15"/><circle cx="18" cy="6" r="3"/><circle cx="6" cy="18" r="3"/><path d="M18 9a9 9 0 0 1-9 9"/></svg>
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align:-2px;"><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"/><path d="M13.73 21a2 2 0 0 1-3.46 0"/></svg> ${t('newFromProcesses')}: ${processTasksNew.length}
                    </div>
                    <div style="font-size:0.85rem;color:#5b21b6;">
                        ${processTasksNew.slice(0, 3).map(t => `• ${esc(t.title)}`).join('<br>')}
                        ${processTasksNew.length > 3 ? `<br><i>+${processTasksNew.length - 3} ${t('moreItems')}...</i>` : ''}
                    </div>
                </div>
            ` : '';
            
            popup.innerHTML = `
                <div style="background:white;border-radius:20px;padding:1.5rem;max-width:400px;width:90%;box-shadow:0 20px 60px rgba(0,0,0,0.3);animation:slideUp 0.3s;">
                    <div style="text-align:center;margin-bottom:1.25rem;">
                        <div style="width:60px;height:60px;background:linear-gradient(135deg,#22c55e,#16a34a);border-radius:50%;display:flex;align-items:center;justify-content:center;margin:0 auto 0.75rem;">
                            <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>
                        </div>
                        <h2 style="margin:0;font-size:1.3rem;color:var(--dark);">${t('greeting')}, ${esc(currentUserData?.name?.split(' ')[0] || currentUser?.email?.split('@')[0] || '')}!</h2>
                        <p style="margin:0.25rem 0 0;color:var(--gray);font-size:0.9rem;">${t('yourTasksToday')}</p>
                    </div>
                    
                    ${processHtml}
                    ${overdueHtml}
                    ${todayHtml}
                    
                    <button onclick="closeMyDayPopup()" style="width:100%;padding:0.9rem;background:var(--primary);color:white;border:none;border-radius:12px;font-size:1rem;font-weight:600;cursor:pointer;display:flex;align-items:center;justify-content:center;gap:0.5rem;">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 12h14"/><path d="M12 5l7 7-7 7"/></svg>
                        ${t('startWork')}
                    </button>
                </div>
            `;
            
            document.body.appendChild(popup);
            
            // Додаємо анімації (тільки один раз)
            if (!document.getElementById('myDayAnimStyles')) {
                const style = document.createElement('style');
                style.id = 'myDayAnimStyles';
                style.textContent = `
                    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
                    @keyframes slideUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
                `;
                document.head.appendChild(style);
            }
        }
        
        function closeMyDayPopup() {
            const popup = document.getElementById('myDayPopup');
            if (popup) {
                popup.style.animation = 'fadeIn 0.2s reverse';
                setTimeout(() => popup.remove(), 200);
            }
        }

        // =====================
        // TASKS
        // =====================
        function openTaskModal(id = null) {
            document.getElementById('taskModal').style.display = 'block';
            updateSelects();
            updateProjectSelects();
            
            // Initialize comments section
            initTaskComments(id);
            
            // Рендеримо чекбокси для сповіщень
            renderNotifyUsersCheckboxes(id);
            renderNotifyReminderCheckboxes();
            
            if (id) {
                editingId = id;
                if (id) { const _t = tasks.find(t => t.id === id); if (_t) _t._openedAt = Date.now(); }
                const task = tasks.find(x => x.id === id);
                if (task) {
                    document.getElementById('taskModalTitle').textContent = t('editTask');
                    document.getElementById('taskTitle').value = task.title || '';
                    document.getElementById('taskFunction').value = task.function || '';
                    updateProjectSelects(task.projectId);
                    document.getElementById('taskProject').value = task.projectId || '';
                    document.getElementById('taskAssignee').value = task.assigneeId || '';
                    // Розбиваємо deadline на дату і час
                    const dl = parseDeadline(task);
                    document.getElementById('taskDeadlineDate').value = dl.date;
                    document.getElementById('taskDeadlineTime').value = dl.time || '18:00';
                    
                    // Час закінчення / тривалість
                    if (task.timeEnd) {
                        document.getElementById('taskTimeEnd').value = task.timeEnd;
                        if (task.duration) {
                            document.getElementById('taskTimeMode').value = 'duration';
                            document.getElementById('taskEstimatedTime').value = task.duration;
                        } else {
                            document.getElementById('taskTimeMode').value = 'end';
                        }
                    } else if (task.estimatedTime) {
                        document.getElementById('taskTimeMode').value = 'duration';
                        document.getElementById('taskEstimatedTime').value = task.estimatedTime;
                        const startTime = task.deadlineTime || '18:00';
                        document.getElementById('taskTimeEnd').value = calculateEndTime(startTime, parseInt(task.estimatedTime));
                    } else {
                        document.getElementById('taskTimeMode').value = 'duration';
                        document.getElementById('taskEstimatedTime').value = '60';
                        document.getElementById('taskTimeEnd').value = '19:00';
                    }
                    toggleTaskTimeMode();
                    
                    document.getElementById('taskPriority').value = task.priority || 'medium';
                    document.getElementById('taskStatus').value = task.status || 'new';
                    document.getElementById('taskExpectedResult').value = task.expectedResult || '';
                    document.getElementById('taskReportFormat').value = task.reportFormat || '';
                    document.getElementById('taskDescription').value = task.description || task.instruction || '';
                    
                    // AI Help button
                    const aiRow = document.getElementById('taskAiHelpRow');
                    const aiLink = document.getElementById('taskAiHelpLink');
                    if (aiRow && aiLink) {
                        aiRow.style.display = 'block';
                        aiLink.href = getAiHelpUrl(task.title, task.description || task.instruction || '', task.function);
                    }
                    
                    // Встановлюємо чекбокси сповіщень
                    setNotifyUsersCheckboxes(task.notifyOnComplete || []);
                    
                    // Встановлюємо налаштування нагадувань
                    setRemindersCheckboxes(task.reminders || [60, 15]);
                    document.getElementById('taskEscalationEnabled').checked = task.escalationEnabled || false;
                    document.getElementById('taskEscalationMinutes').value = task.escalationMinutes || 60;
                    setNotifyReminderCheckboxes(task.notifyOnReminder || []);
                    
                    // FEAT-001: Нові поля
                    renderUserCheckboxes('taskCoExecutors', task.coExecutorIds || []);
                    renderUserCheckboxes('taskObservers', task.observerIds || []);
                    document.getElementById('taskStartDate').value = task.startDate || '';
                    document.getElementById('taskRequireReview').checked = task.requireReview !== false; // default true
                    document.getElementById('taskAllowDeadlineChange').checked = task.allowDeadlineChange || false;
                    renderChecklist(task.checklist || []);
                    
                    // FEAT-006: Time Tracking
                    renderTimeTracking(task);
                    
                    // FEAT-007: Блокуємо дедлайн якщо не дозволено
                    const deadlineEditable = canEditDeadline(task);
                    document.getElementById('taskDeadlineDate').disabled = !deadlineEditable;
                    document.getElementById('taskDeadlineTime').disabled = !deadlineEditable;
                    
                    // VIEW-ONLY режим для employee, який не є виконавцем або постановником
                    const canEdit = currentUserData?.role !== 'employee' || 
                                    task.assigneeId === currentUser?.uid || 
                                    task.creatorId === currentUser?.uid ||
                                    (task.coExecutorIds && task.coExecutorIds.includes(currentUser?.uid));
                    const formFields = document.getElementById('taskForm').querySelectorAll('input, select, textarea');
                    formFields.forEach(el => { 
                        if (!canEdit) el.disabled = true; 
                    });
                    const submitBtn = document.getElementById('taskForm').querySelector('button[type="submit"]');
                    if (submitBtn) submitBtn.style.display = canEdit ? '' : 'none';
                    if (!canEdit) {
                        document.getElementById('taskModalTitle').textContent = t('viewTask');
                    }
                    
                    // Task actions — показуємо керівнику/постановнику дії залежно від статусу
                    const reviewActions = document.getElementById('taskReviewActions');
                    if (reviewActions) {
                        const isOwnerOrAdmin = currentUserData?.role === 'owner' || currentUserData?.role === 'admin';
                        const isManager = currentUserData?.role === 'manager';
                        const isCreator = task.creatorId === currentUser?.uid;
                        const canManage = isOwnerOrAdmin || isManager || isCreator;
                        const isAssignee = task.assigneeId === currentUser?.uid;
                        
                        if (canManage && task.status === 'review') {
                            // Менеджер/owner бачить кнопки ревью
                            reviewActions.style.display = 'block';
                            reviewActions.style.background = 'linear-gradient(135deg,#f0fdf4,#ecfdf5)';
                            reviewActions.style.border = '2px solid #22c55e';
                            const label = document.getElementById('taskActionsLabel');
                            const btns = document.getElementById('taskActionsButtons');
                            label.innerHTML = '<i data-lucide="shield-check" class="icon icon-sm" style="color:#16a34a;"></i> <span style="color:#16a34a;">Завдання на перевірці</span>';
                            btns.innerHTML = `
                                <button type="button" class="btn btn-success" style="flex:1;min-width:130px;padding:0.6rem 1rem;font-size:0.9rem;font-weight:600;" onclick="acceptReviewFromModal()">
                                    <i data-lucide="check-circle" class="icon"></i> Прийняти
                                </button>
                                <button type="button" class="btn" style="flex:1;min-width:130px;padding:0.6rem 1rem;font-size:0.9rem;font-weight:600;background:#f59e0b;" onclick="rejectReviewFromModal()">
                                    <i data-lucide="rotate-ccw" class="icon"></i> Допрацювати
                                </button>`;
                            refreshIcons();
                        } else if (isAssignee && (task.status === 'new' || task.status === 'progress')) {
                            // Виконавець бачить кнопку Виконано
                            reviewActions.style.display = 'block';
                            reviewActions.style.background = 'linear-gradient(135deg,#f0fdf4,#ecfdf5)';
                            reviewActions.style.border = '2px solid #22c55e';
                            const label = document.getElementById('taskActionsLabel');
                            const btns = document.getElementById('taskActionsButtons');
                            const statusLabel = task.status === 'new' ? 'Нове завдання' : 'В роботі';
                            label.innerHTML = '<i data-lucide="info" class="icon icon-sm" style="color:#16a34a;"></i> <span style="color:#16a34a;">Статус: ' + statusLabel + '</span>';
                            
                            const manageButtons = canManage ? `
                                <button type="button" class="btn" style="flex:1;min-width:130px;padding:0.6rem 1rem;font-size:0.85rem;font-weight:600;background:#f59e0b;" onclick="rejectReviewFromModal()">
                                    <i data-lucide="message-circle" class="icon"></i> Допрацювати
                                </button>` : '';
                            
                            btns.innerHTML = `
                                <button type="button" class="btn btn-success" style="flex:1;min-width:180px;padding:0.75rem 1rem;font-size:1rem;font-weight:700;" onclick="completeTaskFromModal()">
                                    <i data-lucide="check-circle" class="icon"></i> Виконано
                                </button>
                                ${manageButtons}`;
                            refreshIcons();
                        } else if (!isAssignee && canManage && (task.status === 'new' || task.status === 'progress')) {
                            // Менеджер дивиться чужу задачу (не на ревью)
                            reviewActions.style.display = 'block';
                            reviewActions.style.background = 'linear-gradient(135deg,#f0f9ff,#e0f2fe)';
                            reviewActions.style.border = '2px solid #38bdf8';
                            const label = document.getElementById('taskActionsLabel');
                            const btns = document.getElementById('taskActionsButtons');
                            const statusLabel = task.status === 'new' ? 'Нове завдання' : 'В роботі';
                            label.innerHTML = '<i data-lucide="info" class="icon icon-sm" style="color:#0284c7;"></i> <span style="color:#0284c7;">Статус: ' + statusLabel + '</span>';
                            btns.innerHTML = `
                                <button type="button" class="btn btn-success" style="flex:1;min-width:130px;padding:0.6rem 1rem;font-size:0.9rem;font-weight:600;" onclick="acceptReviewFromModal()">
                                    <i data-lucide="check-circle" class="icon"></i> Прийняти роботу
                                </button>
                                <button type="button" class="btn" style="flex:1;min-width:130px;padding:0.6rem 1rem;font-size:0.9rem;font-weight:600;background:#f59e0b;" onclick="rejectReviewFromModal()">
                                    <i data-lucide="message-circle" class="icon"></i> Допрацювати
                                </button>`;
                            refreshIcons();
                        } else if (isAssignee && task.status === 'review') {
                            // Працівник бачить що його задача на перевірці
                            reviewActions.style.display = 'block';
                            reviewActions.style.background = 'linear-gradient(135deg,#fffbeb,#fef3c7)';
                            reviewActions.style.border = '2px solid #f59e0b';
                            const label = document.getElementById('taskActionsLabel');
                            const btns = document.getElementById('taskActionsButtons');
                            label.innerHTML = '<i data-lucide="clock" class="icon icon-sm" style="color:#d97706;"></i> <span style="color:#d97706;">Завдання на перевірці у керівника</span>';
                            btns.innerHTML = '<p style="font-size:0.85rem;color:#92400e;margin:0;">Очікуйте підтвердження або зауваження</p>';
                            refreshIcons();
                        } else if (canManage && task.status === 'done') {
                            reviewActions.style.display = 'block';
                            reviewActions.style.background = 'linear-gradient(135deg,#f0fdf4,#ecfdf5)';
                            reviewActions.style.border = '2px solid #86efac';
                            const label = document.getElementById('taskActionsLabel');
                            const btns = document.getElementById('taskActionsButtons');
                            label.innerHTML = '<i data-lucide="check-circle-2" class="icon icon-sm" style="color:#16a34a;"></i> <span style="color:#16a34a;">Завдання виконано</span>';
                            btns.innerHTML = `
                                <button type="button" class="btn" style="flex:1;min-width:130px;padding:0.6rem 1rem;font-size:0.9rem;font-weight:600;background:#f59e0b;" onclick="reopenTaskFromModal()">
                                    <i data-lucide="rotate-ccw" class="icon"></i> Повернути в роботу
                                </button>`;
                            refreshIcons();
                        } else {
                            reviewActions.style.display = 'none';
                        }
                    }
                }
            } else {
                editingId = null;
                document.getElementById('taskModalTitle').textContent = t('newTask');
                document.getElementById('taskForm').reset();
                // Hide review actions
                const reviewActions = document.getElementById('taskReviewActions');
                if (reviewActions) reviewActions.style.display = 'none';
                // Hide AI help for new tasks
                const aiRow = document.getElementById('taskAiHelpRow');
                if (aiRow) aiRow.style.display = 'none';
                // Reset view-only mode
                document.getElementById('taskForm').querySelectorAll('input, select, textarea').forEach(el => el.disabled = false);
                const submitBtn = document.getElementById('taskForm').querySelector('button[type="submit"]');
                if (submitBtn) submitBtn.style.display = '';
                // Встановлюємо дефолтний час
                document.getElementById('taskDeadlineTime').value = '18:00';
                document.getElementById('taskTimeEnd').value = '19:00';
                document.getElementById('taskTimeMode').value = 'duration';
                document.getElementById('taskEstimatedTime').value = '60';
                toggleTaskTimeMode();
                
                // За замовчуванням сповіщуємо творця (поточного користувача)
                setNotifyUsersCheckboxes([currentUser?.uid]);
                
                // Дефолтні налаштування нагадувань
                setRemindersCheckboxes([60, 15]); // За 1 год і 15 хв
                document.getElementById('taskEscalationEnabled').checked = false;
                document.getElementById('taskEscalationMinutes').value = 60;
                setNotifyReminderCheckboxes([currentUser?.uid]); // Контроль творцю
                
                // FEAT-001: Дефолти нових полів
                renderUserCheckboxes('taskCoExecutors', []);
                renderUserCheckboxes('taskObservers', []);
                document.getElementById('taskStartDate').value = '';
                document.getElementById('taskRequireReview').checked = true;
                document.getElementById('taskAllowDeadlineChange').checked = false;
                renderChecklist([]);
                document.getElementById('taskDeadlineDate').disabled = false;
                document.getElementById('taskDeadlineTime').disabled = false;
                // FEAT-006: Ховаємо time tracking для нових завдань
                document.getElementById('timeTrackingSection').style.display = 'none';
            }
        }
        
        // Рендеримо чекбокси для сповіщень
        function renderNotifyUsersCheckboxes(taskId) {
            const container = document.getElementById('taskNotifyUsers');
            if (!container) return;
            
            const sortedUsers = [...users].sort((a, b) => {
                const roleOrder = { owner: 0, manager: 1, employee: 2 };
                return (roleOrder[a.role] || 2) - (roleOrder[b.role] || 2);
            });
            
            const uid = 'taskNotifyUsers_ms';
            container.innerHTML = `
                <div class="user-multiselect" id="${uid}" style="position:relative;width:100%;">
                    <div class="user-ms-toggle" onclick="toggleUserMultiSelect('${uid}')" 
                         style="display:flex;align-items:center;justify-content:space-between;padding:0.5rem 0.75rem;background:white;border:1px solid #d1d5db;border-radius:8px;cursor:pointer;font-size:0.85rem;min-height:38px;transition:border-color 0.2s;">
                        <span class="user-ms-label" style="color:#9ca3af;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;flex:1;">Оберіть...</span>
                        <span style="color:#9ca3af;margin-left:0.5rem;display:flex;align-items:center;gap:0.3rem;">
                            <span style="background:#22c55e;color:white;font-size:0.7rem;padding:1px 6px;border-radius:10px;font-weight:600;display:none;">0</span>
                            <i data-lucide="chevron-down" class="icon" style="width:14px;height:14px;"></i>
                        </span>
                    </div>
                    <div class="user-ms-dropdown" style="display:none;position:absolute;top:100%;left:0;right:0;margin-top:4px;background:white;border:1px solid #e5e7eb;border-radius:10px;box-shadow:0 8px 24px rgba(0,0,0,0.12);z-index:200;max-height:240px;overflow:hidden;">
                        <div style="padding:0.4rem;border-bottom:1px solid #f3f4f6;">
                            <input type="text" placeholder="Пошук..." 
                                   oninput="filterUserMultiSelect('${uid}', this.value)"
                                   style="width:100%;padding:0.4rem 0.6rem;border:1px solid #e5e7eb;border-radius:6px;font-size:0.82rem;outline:none;" 
                                   onfocus="this.style.borderColor='#22c55e'" onblur="this.style.borderColor='#e5e7eb'">
                        </div>
                        <div class="user-ms-list" style="overflow-y:auto;max-height:190px;padding:0.25rem;">
                            ${sortedUsers.map(user => {
                                const roleIcon = user.role === 'owner' ? '👑 ' : user.role === 'manager' ? '⭐ ' : '';
                                return `<label class="user-ms-item" data-name="${esc((user.name || user.email).toLowerCase())}" 
                                                style="display:flex;align-items:center;gap:0.5rem;padding:0.45rem 0.6rem;cursor:pointer;border-radius:6px;font-size:0.84rem;transition:background 0.1s;" 
                                                onmouseover="if(!this.querySelector('input').checked)this.style.background='#f9fafb'" 
                                                onmouseout="if(!this.querySelector('input').checked)this.style.background=''">
                                    <input type="checkbox" name="notifyUser" value="${esc(user.id)}" 
                                           style="width:16px;height:16px;accent-color:#22c55e;flex-shrink:0;" 
                                           onchange="onUserMultiSelectChange('${uid}','taskNotifyUsers')">
                                    <span>${roleIcon}${esc(user.name || user.email)}</span>
                                </label>`;
                            }).join('')}
                        </div>
                    </div>
                </div>
            `;
            refreshIcons();
        }
        
        function updateNotifyCheckboxStyle(checkbox) {
            const label = checkbox.closest('.notify-user-checkbox');
            if (label) {
                label.style.background = checkbox.checked ? '#f0fdf4' : 'white';
                label.style.borderColor = checkbox.checked ? '#22c55e' : '#e5e7eb';
            }
        }
        
        // Встановлюємо вибрані чекбокси
        function setNotifyUsersCheckboxes(userIds) {
            const container = document.getElementById('taskNotifyUsers');
            if (!container) return;
            
            container.querySelectorAll('input[name="notifyUser"]').forEach(cb => {
                cb.checked = userIds.includes(cb.value);
                const item = cb.closest('.user-ms-item');
                if (item) item.style.background = cb.checked ? '#f0fdf4' : '';
            });
            // Update label
            onUserMultiSelectChange('taskNotifyUsers_ms', 'taskNotifyUsers');
        }
        
        // Отримуємо вибраних користувачів
        function getNotifyUsersFromCheckboxes() {
            const container = document.getElementById('taskNotifyUsers');
            if (!container) return [];
            
            return Array.from(container.querySelectorAll('input[name="notifyUser"]:checked'))
                .map(cb => cb.value);
        }
        
        // =====================
        // REMINDERS FUNCTIONS
        // =====================
        
        // Отримуємо вибрані нагадування
        function getSelectedReminders() {
            const reminders = [];
            if (document.getElementById('taskReminder60')?.checked) reminders.push(60);
            if (document.getElementById('taskReminder30')?.checked) reminders.push(30);
            if (document.getElementById('taskReminder15')?.checked) reminders.push(15);
            return reminders;
        }
        
        // Встановлюємо чекбокси нагадувань
        function setRemindersCheckboxes(reminders) {
            const r60 = document.getElementById('taskReminder60');
            const r30 = document.getElementById('taskReminder30');
            const r15 = document.getElementById('taskReminder15');
            
            if (r60) r60.checked = reminders.includes(60);
            if (r30) r30.checked = reminders.includes(30);
            if (r15) r15.checked = reminders.includes(15);
        }
        
        // Рендеримо чекбокси для контролю (notifyOnReminder)
        function renderNotifyReminderCheckboxes() {
            const container = document.getElementById('taskNotifyReminder');
            if (!container) return;
            
            const managers = users.filter(u => u.role === 'owner' || u.role === 'manager');
            const uid = 'taskNotifyReminder_ms';
            
            container.innerHTML = `
                <div class="user-multiselect" id="${uid}" style="position:relative;width:100%;">
                    <div class="user-ms-toggle" onclick="toggleUserMultiSelect('${uid}')" 
                         style="display:flex;align-items:center;justify-content:space-between;padding:0.5rem 0.75rem;background:white;border:1px solid #d1d5db;border-radius:8px;cursor:pointer;font-size:0.85rem;min-height:38px;transition:border-color 0.2s;">
                        <span class="user-ms-label" style="color:#9ca3af;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;flex:1;">Оберіть...</span>
                        <span style="color:#9ca3af;margin-left:0.5rem;display:flex;align-items:center;gap:0.3rem;">
                            <span style="background:#22c55e;color:white;font-size:0.7rem;padding:1px 6px;border-radius:10px;font-weight:600;display:none;">0</span>
                            <i data-lucide="chevron-down" class="icon" style="width:14px;height:14px;"></i>
                        </span>
                    </div>
                    <div class="user-ms-dropdown" style="display:none;position:absolute;top:100%;left:0;right:0;margin-top:4px;background:white;border:1px solid #e5e7eb;border-radius:10px;box-shadow:0 8px 24px rgba(0,0,0,0.12);z-index:200;max-height:200px;overflow:hidden;">
                        <div class="user-ms-list" style="overflow-y:auto;max-height:190px;padding:0.25rem;">
                            ${managers.map(user => {
                                const roleIcon = user.role === 'owner' ? '👑 ' : '⭐ ';
                                return `<label class="user-ms-item" data-name="${esc((user.name || user.email).toLowerCase())}" 
                                                style="display:flex;align-items:center;gap:0.5rem;padding:0.45rem 0.6rem;cursor:pointer;border-radius:6px;font-size:0.84rem;transition:background 0.1s;" 
                                                onmouseover="if(!this.querySelector('input').checked)this.style.background='#f9fafb'" 
                                                onmouseout="if(!this.querySelector('input').checked)this.style.background=''">
                                    <input type="checkbox" name="notifyReminder" value="${esc(user.id)}" 
                                           style="width:16px;height:16px;accent-color:#22c55e;flex-shrink:0;" 
                                           onchange="onUserMultiSelectChange('${uid}','taskNotifyReminder')">
                                    <span>${roleIcon}${esc(user.name || user.email)}</span>
                                </label>`;
                            }).join('')}
                        </div>
                    </div>
                </div>
            `;
            refreshIcons();
        }
        
        // Встановлюємо чекбокси контролю
        function setNotifyReminderCheckboxes(userIds) {
            const container = document.getElementById('taskNotifyReminder');
            if (!container) return;
            
            container.querySelectorAll('input[name="notifyReminder"]').forEach(cb => {
                cb.checked = userIds.includes(cb.value);
                const item = cb.closest('.user-ms-item');
                if (item) item.style.background = cb.checked ? '#f0fdf4' : '';
            });
            onUserMultiSelectChange('taskNotifyReminder_ms', 'taskNotifyReminder');
        }
        
        // Отримуємо вибраних для контролю
        function getNotifyReminderFromCheckboxes() {
            const container = document.getElementById('taskNotifyReminder');
            if (!container) return [];
            
            return Array.from(container.querySelectorAll('input[name="notifyReminder"]:checked'))
                .map(cb => cb.value);
        }

        async function saveTask(e) {
            e.preventDefault();
            
            // Захист від подвійного збереження
            if (isSaving) return;
            
            // Rate limiting
            if (!rateLimiter.check('saveTask')) {
                alert(t('tooManyRequests'));
                return;
            }
            
            // Збираємо дані для валідації
            const taskData = {
                title: document.getElementById('taskTitle').value.trim(),
                deadlineDate: document.getElementById('taskDeadlineDate').value,
                deadlineTime: document.getElementById('taskDeadlineTime').value,
                description: document.getElementById('taskDescription').value.trim()
            };
            
            // Валідація
            const errors = validateTaskData(taskData);
            if (errors.length > 0) {
                alert(errors.join('\n'));
                return;
            }
            
            isSaving = true;
            
            // Копіюємо editingId локально щоб уникнути race condition
            const currentEditingId = editingId;
            
            const submitBtn = e.target.querySelector('button[type="submit"]');
            const originalText = submitBtn?.innerHTML;
            if (submitBtn) {
                submitBtn.disabled = true;
                submitBtn.innerHTML = '<span class="spinner" style="width:16px;height:16px;border-width:2px;"></span>';
            }
            
            try {
                const assigneeId = document.getElementById('taskAssignee').value;
                const assignee = users.find(u => u.id === assigneeId);
                const deadlineDate = document.getElementById('taskDeadlineDate').value;
                const deadlineTime = document.getElementById('taskDeadlineTime').value;
                const timeMode = document.getElementById('taskTimeMode').value;
                const timeEnd = timeMode === 'end' 
                    ? document.getElementById('taskTimeEnd').value 
                    : calculateEndTime(deadlineTime, parseInt(document.getElementById('taskEstimatedTime').value || '60'));
                const duration = timeMode === 'duration' 
                    ? parseInt(document.getElementById('taskEstimatedTime').value || '60') 
                    : null;
                
                const statusVal = document.getElementById('taskStatus').value;
                const data = {
                    title: document.getElementById('taskTitle').value.trim(),
                    function: document.getElementById('taskFunction').value,
                    projectId: document.getElementById('taskProject')?.value || '',
                    assigneeId: assigneeId,
                    assigneeName: assignee?.name || assignee?.email || '',
                    deadlineDate: deadlineDate,
                    deadlineTime: deadlineTime,
                    timeEnd: timeEnd,
                    duration: duration,
                    deadline: deadlineDate + 'T' + deadlineTime, // для сумісності
                    estimatedTime: document.getElementById('taskEstimatedTime').value,
                    priority: document.getElementById('taskPriority').value,
                    status: statusVal,
                    expectedResult: document.getElementById('taskExpectedResult').value.trim(),
                    reportFormat: document.getElementById('taskReportFormat').value.trim(),
                    description: document.getElementById('taskDescription').value.trim(),
                    notifyOnComplete: getNotifyUsersFromCheckboxes(),
                    // Нові поля для сповіщень
                    reminders: getSelectedReminders(),
                    escalationEnabled: document.getElementById('taskEscalationEnabled').checked,
                    escalationMinutes: parseInt(document.getElementById('taskEscalationMinutes').value) || 60,
                    notifyOnReminder: getNotifyReminderFromCheckboxes(),
                    // FEAT-001: Співвиконавці та спостерігачі
                    coExecutorIds: getSelectedUsersFromCheckboxes('taskCoExecutors'),
                    observerIds: getSelectedUsersFromCheckboxes('taskObservers'),
                    // FEAT-003: Дата початку
                    startDate: document.getElementById('taskStartDate').value || null,
                    // FEAT-002+007: Toggles
                    requireReview: document.getElementById('taskRequireReview').checked,
                    allowDeadlineChange: document.getElementById('taskAllowDeadlineChange').checked,
                    // FEAT-001: Чеклист
                    checklist: getChecklistData(),
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                };
                
                // Status-dependent timestamps + review enforcement
                const existingForReview = currentEditingId ? tasks.find(t => t.id === currentEditingId) : null;
                if (statusVal === 'done' && existingForReview && shouldSendForReview(existingForReview)) {
                    // Задача потребує review — перенаправляємо
                    data.status = 'review';
                    data.sentForReviewAt = firebase.firestore.FieldValue.serverTimestamp();
                    data.completedAt = null;
                } else if (statusVal === 'done') {
                    data.completedAt = firebase.firestore.FieldValue.serverTimestamp();
                    data.completedBy = currentUser.uid;
                } else if (statusVal === 'review') {
                    data.sentForReviewAt = firebase.firestore.FieldValue.serverTimestamp();
                    data.completedAt = null;
                } else {
                    data.completedAt = null;
                }
                
                let newDocRef = null;
                let _prevProjectId = '';
                
                if (currentEditingId) {
                    // Update existing task
                    const existingTask = tasks.find(t => t.id === currentEditingId);
                    // Permission check: employee can only edit own tasks
                    if (existingTask && !canEditTask(existingTask)) {
                        showToast(t('noPermissionTask'), 'error');
                        isSaving = false;
                        if (submitBtn) { submitBtn.disabled = false; submitBtn.innerHTML = originalText; }
                        return;
                    }
                    // Зберігаємо попередній projectId для автостатусу
                    _prevProjectId = existingTask?.projectId || '';
                    
                    // Concurrency check: warn if another user modified this task
                    if (existingTask?._openedAt) {
                        try {
                            const freshDoc = await db.collection('companies').doc(currentCompany).collection('tasks').doc(currentEditingId).get();
                            const freshUpdated = freshDoc.data()?.updatedAt;
                            if (freshUpdated?.toMillis && freshUpdated.toMillis() > existingTask._openedAt) {
                                if (!confirm(t('taskModifiedByOther') || 'Task was modified by another user. Save anyway?')) {
                                    isSaving = false;
                                    if (submitBtn) { submitBtn.disabled = false; submitBtn.innerHTML = originalText; }
                                    return;
                                }
                            }
                        } catch(e) { /* proceed on error */ }
                    }
                    
                    await db.collection('companies').doc(currentCompany).collection('tasks').doc(currentEditingId).update(data);
                    
                    // AUDIT LOG — визначаємо що змінилось
                    if (existingTask) {
                        const trackedFields = ['title','status','assigneeId','deadlineDate','deadlineTime','priority','description','expectedResult','projectId','function','requireReview'];
                        const changes = {};
                        for (const f of trackedFields) {
                            if (String(data[f] ?? '') !== String(existingTask[f] ?? '')) {
                                changes[f] = data[f];
                            }
                        }
                        if (Object.keys(changes).length > 0) {
                            const action = changes.status ? 'status' : changes.assigneeId ? 'reassign' : changes.deadlineDate || changes.deadlineTime ? 'deadline' : 'edit';
                            logTaskChange(currentEditingId, action, changes, existingTask);
                        }
                    }
                    
                    // Sync with Google Calendar (non-blocking)
                    if (existingTask?.calendarEventId && googleAccessToken) {
                        updateCalendarEvent(existingTask.calendarEventId, data).catch(err => 
                            console.warn('[Calendar] Update sync failed:', err)
                        );
                    }
                } else {
                    // Create new task
                    data.createdAt = firebase.firestore.FieldValue.serverTimestamp();
                    data.createdDate = getLocalDateStr();
                    data.creatorId = currentUser.uid;
                    data.creatorName = currentUserData?.name || currentUser.email;
                    data.pinned = false;
                    
                    newDocRef = await db.collection('companies').doc(currentCompany).collection('tasks').add(data);
                    
                    // AUDIT LOG — створення задачі
                    logTaskChange(newDocRef.id, 'created', { title: data.title, assigneeId: data.assigneeId, deadlineDate: data.deadlineDate }, null);
                    
                    // Sync with Google Calendar (only if date is set)
                    if (deadlineDate && googleAccessToken) {
                        const calendarEventId = await createCalendarEvent(data);
                        if (calendarEventId) {
                            await newDocRef.update({ calendarEventId: calendarEventId });
                        }
                    }
                }
                
                closeModal('taskModal');
                
                // FIX 3: Warning якщо дедлайн задачі > дедлайн проєкту
                if (data.projectId && data.deadlineDate) {
                    const proj = projects.find(p => p.id === data.projectId);
                    if (proj?.deadline && data.deadlineDate > proj.deadline && data.status !== 'done') {
                        showToast(t('deadlineExceedsProject').replace('{taskDate}', formatDateShort(data.deadlineDate)).replace('{projName}', proj.name).replace('{projDate}', formatDateShort(proj.deadline)), 'warning');
                    }
                }
                
                // Автопросування процесу якщо завдання завершили через форму
                if (currentEditingId && data.status === 'done') {
                    advanceProcessIfLinked(currentEditingId);
                    // Delete calendar event when task completed
                    const completedTask = tasks.find(t => t.id === currentEditingId);
                    if (completedTask?.calendarEventId && googleAccessToken) {
                        deleteCalendarEvent(completedTask.calendarEventId).catch(() => {});
                    }
                }
                // Re-create calendar event when reopened from done via form
                if (currentEditingId && data.status !== 'done' && data.status !== 'review') {
                    const prevTask = tasks.find(t => t.id === currentEditingId);
                    if (prevTask?.status === 'done' && data.deadlineDate && googleAccessToken) {
                        createCalendarEvent(data).then(calId => {
                            if (calId) db.collection('companies').doc(currentCompany).collection('tasks').doc(currentEditingId).update({ calendarEventId: calId }).catch(() => {});
                        }).catch(() => {});
                    }
                }
                
                // Локальне оновлення замість повного перезавантаження
                if (currentEditingId) {
                    // Update — знаходимо і оновлюємо в масиві
                    const idx = tasks.findIndex(t => t.id === currentEditingId);
                    if (idx >= 0) {
                        // Прибираємо FieldValue sentinels перед локальним merge
                        const localData = { ...data };
                        delete localData.updatedAt;
                        delete localData.createdAt;
                        delete localData.completedAt;
                        delete localData.sentForReviewAt;
                        tasks[idx] = { ...tasks[idx], ...localData, id: currentEditingId };
                    }
                } else {
                    // Create — додаємо на початок масиву
                    if (!tasks.some(t => t.id === newDocRef.id)) tasks.unshift({ id: newDocRef.id, ...data, createdAt: new Date() });
                }
                
                // Перерендерюємо тільки потрібні views
                renderMyDay();
                refreshCurrentView();
                updateSelects();
                
                // Оновлюємо project detail якщо відкритий
                if (openProjectId) renderProjectDetail(openProjectId);
                
                // Автостатус проекту (оновити новий і старий проєкт)
                if (data.projectId) autoUpdateProjectStatus(data.projectId);
                if (_prevProjectId && _prevProjectId !== data.projectId) {
                    autoUpdateProjectStatus(_prevProjectId);
                }
                
            } catch (error) {
                console.error('saveTask error:', error);
                alert(t('error') + ': ' + error.message);
            } finally {
                isSaving = false;
                if (submitBtn) {
                    submitBtn.disabled = false;
                    submitBtn.innerHTML = originalText;
                }
            }
        }

        // =====================
        // VALIDATION & SECURITY
        // =====================
        
        // Санітизація HTML для захисту від XSS
        function deepCloneTask(task) {
            try { return structuredClone(task); } 
            catch(e) { return JSON.parse(JSON.stringify(task)); }
        }
        
        function sanitizeHTML(str) {
            if (!str) return '';
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }
        
        // Локальна дата у форматі YYYY-MM-DD (без UTC зсуву)
        function getLocalDateStr(d) {
            if (!d) d = new Date();
            const y = d.getFullYear();
            const m = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${y}-${m}-${day}`;
        }
        
        // Санітизація для відображення (escape HTML entities)
        function esc(str) {
            if (!str) return '';
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }
        
        // Alias для зворотної сумісності
        const escapeForDisplay = esc;
        
        // Escape ID для безпечної вставки в onclick='func("ID")'
        // Proper escaping замість видалення символів
        function escId(id) {
            if (!id) return '';
            return String(id)
                .replace(/\\/g, '\\\\')
                .replace(/'/g, "\\'")
                .replace(/"/g, '&quot;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
        }
        
        // Безпечний парсинг deadline — може бути string "2026-02-16T11:30", Firestore Timestamp, або undefined
        function parseDeadline(task) {
            let date = task.deadlineDate || '';
            let time = task.deadlineTime || '';
            if (!date && task.deadline) {
                if (task.deadline.toDate) {
                    const d = task.deadline.toDate();
                    date = getLocalDateStr(d);
                    if (!time) time = d.toTimeString().slice(0,5);
                } else if (typeof task.deadline === 'string') {
                    date = task.deadline.split('T')[0];
                    if (!time) time = task.deadline.split('T')[1]?.slice(0,5) || '';
                }
            }
            return { date, time };
        }
        
        // Одноразова міграція: якщо задача має deadline (Timestamp або string) але НЕ має deadlineDate —
        // парсимо deadline і дописуємо deadlineDate + deadlineTime в Firestore.
        // Працює в фоні, не блокує UI. Після міграції поле є — функція більше не спрацьовує.

        // Перевірка видимості задачі для поточного юзера
        // Owner/Manager бачать ВСЕ. Employee — тільки де він учасник.
        // Centralized permission check for task operations
        function canEditTask(task) {
            if (!currentUserData || !currentUser) return false;
            const role = currentUserData.role;
            if (role === 'owner' || role === 'admin' || role === 'manager') return true;
            const uid = currentUser.uid;
            return task.assigneeId === uid || task.creatorId === uid;
        }
        
        function isManagerOrAbove() {
            const role = currentUserData?.role;
            return role === 'owner' || role === 'admin' || role === 'manager' || role === 'superadmin';
        }
        
        // Safe batch wrapper — auto-splits at 450 operations (Firestore limit is 500)
        async function safeBatchCommit(operations) {
            const BATCH_LIMIT = 450;
            for (let i = 0; i < operations.length; i += BATCH_LIMIT) {
                const batch = db.batch();
                const chunk = operations.slice(i, i + BATCH_LIMIT);
                for (const op of chunk) {
                    if (op.type === 'set') batch.set(op.ref, op.data);
                    else if (op.type === 'update') batch.update(op.ref, op.data);
                    else if (op.type === 'delete') batch.delete(op.ref);
                }
                await batch.commit();
            }
        }
        
        let _visibleTaskIds = null;
        
        function _buildVisibleSet() {
            if (!currentUserData || !currentUser) return null;
            if (currentUserData.role === 'owner' || currentUserData.role === 'manager') return null;
            const uid = currentUser.uid;
            const s = new Set();
            for (const t of tasks) {
                if (t.assigneeId === uid || t.creatorId === uid || 
                    (t.coExecutorIds && t.coExecutorIds.includes(uid)) || 
                    (t.observerIds && t.observerIds.includes(uid))) {
                    s.add(t.id);
                }
            }
            return s;
        }
        
        function isTaskVisibleToUser(task) {
            if (!currentUserData || !currentUser) return true;
            if (currentUserData.role === 'owner' || currentUserData.role === 'manager') return true;
            if (_visibleTaskIds === null) _visibleTaskIds = _buildVisibleSet();
            if (_visibleTaskIds === null) return true;
            return _visibleTaskIds.has(task.id);
        }

        async function migrateDeadlineFields(base) {
            const toMigrate = tasks.filter(t => !t.deadlineDate && t.deadline);
            if (toMigrate.length === 0) return;
            
            console.log(`[Migration] ${toMigrate.length} tasks need deadlineDate migration`);
            
            const batch = db.batch();
            let count = 0;
            
            for (const task of toMigrate) {
                let date = '', time = '';
                try {
                    if (task.deadline.toDate) {
                        const d = task.deadline.toDate();
                        date = getLocalDateStr(d);
                        time = d.toTimeString().slice(0,5);
                    } else if (typeof task.deadline === 'string' && task.deadline.includes('T')) {
                        date = task.deadline.split('T')[0];
                        time = task.deadline.split('T')[1]?.slice(0,5) || '';
                    }
                } catch(e) { continue; }
                
                if (!date) continue;
                
                const ref = base.collection('tasks').doc(task.id);
                batch.update(ref, { deadlineDate: date, deadlineTime: time || '18:00' });
                
                // Оновлюємо локальний масив одразу
                task.deadlineDate = date;
                task.deadlineTime = time || '18:00';
                count++;
                
                if (count >= 400) break; // Firestore batch limit safety
            }
            
            if (count > 0) {
                try {
                    await batch.commit();
                    console.log(`[Migration] Done: ${count} tasks migrated`);
                } catch(e) {
                    console.warn('[Migration] Failed:', e);
                }
            }
        }
        
        // Валідація завдання
        function validateTaskData(data) {
            const errors = [];
            
            if (!data.title || data.title.trim().length === 0) {
                errors.push('Назва завдання обов\'язкова');
            } else if (data.title.length > 500) {
                errors.push('Назва занадто довга (макс. 500 символів)');
            }
            
            if (data.deadlineDate && !/^\d{4}-\d{2}-\d{2}$/.test(data.deadlineDate)) {
                errors.push('Невірний формат дати');
            }
            
            if (data.deadlineTime && !/^\d{2}:\d{2}$/.test(data.deadlineTime)) {
                errors.push('Невірний формат часу');
            }
            
            if (data.description && data.description.length > 10000) {
                errors.push('Опис занадто довгий (макс. 10000 символів)');
            }
            
            return errors;
        }
        
        // Валідація регулярного завдання
        function validateRegularTaskData(data) {
            const errors = [];
            
            if (!data.title || data.title.trim().length === 0) {
                errors.push('Назва завдання обов\'язкова');
            } else if (data.title.length > 500) {
                errors.push('Назва занадто довга (макс. 500 символів)');
            }
            
            if (!data.function) {
                errors.push('Функція обов\'язкова');
            }
            
            if (!data.timeStart || !/^\d{2}:\d{2}$/.test(data.timeStart)) {
                errors.push('Невірний час початку');
            }
            
            return errors;
        }
        
        // Валідація функції
        function validateFunctionData(data) {
            const errors = [];
            
            if (!data.name || data.name.trim().length === 0) {
                errors.push(t('functionNameRequired'));
            } else if (data.name.length > 200) {
                errors.push(t('functionNameTooLong'));
            } else {
                // Duplicate name check (exclude current editing function)
                const duplicate = functions.find(f => 
                    f.name.toLowerCase() === data.name.trim().toLowerCase() && 
                    f.id !== editingId && 
                    f.status !== 'archived'
                );
                if (duplicate) {
                    errors.push(t('functionNameDuplicate'));
                }
            }
            
            if (!data.headId) {
                errors.push(t('functionHeadRequired'));
            }
            
            return errors;
        }
        
        // Rate limiting
        const rateLimiter = {
            actions: {},
            limit: 10, // максимум дій
            window: 60000, // за 1 хвилину
            
            check(action) {
                const now = Date.now();
                if (!this.actions[action]) {
                    this.actions[action] = [];
                }
                
                // Видаляємо старі записи
                this.actions[action] = this.actions[action].filter(t => now - t < this.window);
                
                if (this.actions[action].length >= this.limit) {
                    return false; // Rate limit exceeded
                }
                
                this.actions[action].push(now);
                return true;
            }
        };
        
        // Undo system — stack для підтримки кількох послідовних видалень
        let deletedItemsStack = [];
        let undoTimeout = null;
        let undoTimerInterval = null;
        
        function showUndoToast(itemName, item, type) {
            // Додаємо в стек (а не перезаписуємо)
            deletedItemsStack.push({ item, type, name: itemName });
            
            const toast = document.getElementById('undoToast');
            const messageEl = document.getElementById('undoMessage');
            const timerBar = document.getElementById('undoTimerBar');
            
            // Показуємо останній видалений елемент + кількість в стеку
            if (deletedItemsStack.length > 1) {
                messageEl.textContent = `${itemName} (+${deletedItemsStack.length - 1} ще)`;
            } else {
                messageEl.textContent = itemName;
            }
            messageEl.title = deletedItemsStack.map(d => d.name).join(', ');
            timerBar.style.width = '100%';
            toast.classList.add('show');
            
            // Reset timers (перезапускаємо 5 сек від останнього видалення)
            if (undoTimeout) clearTimeout(undoTimeout);
            if (undoTimerInterval) clearInterval(undoTimerInterval);
            
            let timeLeft = 100;
            undoTimerInterval = setInterval(() => {
                timeLeft -= 2;
                timerBar.style.width = timeLeft + '%';
                if (timeLeft <= 0) clearInterval(undoTimerInterval);
            }, 100);
            
            undoTimeout = setTimeout(() => {
                hideUndoToast();
                deletedItemsStack = [];
            }, 5000);
        }
        
        function hideUndoToast() {
            document.getElementById('undoToast').classList.remove('show');
            if (undoTimerInterval) clearInterval(undoTimerInterval);
            if (undoTimeout) clearTimeout(undoTimeout);
        }
        
        async function undoDelete() {
            if (deletedItemsStack.length === 0) return;
            
            hideUndoToast();
            
            const itemsToRestore = [...deletedItemsStack];
            deletedItemsStack = [];
            
            let restored = 0;
            let failed = 0;
            
            // Очистка Firestore Timestamp-ів перед restore
            // Timestamp об'єкти при .set() записуються як nested objects замість timestamps
            function cleanForRestore(obj) {
                const clean = {};
                for (const [key, val] of Object.entries(obj)) {
                    if (key === 'id') continue; // id не зберігаємо в документі
                    if (val && typeof val === 'object' && typeof val.toDate === 'function') {
                        // Firestore Timestamp → JS Date → Firestore Timestamp
                        clean[key] = firebase.firestore.Timestamp.fromDate(val.toDate());
                    } else if (val && typeof val === 'object' && val.seconds !== undefined && val.nanoseconds !== undefined) {
                        // Серіалізований Timestamp без toDate
                        clean[key] = new firebase.firestore.Timestamp(val.seconds, val.nanoseconds);
                    } else if (Array.isArray(val)) {
                        // Рекурсивно обробляємо масиви
                        clean[key] = val.map(item => {
                            if (item && typeof item === 'object' && typeof item.toDate === 'function') {
                                return firebase.firestore.Timestamp.fromDate(item.toDate());
                            } else if (item && typeof item === 'object' && item.seconds !== undefined && item.nanoseconds !== undefined) {
                                return new firebase.firestore.Timestamp(item.seconds, item.nanoseconds);
                            } else if (item && typeof item === 'object' && !Array.isArray(item)) {
                                return cleanForRestore({ ...item, id: undefined });
                            }
                            return item;
                        });
                    } else if (val && typeof val === 'object' && !(val instanceof Date)) {
                        // Рекурсивно обробляємо вкладені об'єкти
                        clean[key] = cleanForRestore({ ...val, id: undefined });
                    } else {
                        clean[key] = val;
                    }
                }
                return clean;
            }
            
            for (const { item, type } of itemsToRestore) {
                try {
                    const cleanItem = cleanForRestore(item);
                    if (type === 'task') {
                        await db.collection('companies').doc(currentCompany).collection('tasks').doc(item.id).set(cleanItem);
                        if (!tasks.find(t => t.id === item.id)) {
                            tasks.unshift(item);
                        }
                    } else if (type === 'regularTask') {
                        await db.collection('companies').doc(currentCompany).collection('regularTasks').doc(item.id).set(cleanItem);
                        if (!regularTasks.find(t => t.id === item.id)) {
                            regularTasks.unshift(item);
                        }
                    } else if (type === 'function') {
                        await db.collection('companies').doc(currentCompany).collection('functions').doc(item.id).set(cleanItem);
                        if (!functions.find(f => f.id === item.id)) {
                            functions.unshift(item);
                        }
                    }
                    restored++;
                } catch (error) {
                    console.error('Undo error for item:', item.id, error);
                    failed++;
                }
            }
            
            // Re-render після всіх спроб (навіть якщо частина failed)
            renderMyDay();
            refreshCurrentView();
            if (currentRegularView === 'list') renderRegularTasks();
            else renderRegularWeekView();
            renderFunctions();
            updateSelects();
            
            // Автостатус проєктів для відновлених задач
            const affectedProjects = new Set();
            itemsToRestore.forEach(({ item, type }) => {
                if (type === 'task' && item.projectId) affectedProjects.add(item.projectId);
            });
            affectedProjects.forEach(pid => autoUpdateProjectStatus(pid));
            
            if (failed > 0) {
                alert(t('restorePartial').replace('{ok}', restored).replace('{total}', restored + failed).replace('{fail}', failed));
            } else if (restored > 0) {
                showToast(t('restoreSuccess').replace('{n}', restored), 'success');
            }
        }
        
        async function deleteTask(id) {
            const taskForDel = tasks.find(t => t.id === id);
            if (taskForDel && !canEditTask(taskForDel)) {
                showToast(t('noPermissionTask'), 'error');
                return;
            }

            const task = tasks.find(t => t.id === id);
            if (!task) return;
            
            const taskName = task.title || 'Завдання';
            
            // Prevent snapshot from re-inserting during async delete
            pendingDeleteIds.add(id);
            
            // Оптимістичне видалення — зберігаємо копію для rollback
            const taskCopy = { ...task };
            tasks = tasks.filter(t => t.id !== id);
            renderMyDay();
            refreshCurrentView();
            
            // Показуємо toast з можливістю undo
            showUndoToast(taskName, taskCopy, 'task');
            
            try {
                if (taskCopy.calendarEventId && googleAccessToken) {
                    deleteCalendarEvent(taskCopy.calendarEventId).catch(err => console.warn("[Calendar] Delete sync failed:", err));
                }
                
                await db.collection('companies').doc(currentCompany).collection('tasks').doc(id).delete();
                pendingDeleteIds.delete(id);
                // Автостатус проєкту після видалення задачі
                if (taskCopy.projectId) autoUpdateProjectStatus(taskCopy.projectId);
                // Note: audit log not needed for deletes — task doc is gone
            } catch (error) {
                pendingDeleteIds.delete(id);
                // Rollback — вставляємо назад (filter + unshift безпечно незалежно від змін масиву)
                if (!tasks.find(t => t.id === id)) {
                    tasks.unshift(taskCopy);
                }
                // Видаляємо цей елемент зі стеку undo (вже rollback-нутий)
                deletedItemsStack = deletedItemsStack.filter(d => d.item.id !== id);
                renderMyDay();
                refreshCurrentView();
                hideUndoToast();
                console.error('deleteTask error:', error);
                alert(t('error') + ': ' + error.message);
            }
        }

        async function togglePin(id) {
            const taskIndex = tasks.findIndex(x => x.id === id);
            if (taskIndex < 0) return;
            
            const originalPinned = tasks[taskIndex].pinned;
            
            // Оптимістичне оновлення
            tasks[taskIndex].pinned = !originalPinned;
            renderMyDay();
            refreshCurrentView();
            
            try {
                await db.collection('companies').doc(currentCompany).collection('tasks').doc(id).update({ pinned: !originalPinned });
            } catch (error) {
                // Rollback
                tasks[taskIndex].pinned = originalPinned;
                renderMyDay();
                refreshCurrentView();
                console.error('togglePin error:', error);
            }
        }

        // =====================
        // REVIEW SYSTEM (Перевірка постановником)
        // =====================
        
        // Визначаємо чи потрібна перевірка постановником
        function shouldSendForReview(task) {
            // Якщо постановник = виконавець — одразу done, без перевірки
            if (!task) return false;
            if (!task.creatorId) return false;
            if (task.creatorId === task.assigneeId) return false;
            if (task.creatorId === currentUser.uid) return false;
            // Автосгенеровані регулярні завдання — без перевірки
            if (task.autoGenerated) return false;
            // Per-task toggle: якщо явно вимкнено — без перевірки
            if (task.requireReview === false) return false;
            return true;
        }
        
        // Постановник приймає завдання
        // Review з модалки
        async function acceptReviewFromModal() {
            console.log('[acceptReview] editingId:', editingId);
            if (!editingId) { console.error('[acceptReview] No editingId!'); return; }
            const taskId = editingId;
            closeModal('taskModal');
            console.log('[acceptReview] calling acceptReviewTask:', taskId);
            await acceptReviewTask(taskId);
        }
        
        async function completeTaskFromModal() {
            if (!editingId) return;
            const taskId = editingId;
            closeModal('taskModal');
            await quickCompleteTask(taskId);
        }
        
        async function rejectReviewFromModal() {
            if (!editingId) return;
            const taskId = editingId;
            closeModal('taskModal');
            await rejectReviewTask(taskId);
        }
        
        async function reopenTaskFromModal() {
            if (!editingId) return;
            const taskId = editingId;
            const taskIndex = tasks.findIndex(t => t.id === taskId);
            if (taskIndex < 0) return;
            
            const originalTask = deepCloneTask(tasks[taskIndex]);
            tasks[taskIndex].status = 'progress';
            tasks[taskIndex].completedAt = null;
            closeModal('taskModal');
            renderMyDay();
            refreshCurrentView();
            
            try {
                await db.collection('companies').doc(currentCompany).collection('tasks').doc(taskId).update({
                    status: 'progress',
                    completedAt: null,
                    reopenedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    reopenedBy: currentUser.uid
                });
                showToast(t('taskReopened'), 'success');
                // Re-create calendar event if it was deleted on complete
                if (googleAccessToken && originalTask?.deadlineDate) {
                    createCalendarEvent(originalTask).then(id => {
                        if (id) db.collection('companies').doc(currentCompany).collection('tasks').doc(taskId).update({ calendarEventId: id }).catch(() => {});
                    }).catch(() => {});
                }
                // AUDIT LOG
                logTaskChange(taskId, 'reopen', { status: 'progress' }, { status: originalTask?.status || 'done' });
                // Автостатус проєкту
                if (originalTask?.projectId) autoUpdateProjectStatus(originalTask.projectId);
            } catch(e) {
                tasks[taskIndex] = originalTask;
                renderMyDay();
                refreshCurrentView();
                alert(t('error') + ': ' + e.message);
            }
        }
        
        async function acceptReviewTask(taskId) {
            const taskIndex = tasks.findIndex(t => t.id === taskId);
            if (taskIndex < 0) return;
            
            // Only creator or manager+ can accept review
            const task = tasks[taskIndex];
            if (task.creatorId !== currentUser?.uid && !isManagerOrAbove()) {
                showToast(t('noPermissionTask'), 'error');
                return;
            }
            
            const originalTask = deepCloneTask(tasks[taskIndex]);
            
            // Оптимістичне оновлення
            tasks[taskIndex].status = 'done';
            tasks[taskIndex].completedAt = new Date().toISOString();
            tasks[taskIndex].reviewedAt = new Date().toISOString();
            tasks[taskIndex].reviewedBy = currentUser.uid;
            renderMyDay();
            refreshCurrentView();
            
            try {
                if (originalTask.calendarEventId && googleAccessToken) {
                    deleteCalendarEvent(originalTask.calendarEventId).catch(err => console.warn("[Calendar] Delete sync failed:", err));
                }
                
                await db.collection('companies').doc(currentCompany).collection('tasks').doc(taskId).update({
                    status: 'done',
                    completedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    reviewedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    reviewedBy: currentUser.uid
                });
                
                // Автопросування процесу (review accepted = done)
                advanceProcessIfLinked(taskId);
                // Автостатус проекту
                const acceptedTask = tasks[taskIndex];
                if (acceptedTask?.projectId) autoUpdateProjectStatus(acceptedTask.projectId);
                // AUDIT LOG
                logTaskChange(taskId, 'review', { status: 'done' }, { status: 'review' });
                
                showToast(t('taskAccepted'), 'success');
            } catch (e) {
                tasks[taskIndex] = originalTask;
                renderMyDay();
                refreshCurrentView();
                alert(t('error') + ': ' + e.message);
            }
        }
        
        // Постановник повертає на доопрацювання
        async function rejectReviewTask(taskId) {
            // Only creator or manager+ can reject review
            const taskForCheck = tasks.find(t => t.id === taskId);
            if (taskForCheck && taskForCheck.creatorId !== currentUser?.uid && !isManagerOrAbove()) {
                showToast(t('noPermissionTask'), 'error');
                return;
            }
            
            const reason = prompt(t('rejectReasonPlaceholder'));
            if (reason === null) return;
            
            const taskIndex = tasks.findIndex(t => t.id === taskId);
            if (taskIndex < 0) return;
            
            const originalTask = deepCloneTask(tasks[taskIndex]);
            
            // Оптимістичне оновлення
            tasks[taskIndex].status = 'progress';
            tasks[taskIndex].completedAt = null;
            tasks[taskIndex].reviewRejectedAt = new Date().toISOString();
            tasks[taskIndex].reviewRejectedBy = currentUser.uid;
            if (reason) tasks[taskIndex].reviewRejectReason = reason;
            renderMyDay();
            refreshCurrentView();
            
            try {
                const updateData = {
                    status: 'progress',
                    completedAt: null,
                    reviewRejectedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    reviewRejectedBy: currentUser.uid
                };
                if (reason) updateData.reviewRejectReason = reason;
                
                await db.collection('companies').doc(currentCompany).collection('tasks').doc(taskId).update(updateData);
                // AUDIT LOG
                logTaskChange(taskId, 'status', { status: updateData.status }, { status: 'review' });
                
                showToast(t('taskRejected'), 'warning');
            } catch (e) {
                tasks[taskIndex] = originalTask;
                renderMyDay();
                refreshCurrentView();
                alert(t('error') + ': ' + e.message);
            }
        }
        
        // =====================
        // FEAT-006: TIME TRACKING
        // =====================
        let timeTrackerInterval = null;
        let timeTrackerStart = null;
        let timeTrackerTaskId = null;
        
        function toggleTimeTracker() {
            if (!editingId) return;
            
            if (timeTrackerInterval) {
                // СТОП
                stopTimeTracker();
            } else {
                // СТАРТ
                timeTrackerStart = Date.now();
                timeTrackerTaskId = editingId;
                const btn = document.getElementById('timeTrackBtn');
                btn.style.background = '#ef4444';
                btn.innerHTML = '<i data-lucide="square" class="icon icon-sm"></i> <span>Стоп</span>';
                refreshIcons();
                
                timeTrackerInterval = setInterval(() => {
                    if (!timeTrackerStart) return;
                    const elapsed = Math.floor((Date.now() - timeTrackerStart) / 1000);
                    const mins = Math.floor(elapsed / 60);
                    const secs = elapsed % 60;
                    document.getElementById('timeTrackActual').textContent = formatTrackedTime(getTotalTrackedMinutes() + mins) + ':' + String(secs).padStart(2, '0').slice(-2);
                }, 1000);
            }
        }
        
        function stopTimeTracker() {
            if (!timeTrackerStart || !timeTrackerTaskId) return;
            
            const elapsed = Math.round((Date.now() - timeTrackerStart) / 60000); // хвилини
            clearInterval(timeTrackerInterval);
            timeTrackerInterval = null;
            
            const btn = document.getElementById('timeTrackBtn');
            btn.style.background = '#22c55e';
            btn.innerHTML = '<i data-lucide="play" class="icon icon-sm"></i> <span data-i18n="startTimer">Старт</span>';
            refreshIcons();
            
            if (elapsed >= 1) {
                addTimeEntry(elapsed);
            }
            
            timeTrackerStart = null;
        }
        
        function addManualTime() {
            if (!editingId) return;
            const minutes = prompt(t('howManyMinutes'));
            if (minutes === null) return;
            const mins = parseInt(minutes);
            if (isNaN(mins) || mins <= 0) return;
            addTimeEntry(mins);
        }
        
        async function addTimeEntry(minutes) {
            const taskId = editingId; // copy to avoid race condition
            const task = tasks.find(t => t.id === taskId);
            if (!task || !taskId) return;
            
            const entry = {
                minutes: minutes,
                userId: currentUser.uid,
                userName: currentUserData?.name || currentUser.email,
                date: new Date().toISOString()
            };
            
            const timeLog = [...(task.timeLog || []), entry];
            
            try {
                await db.collection('companies').doc(currentCompany).collection('tasks').doc(taskId).update({
                    timeLog: timeLog
                });
                task.timeLog = timeLog;
                renderTimeTracking(task);
            } catch (e) {
                console.error('addTimeEntry error:', e);
                showToast(t('error') + ': ' + e.message, 'error');
            }
        }
        
        function getTotalTrackedMinutes() {
            const task = tasks.find(t => t.id === editingId);
            if (!task || !task.timeLog) return 0;
            return task.timeLog.reduce((sum, e) => sum + (e.minutes || 0), 0);
        }
        
        function formatTrackedTime(totalMinutes) {
            const h = Math.floor(totalMinutes / 60);
            const m = totalMinutes % 60;
            return `${h}:${String(m).padStart(2, '0')}`;
        }
        
        function renderTimeTracking(task) {
            const section = document.getElementById('timeTrackingSection');
            if (!section) return;
            
            // Показуємо тільки при редагуванні
            section.style.display = editingId ? 'block' : 'none';
            
            // Запланований час
            const planned = task?.estimatedTime ? parseInt(task.estimatedTime) : 0;
            document.getElementById('timeTrackPlanned').textContent = planned > 0 
                ? formatTrackedTime(planned) : '—';
            
            // Фактичний час
            const total = task?.timeLog ? task.timeLog.reduce((s, e) => s + (e.minutes || 0), 0) : 0;
            const actualEl = document.getElementById('timeTrackActual');
            actualEl.textContent = formatTrackedTime(total);
            
            // Колір: зелений якщо < план, жовтий якщо ~, червоний якщо >
            if (planned > 0 && total > planned * 1.2) {
                actualEl.style.color = '#ef4444';
            } else if (planned > 0 && total > planned * 0.8) {
                actualEl.style.color = '#f59e0b';
            } else {
                actualEl.style.color = '#22c55e';
            }
            
            // Лог
            const logEl = document.getElementById('timeTrackLog');
            if (task?.timeLog && task.timeLog.length > 0) {
                logEl.innerHTML = task.timeLog.slice(-10).reverse().map(e => {
                    const date = new Date(e.date);
                    const dateStr = date.toLocaleDateString('uk-UA', { day: 'numeric', month: 'short' });
                    const timeStr = date.toLocaleTimeString('uk-UA', { hour: '2-digit', minute: '2-digit' });
                    return `<div style="padding:2px 0;border-bottom:1px solid #f3f4f6;">${esc(e.userName)}: <strong>${esc(String(e.minutes || 0))} хв</strong> — ${esc(dateStr)} ${esc(timeStr)}</div>`;
                }).join('');
            } else {
                logEl.innerHTML = '';
            }
        }
        
        // =====================
        // CHECKLIST
        // =====================
        let checklistCounter = 0;
        
        function addChecklistItem(text = '', checked = false) {
            checklistCounter++;
            const id = 'cl_' + checklistCounter;
            const container = document.getElementById('taskChecklist');
            const item = document.createElement('div');
            item.id = id;
            item.style.cssText = 'display:flex;align-items:center;gap:0.5rem;margin-bottom:0.4rem;';
            item.innerHTML = `
                <input type="checkbox" ${checked ? 'checked' : ''} style="width:18px;height:18px;accent-color:var(--primary);flex-shrink:0;">
                <input type="text" value="${esc(text)}" placeholder="${t('checklistItemPlaceholder')}" 
                       style="flex:1;padding:0.4rem 0.5rem;border:1px solid #e5e7eb;border-radius:6px;font-size:0.85rem;"
                       onkeydown="if(event.key==='Enter'){event.preventDefault();addChecklistItem();this.parentElement.nextElementSibling?.querySelector('input[type=text]')?.focus();}">
                <button type="button" onclick="this.parentElement.remove()" style="background:none;border:none;cursor:pointer;color:#ef4444;padding:2px;">
                    <i data-lucide="x" class="icon icon-sm"></i>
                </button>
            `;
            container.appendChild(item);
            refreshIcons();
            // Фокус на нове поле
            if (!text) item.querySelector('input[type="text"]').focus();
        }
        
        function getChecklistData() {
            const items = [];
            document.querySelectorAll('#taskChecklist > div').forEach(item => {
                const checkbox = item.querySelector('input[type="checkbox"]');
                const textInput = item.querySelector('input[type="text"]');
                if (textInput && textInput.value.trim()) {
                    items.push({ text: textInput.value.trim(), done: checkbox?.checked || false });
                }
            });
            return items;
        }
        
        function renderChecklist(checklist) {
            const container = document.getElementById('taskChecklist');
            container.innerHTML = '';
            checklistCounter = 0;
            if (!checklist || !Array.isArray(checklist)) return;
            checklist.forEach(item => addChecklistItem(item.text, item.done));
        }
        
        // =====================
        // USER CHECKBOXES (co-executors, observers)
        // =====================
        function renderUserCheckboxes(containerId, selectedIds = []) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            const uid = containerId + '_ms';
            const selectedSet = new Set(selectedIds);
            
            // Count selected
            const selCount = selectedIds.length;
            const selNames = users.filter(u => selectedSet.has(u.id)).map(u => u.name || u.email).slice(0, 3).join(', ');
            const moreText = selCount > 3 ? ` +${selCount - 3}` : '';
            const btnLabel = selCount > 0 ? `${selNames}${moreText}` : 'Оберіть...';
            
            container.innerHTML = `
                <div class="user-multiselect" id="${uid}" style="position:relative;width:100%;">
                    <div class="user-ms-toggle" onclick="toggleUserMultiSelect('${uid}')" 
                         style="display:flex;align-items:center;justify-content:space-between;padding:0.5rem 0.75rem;background:white;border:1px solid #d1d5db;border-radius:8px;cursor:pointer;font-size:0.85rem;min-height:38px;transition:border-color 0.2s;">
                        <span class="user-ms-label" style="color:${selCount ? '#1a1a1a' : '#9ca3af'};overflow:hidden;text-overflow:ellipsis;white-space:nowrap;flex:1;">${esc(btnLabel)}</span>
                        <span style="color:#9ca3af;margin-left:0.5rem;display:flex;align-items:center;gap:0.3rem;">
                            ${selCount ? '<span style="background:#22c55e;color:white;font-size:0.7rem;padding:1px 6px;border-radius:10px;font-weight:600;">'+selCount+'</span>' : ''}
                            <i data-lucide="chevron-down" class="icon" style="width:14px;height:14px;"></i>
                        </span>
                    </div>
                    <div class="user-ms-dropdown" style="display:none;position:absolute;top:100%;left:0;right:0;margin-top:4px;background:white;border:1px solid #e5e7eb;border-radius:10px;box-shadow:0 8px 24px rgba(0,0,0,0.12);z-index:200;max-height:240px;overflow:hidden;">
                        <div style="padding:0.4rem;border-bottom:1px solid #f3f4f6;">
                            <input type="text" placeholder="Пошук..." 
                                   oninput="filterUserMultiSelect('${uid}', this.value)"
                                   style="width:100%;padding:0.4rem 0.6rem;border:1px solid #e5e7eb;border-radius:6px;font-size:0.82rem;outline:none;" 
                                   onfocus="this.style.borderColor='#22c55e'" onblur="this.style.borderColor='#e5e7eb'">
                        </div>
                        <div class="user-ms-list" style="overflow-y:auto;max-height:190px;padding:0.25rem;">
                            ${users.map(user => {
                                const checked = selectedSet.has(user.id);
                                const roleIcon = user.role === 'owner' ? '👑 ' : user.role === 'manager' ? '⭐ ' : '';
                                return `<label class="user-ms-item" data-name="${esc((user.name || user.email).toLowerCase())}" 
                                                style="display:flex;align-items:center;gap:0.5rem;padding:0.45rem 0.6rem;cursor:pointer;border-radius:6px;font-size:0.84rem;transition:background 0.1s;${checked ? 'background:#f0fdf4;' : ''}" 
                                                onmouseover="if(!this.querySelector('input').checked)this.style.background='#f9fafb'" 
                                                onmouseout="if(!this.querySelector('input').checked)this.style.background=''">
                                    <input type="checkbox" value="${user.id}" ${checked ? 'checked' : ''} 
                                           style="width:16px;height:16px;accent-color:#22c55e;flex-shrink:0;" 
                                           onchange="onUserMultiSelectChange('${uid}', '${containerId}')">
                                    <span>${roleIcon}${esc(user.name || user.email)}</span>
                                </label>`;
                            }).join('')}
                        </div>
                    </div>
                </div>
            `;
            refreshIcons();
        }
        
        function resetDropdownPosition(dd) {
            dd.style.position = 'absolute';
            dd.style.top = '100%';
            dd.style.bottom = '';
            dd.style.left = '0';
            dd.style.right = '0';
            dd.style.width = '';
            dd.style.zIndex = '200';
            dd.style.maxHeight = '';
            dd.style.marginTop = '4px';
        }
        
        function toggleUserMultiSelect(uid) {
            const wrap = document.getElementById(uid);
            if (!wrap) return;
            const dd = wrap.querySelector('.user-ms-dropdown');
            const toggle = wrap.querySelector('.user-ms-toggle');
            const isOpen = dd.style.display !== 'none';
            const isMobile = window.innerWidth < 768;
            
            // Close all other dropdowns
            document.querySelectorAll('.user-ms-dropdown').forEach(d => { d.style.display = 'none'; resetDropdownPosition(d); });
            document.querySelectorAll('.user-ms-toggle').forEach(t => t.style.borderColor = '#d1d5db');
            
            if (!isOpen) {
                if (isMobile) {
                    // Mobile: inline — просто розгортаємо під toggle (position:relative)
                    dd.style.position = 'relative';
                    dd.style.top = '';
                    dd.style.left = '';
                    dd.style.right = '';
                    dd.style.bottom = '';
                    dd.style.width = '100%';
                    dd.style.zIndex = '';
                    dd.style.maxHeight = '200px';
                    dd.style.marginTop = '4px';
                } else {
                    // Desktop: fixed to escape overflow clipping
                    const rect = toggle.getBoundingClientRect();
                    const spaceBelow = window.innerHeight - rect.bottom;
                    const ddHeight = 240;
                    
                    dd.style.position = 'fixed';
                    dd.style.left = rect.left + 'px';
                    dd.style.width = rect.width + 'px';
                    dd.style.zIndex = '9999';
                    dd.style.marginTop = '';
                    
                    if (spaceBelow >= ddHeight || spaceBelow >= rect.top) {
                        dd.style.top = rect.bottom + 4 + 'px';
                        dd.style.bottom = '';
                        dd.style.maxHeight = Math.min(ddHeight, spaceBelow - 8) + 'px';
                    } else {
                        dd.style.bottom = (window.innerHeight - rect.top + 4) + 'px';
                        dd.style.top = '';
                        dd.style.maxHeight = Math.min(ddHeight, rect.top - 8) + 'px';
                    }
                }
                
                dd.style.display = 'block';
                toggle.style.borderColor = '#22c55e';
                const inp = dd.querySelector('input[type="text"]');
                if (inp && !isMobile) setTimeout(() => inp.focus(), 50);
                
                // Close on outside click or scroll (desktop only)
                const closeHandler = (e) => {
                    if (!wrap.contains(e.target) && !dd.contains(e.target)) {
                        dd.style.display = 'none';
                        resetDropdownPosition(dd);
                        toggle.style.borderColor = '#d1d5db';
                        document.removeEventListener('click', closeHandler);
                        if (!isMobile) document.removeEventListener('scroll', scrollHandler, true);
                    }
                };
                const scrollHandler = (e) => {
                    if (dd.contains(e.target)) return;
                    dd.style.display = 'none';
                    resetDropdownPosition(dd);
                    toggle.style.borderColor = '#d1d5db';
                    document.removeEventListener('click', closeHandler);
                    document.removeEventListener('scroll', scrollHandler, true);
                };
                setTimeout(() => {
                    document.addEventListener('click', closeHandler);
                    if (!isMobile) document.addEventListener('scroll', scrollHandler, true);
                }, 10);
            }
        }
        
        function filterUserMultiSelect(uid, query) {
            const wrap = document.getElementById(uid);
            if (!wrap) return;
            const q = query.toLowerCase();
            wrap.querySelectorAll('.user-ms-item').forEach(item => {
                item.style.display = item.dataset.name.includes(q) ? 'flex' : 'none';
            });
        }
        
        function onUserMultiSelectChange(uid, containerId) {
            const wrap = document.getElementById(uid);
            if (!wrap) return;
            // Update toggle label
            const checked = Array.from(wrap.querySelectorAll('.user-ms-item input:checked'));
            const names = checked.map(cb => {
                const label = cb.closest('.user-ms-item');
                return label ? label.querySelector('span').textContent.trim() : '';
            });
            const count = checked.length;
            const labelEl = wrap.querySelector('.user-ms-label');
            if (count === 0) {
                labelEl.textContent = 'Оберіть...';
                labelEl.style.color = '#9ca3af';
            } else {
                labelEl.textContent = names.slice(0, 3).join(', ') + (count > 3 ? ` +${count - 3}` : '');
                labelEl.style.color = '#1a1a1a';
            }
            // Update counter badge
            const badge = wrap.querySelector('.user-ms-toggle');
            const existingBadge = badge.querySelector('span[style*="background:#22c55e"]');
            if (existingBadge) {
                if (count > 0) { existingBadge.textContent = count; existingBadge.style.display = ''; }
                else existingBadge.style.display = 'none';
            }
            // Update item bg
            wrap.querySelectorAll('.user-ms-item').forEach(item => {
                const cb = item.querySelector('input');
                item.style.background = cb.checked ? '#f0fdf4' : '';
            });
        }
        
        function getSelectedUsersFromCheckboxes(containerId) {
            const container = document.getElementById(containerId);
            if (!container) return [];
            return Array.from(container.querySelectorAll('input[type="checkbox"]:checked')).map(cb => cb.value);
        }
        
        // =====================
        // FEAT-007: Deadline change validation
        // =====================
        function canEditDeadline(task) {
            if (!task) return true;
            // Постановник завжди може
            if (task.creatorId === currentUser?.uid) return true;
            // Якщо дозволено виконавцю
            if (task.allowDeadlineChange) return true;
            // Адмін/овнер завжди може
            if (currentUserData?.role === 'owner' || currentUserData?.role === 'superadmin') return true;
            return false;
        }
        
        function showToast(message, type = 'success') {
            const existing = document.getElementById('simpleToast');
            if (existing) existing.remove();
            
            const colors = {
                success: { bg: 'linear-gradient(135deg, #22c55e, #16a34a)', shadow: 'rgba(34,197,94,0.4)' },
                warning: { bg: 'linear-gradient(135deg, #f59e0b, #d97706)', shadow: 'rgba(245,158,11,0.4)' },
                error: { bg: 'linear-gradient(135deg, #ef4444, #dc2626)', shadow: 'rgba(239,68,68,0.4)' },
                info: { bg: 'linear-gradient(135deg, #3b82f6, #2563eb)', shadow: 'rgba(59,130,246,0.4)' }
            };
            const c = colors[type] || colors.success;
            
            const toast = document.createElement('div');
            toast.id = 'simpleToast';
            toast.style.cssText = `
                position:fixed;top:20px;right:20px;background:${c.bg};color:white;
                padding:1rem 1.5rem;border-radius:12px;box-shadow:0 10px 40px ${c.shadow};
                z-index:10001;animation:slideInRight 0.3s ease;cursor:pointer;
                max-width:350px;font-weight:500;font-size:0.9rem;
            `;
            toast.textContent = message;
            toast.onclick = () => toast.remove();
            document.body.appendChild(toast);
            
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.style.animation = 'slideInRight 0.3s reverse';
                    setTimeout(() => toast.remove(), 300);
                }
            }, 4000);
        }
        
        // Listener для завдань на перевірці (сповіщення постановнику)
        let reviewTasksUnsubscribe = null;
        let knownReviewTaskIds = new Set();
        
        function initReviewTasksListener() {
            if (!currentCompany || !currentUser) return;
            
            if (reviewTasksUnsubscribe) {
                reviewTasksUnsubscribe();
            }
            
            let isFirstLoad = true;
            
            // Слухаємо завдання де поточний юзер — постановник, статус = review
            // УВАГА: Потрібен складений індекс в Firebase:
            // Collection: tasks, Fields: creatorId (Ascending), status (Ascending)
            reviewTasksUnsubscribe = db.collection('companies').doc(currentCompany)
                .collection('tasks')
                .where('creatorId', '==', currentUser.uid)
                .where('status', '==', 'review')
                .onSnapshot(snapshot => {
                    const currentIds = new Set(snapshot.docs.map(d => d.id));
                    
                    if (isFirstLoad) {
                        knownReviewTaskIds = currentIds;
                        isFirstLoad = false;
                        return;
                    }
                    
                    const newReviews = snapshot.docs.filter(doc => !knownReviewTaskIds.has(doc.id));
                    
                    if (newReviews.length > 0) {
                        newReviews.forEach(doc => {
                            const task = doc.data();
                            // Не сповіщаємо якщо сам собі поставив
                            if (task.assigneeId !== currentUser.uid) {
                                playNotificationSound();
                                showReviewTaskToast(task, doc.id);
                            }
                            // Інкрементальне оновлення
                            const idx = tasks.findIndex(t => t.id === doc.id);
                            if (idx >= 0) {
                                tasks[idx] = { ...tasks[idx], ...task, id: doc.id };
                            }
                        });
                        
                        scheduleRender();
                    }
                    
                    knownReviewTaskIds = currentIds;
                }, error => {
                    console.error('Review tasks listener error:', error);
                });
        }
        
        // Listener для повернених на доопрацювання (сповіщення виконавцю)
        let rejectedTasksUnsubscribe = null;
        let knownRejectedTimestamps = new Map();
        
        function initRejectedTasksListener() {
            if (!currentCompany || !currentUser) return;
            
            if (rejectedTasksUnsubscribe) {
                rejectedTasksUnsubscribe();
            }
            
            let isFirstLoad = true;
            
            // Слухаємо завдання де поточний юзер — виконавець, статус = progress
            // і є поле reviewRejectedAt (означає що повернули з перевірки)
            rejectedTasksUnsubscribe = db.collection('companies').doc(currentCompany)
                .collection('tasks')
                .where('assigneeId', '==', currentUser.uid)
                .where('status', '==', 'progress')
                .onSnapshot(snapshot => {
                    if (isFirstLoad) {
                        // Запамʼятовуємо поточні timestamp-и
                        snapshot.docs.forEach(doc => {
                            const data = doc.data();
                            if (data.reviewRejectedAt) {
                                knownRejectedTimestamps.set(doc.id, data.reviewRejectedAt);
                            }
                        });
                        isFirstLoad = false;
                        return;
                    }
                    
                    // Шукаємо нові повернення
                    snapshot.docs.forEach(doc => {
                        const data = doc.data();
                        if (data.reviewRejectedAt && data.reviewRejectedBy !== currentUser.uid) {
                            const prevTimestamp = knownRejectedTimestamps.get(doc.id);
                            if (data.reviewRejectedAt !== prevTimestamp) {
                                playNotificationSound();
                                const reason = data.reviewRejectReason;
                                const creatorName = data.creatorName || '';
                                const msg = `↩ ${creatorName} ${t('rejectedTaskMsg')}: ${data.title?.substring(0,30) || ''}${reason ? ' — ' + reason : ''}`;
                                showToast(msg, 'warning');
                                addNotification('rejected', t('taskReturnedForRevision') || 'Повернуто на доопрацювання', (data.creatorName || '') + ': ' + (data.title || ''), doc.id);
                                // Інкрементальне оновлення
                                const idx = tasks.findIndex(t => t.id === doc.id);
                                if (idx >= 0) {
                                    tasks[idx] = { ...tasks[idx], ...data, id: doc.id };
                                }
                                _coalesceMyDay = true;
                                _coalesceView = true;
                            }
                        }
                        if (data.reviewRejectedAt) {
                            knownRejectedTimestamps.set(doc.id, data.reviewRejectedAt);
                        }
                    });
                    // Batch render after processing all rejected tasks
                    if (_coalesceMyDay || _coalesceView) scheduleRender();
                }, error => {
                    console.error('Rejected tasks listener error:', error);
                });
        }
        
        function showReviewTaskToast(task, taskId) {
            // Add to notification center
            addNotification('review', t('taskForReview') || 'Завдання на перевірку', (task.assigneeName || '') + ': ' + (task.title || ''), taskId || null);
            
            const existingToast = document.getElementById('reviewTaskToast');
            if (existingToast) existingToast.remove();
            
            const assigneeName = task.assigneeName || '';
            const title = task.title || '';
            const shortTitle = title.length > 25 ? title.substring(0, 25) + '...' : title;
            
            const toast = document.createElement('div');
            toast.id = 'reviewTaskToast';
            toast.style.cssText = `
                position:fixed;top:80px;right:20px;background:linear-gradient(135deg,#8b5cf6,#7c3aed);
                color:white;padding:1rem 1.25rem;border-radius:12px;
                box-shadow:0 10px 40px rgba(139,92,246,0.4);z-index:10001;
                display:flex;flex-direction:column;gap:0.75rem;animation:slideInRight 0.3s ease;
                max-width:360px;width:calc(100% - 40px);
            `;
            toast.innerHTML = `
                <div style="display:flex;align-items:center;gap:0.75rem;">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M9 11l3 3L22 4"/><path d="M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11"/>
                    </svg>
                    <div style="flex:1;min-width:0;">
                        <div style="font-weight:600;"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align:-2px;"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg> ${t('taskOnReview')}</div>
                        <div style="font-size:0.85rem;opacity:0.9;">${esc(assigneeName)}: ${esc(shortTitle)}</div>
                    </div>
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" 
                         style="opacity:0.7;cursor:pointer;flex-shrink:0;" onclick="this.closest('#reviewTaskToast').remove()">
                        <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
                    </svg>
                </div>
                <div style="display:flex;gap:0.5rem;">
                    <button onclick="this.closest('#reviewTaskToast').remove();acceptReviewTask('${escId(taskId)}')" 
                            style="flex:1;padding:0.5rem;border:none;border-radius:8px;background:#22c55e;color:white;font-weight:600;cursor:pointer;font-size:0.85rem;">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align:-2px;"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg> ${t('acceptTask')}
                    </button>
                    <button onclick="this.closest('#reviewTaskToast').remove();rejectReviewTask('${escId(taskId)}')" 
                            style="flex:1;padding:0.5rem;border:none;border-radius:8px;background:rgba(255,255,255,0.2);color:white;font-weight:600;cursor:pointer;font-size:0.85rem;">
                        ↩ ${t('rejectTask')}
                    </button>
                </div>
            `;
            
            document.body.appendChild(toast);
            
            // Автоховаємо через 15 сек (більше часу бо потрібна дія)
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.style.animation = 'slideInRight 0.3s reverse';
                    setTimeout(() => toast.remove(), 300);
                }
            }, 15000);
        }

        // Mobile quick complete
        const completingTaskIds = new Set();
        const pendingDeleteIds = new Set(); // Prevent snapshot re-inserting during delete
        
        async function quickCompleteTask(id) {
            const taskForQC = tasks.find(t => t.id === id);
            if (taskForQC && !canEditTask(taskForQC)) {
                showToast(t('noPermissionTask'), 'error');
                return;
            }

            // Guard against double-tap
            if (completingTaskIds.has(id)) return;
            completingTaskIds.add(id);
            
            // Оптимістичне оновлення - миттєво показуємо результат
            const taskIndex = tasks.findIndex(t => t.id === id);
            const originalTask = taskIndex >= 0 ? deepCloneTask(tasks[taskIndex]) : null;
            
            // Визначаємо статус: review (якщо є постановник) або done
            const needsReview = shouldSendForReview(originalTask);
            const newStatus = needsReview ? 'review' : 'done';
            
            // Якщо потрібен звіт — показуємо modal перед завершенням
            if (requiresCompletionReport(originalTask)) {
                // Зберігаємо попередній статус для rollback
                if (taskIndex >= 0) {
                    tasks[taskIndex]._prevStatus = tasks[taskIndex].status;
                    tasks[taskIndex].status = newStatus;
                    renderMyDay();
                    refreshCurrentView();
                }
                showCompletionReport(id, () => doQuickComplete(id, taskIndex, originalTask, needsReview, newStatus));
                return;
            }
            
            doQuickComplete(id, taskIndex, originalTask, needsReview, newStatus);
        }
        
        async function doQuickComplete(id, taskIndex, originalTask, needsReview, newStatus) {
            if (taskIndex >= 0 && !tasks[taskIndex]._prevStatus) {
                tasks[taskIndex].status = newStatus;
                tasks[taskIndex].completedAt = new Date().toISOString();
                if (needsReview) tasks[taskIndex].sentForReviewAt = new Date().toISOString();
                renderMyDay();
                refreshCurrentView();
            }
            if (taskIndex >= 0) delete tasks[taskIndex]._prevStatus;
            
            try {
                // Delete from Google Calendar when completed
                if (originalTask?.calendarEventId && googleAccessToken && !needsReview) {
                    deleteCalendarEvent(originalTask.calendarEventId).catch(err => console.warn("[Calendar] Delete sync failed:", err));
                }
                
                const updateData = { 
                    status: newStatus,
                    completedAt: firebase.firestore.FieldValue.serverTimestamp()
                };
                if (needsReview) updateData.sentForReviewAt = firebase.firestore.FieldValue.serverTimestamp();
                
                await db.collection('companies').doc(currentCompany).collection('tasks').doc(id).update(updateData);
                
                // Автопросування процесу якщо завдання пов'язане
                if (!needsReview) {
                    advanceProcessIfLinked(id);
                }
                // Автостатус проєкту
                if (originalTask?.projectId) autoUpdateProjectStatus(originalTask.projectId);
                // AUDIT LOG
                logTaskChange(id, 'complete', { status: newStatus }, { status: originalTask?.status || 'todo' });
                
                if (needsReview) {
                    showToast(t('taskSentForReview'), 'info');
                }
            } catch (e) {
                // Rollback при помилці
                if (taskIndex >= 0 && originalTask) {
                    tasks[taskIndex] = originalTask;
                    renderMyDay();
                    refreshCurrentView();
                }
                alert(t('error') + ': ' + e.message);
            } finally {
                completingTaskIds.delete(id);
            }
        }
        
        // Reopen completed task
        async function reopenTask(id) {
            const taskForCheck = tasks.find(t => t.id === id);
            if (taskForCheck && !canEditTask(taskForCheck)) {
                showToast(t('noPermissionTask'), 'error');
                return;
            }
            
            // Оптимістичне оновлення
            const taskIndex = tasks.findIndex(t => t.id === id);
            const originalTask = taskIndex >= 0 ? deepCloneTask(tasks[taskIndex]) : null;
            
            if (taskIndex >= 0) {
                tasks[taskIndex].status = 'progress';
                tasks[taskIndex].completedAt = null;
                renderMyDay();
                refreshCurrentView();
            }
            
            try {
                await db.collection('companies').doc(currentCompany).collection('tasks').doc(id).update({ 
                    status: 'progress',
                    completedAt: null
                });
                // Автостатус проєкту (done→progress може змінити completed→active)
                if (originalTask?.projectId) autoUpdateProjectStatus(originalTask.projectId);
                // AUDIT LOG
                logTaskChange(id, 'reopen', { status: 'progress' }, { status: originalTask?.status || 'done' });
                showToast(t('taskReopened'), 'success');
                // Re-create calendar event
                if (googleAccessToken && originalTask?.deadlineDate) {
                    createCalendarEvent(originalTask).then(calId => {
                        if (calId) db.collection('companies').doc(currentCompany).collection('tasks').doc(id).update({ calendarEventId: calId }).catch(() => {});
                    }).catch(() => {});
                }
            } catch (e) {
                // Rollback при помилці
                if (taskIndex >= 0 && originalTask) {
                    tasks[taskIndex] = originalTask;
                    renderMyDay();
                    refreshCurrentView();
                }
                alert(t('error') + ': ' + e.message);
            }
        }

        // =====================
        // CALENDAR VIEW
        // =====================
        
        let currentCalendarView = 'day'; // day, week, month, list
        let calendarDate = new Date(); // Currently displayed date
        
        function getDayNames() {
            const d = { ua: ['Неділя', 'Понеділок', 'Вівторок', 'Середа', 'Четвер', 'Пʼятниця', 'Субота'],
                        ru: ['Воскресенье', 'Понедельник', 'Вторник', 'Среда', 'Четверг', 'Пятница', 'Суббота'],
                        pl: ['Niedziela', 'Poniedziałek', 'Wtorek', 'Środa', 'Czwartek', 'Piątek', 'Sobota'] };
            return d[currentLang] || d['ua'];
        }
        function getDayNamesShort() {
            const d = { ua: ['Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Нд'],
                        ru: ['Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Вс'],
                        pl: ['Pn', 'Wt', 'Śr', 'Czw', 'Pt', 'Sob', 'Nd'] };
            return d[currentLang] || d['ua'];
        }
        function getMonthNamesFull() {
            const m = { ua: ['Січень', 'Лютий', 'Березень', 'Квітень', 'Травень', 'Червень', 'Липень', 'Серпень', 'Вересень', 'Жовтень', 'Листопад', 'Грудень'],
                        ru: ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'],
                        pl: ['Styczeń', 'Luty', 'Marzec', 'Kwiecień', 'Maj', 'Czerwiec', 'Lipiec', 'Sierpień', 'Wrzesień', 'Październik', 'Listopad', 'Grudzień'] };
            return m[currentLang] || m['ua'];
        }
        
        // Для сумісності зі старим кодом
        let dayNames = getDayNames();
        let dayNamesShort = getDayNamesShort();
        let monthNames = getMonthNamesFull();
        
        function setCalendarView(view) {
            currentCalendarView = view;
            
            // Update buttons
            document.querySelectorAll('.calendar-view-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.view === view);
            });
            
            // Hide/show week strip (only useful for day view on mobile)
            const weekStrip = document.getElementById('mobileWeekStrip');
            if (weekStrip) {
                weekStrip.style.display = (view === 'day') ? '' : 'none';
            }
            
            // Hide calendar nav for kanban/deadlines/list (arrows make no sense)
            const calNavBtns = document.querySelector('.calendar-nav');
            if (calNavBtns) {
                calNavBtns.style.display = (view === 'kanban' || view === 'deadlines' || view === 'list') ? 'none' : '';
            }
            
            // Mobile filter bar — only in list view
            const mobileFilterBar = document.getElementById('mobileFilterBar');
            if (mobileFilterBar && window.innerWidth < 768) {
                mobileFilterBar.style.display = (view === 'list') ? '' : 'none';
            }
            
            // Calendar filters — only in calendar views (not list, not kanban)
            const calFilterRow = document.getElementById('calendarFiltersRow');
            if (calFilterRow) {
                const isCalView = (view !== 'list' && view !== 'kanban' && view !== 'deadlines' && window.innerWidth >= 768);
                calFilterRow.style.display = isCalView ? 'flex' : 'none';
            }
            
            // Show/hide containers
            const calendarContainer = document.getElementById('calendarContainer');
            const listContainer = document.getElementById('listContainer');
            
            if (view === 'list') {
                calendarContainer.classList.remove('active');
                listContainer.classList.add('active');
                listContainer.style.display = '';
                listContainer.style.minHeight = '';
                const tasksC = document.getElementById('tasksContainer');
                if (tasksC) tasksC.style.display = '';
                const totalTimeInfo = document.getElementById('totalTimeInfo');
                if (totalTimeInfo) totalTimeInfo.style.display = '';
                // Hide kanban
                const kanbanC = document.getElementById('kanbanContainer');
                if (kanbanC) kanbanC.style.display = 'none';
                // Reset archive view if it was open
                if (isArchiveView) {
                    isArchiveView = false;
                    document.getElementById('tasksContainer').style.display = '';
                    const filtersRow = document.querySelector('#listContainer .filters-row');
                    if (filtersRow) filtersRow.style.display = '';
                    const mobileFilterBar = document.getElementById('mobileFilterBar');
                    if (mobileFilterBar) mobileFilterBar.style.display = '';
                    const totalTimeInfo = document.getElementById('totalTimeInfo');
                    if (totalTimeInfo) totalTimeInfo.style.display = '';
                    document.getElementById('archiveContainer').style.display = 'none';
                    const archiveBtn = document.getElementById('archiveToggleBtn');
                    if (archiveBtn) {
                        archiveBtn.style.background = '#6b7280';
                        archiveBtn.innerHTML = '<i data-lucide="archive" class="icon"></i> <span>Архів</span>';
                    }
                }
                renderTasks();
                updateCalendarTitle();
            } else if (view === 'kanban' || view === 'deadlines') {
                calendarContainer.classList.remove('active');
                listContainer.classList.remove('active');
                // Show list filters row (reuse for kanban filtering)
                const listFiltersRow = document.querySelector('#listContainer .filters-row');
                if (listFiltersRow) {
                    listFiltersRow.style.display = '';
                    listFiltersRow.style.position = 'relative';
                    listFiltersRow.style.zIndex = '10';
                }
                listContainer.style.display = 'block';
                listContainer.style.minHeight = '0';
                const tasksC = document.getElementById('tasksContainer');
                if (tasksC) tasksC.style.display = 'none';
                const totalTimeInfo = document.getElementById('totalTimeInfo');
                if (totalTimeInfo) totalTimeInfo.style.display = 'none';
                
                let kanbanC = document.getElementById('kanbanContainer');
                if (!kanbanC) {
                    kanbanC = document.createElement('div');
                    kanbanC.id = 'kanbanContainer';
                    listContainer.parentNode.insertBefore(kanbanC, listContainer.nextSibling);
                }
                kanbanC.style.display = 'block';
                renderKanbanBoard(view);
                updateCalendarTitle();
            } else {
                calendarContainer.classList.add('active');
                listContainer.classList.remove('active');
                listContainer.style.display = '';
                listContainer.style.minHeight = '';
                const tasksC = document.getElementById('tasksContainer');
                if (tasksC) tasksC.style.display = '';
                const kanbanC = document.getElementById('kanbanContainer');
                if (kanbanC) kanbanC.style.display = 'none';
                renderCalendar();
            }
            
            // Save preference
            localStorage.setItem('calendarView', view);
        }
        
        function calendarPrev() {
            if (currentCalendarView === 'kanban' || currentCalendarView === 'deadlines' || currentCalendarView === 'list') return;
            if (currentCalendarView === 'day') {
                calendarDate.setDate(calendarDate.getDate() - 1);
            } else if (currentCalendarView === 'week') {
                calendarDate.setDate(calendarDate.getDate() - 7);
            } else if (currentCalendarView === 'month') {
                calendarDate.setMonth(calendarDate.getMonth() - 1);
            }
            renderCalendar();
        }
        
        function calendarNext() {
            if (currentCalendarView === 'kanban' || currentCalendarView === 'deadlines' || currentCalendarView === 'list') return;
            if (currentCalendarView === 'day') {
                calendarDate.setDate(calendarDate.getDate() + 1);
            } else if (currentCalendarView === 'week') {
                calendarDate.setDate(calendarDate.getDate() + 7);
            } else if (currentCalendarView === 'month') {
                calendarDate.setMonth(calendarDate.getMonth() + 1);
            }
            renderCalendar();
        }
        
        function calendarToday() {
            if (currentCalendarView === 'kanban' || currentCalendarView === 'deadlines' || currentCalendarView === 'list') return;
            calendarDate = new Date();
            renderCalendar();
        }
        
        function renderCalendar() {
            updateCalendarTitle();
            renderWeekStrip(); // Mobile week strip
            updateCalendarFilterUI();
            
            if (currentCalendarView === 'day') {
                renderDayView();
            } else if (currentCalendarView === 'week') {
                renderWeekView();
            } else if (currentCalendarView === 'month') {
                renderMonthView();
            }
            
            refreshIcons();
        }
        
        function getCalendarFilteredTasks() {
            const af = document.getElementById('calendarAssigneeFilter')?.value;
            const ff = document.getElementById('calendarFunctionFilter')?.value;
            return tasks.filter(task => {
                if (!isTaskVisibleToUser(task)) return false;
                if (af && task.assigneeId !== af) return false;
                if (ff && task.function !== ff) return false;
                return true;
            });
        }
        
        function filterCalendarMy() {
            const af = document.getElementById('calendarAssigneeFilter');
            if (af.value === currentUser?.uid) {
                af.value = '';
            } else {
                af.value = currentUser?.uid;
            }
            renderCalendar();
        }
        
        function updateCalendarFilterUI() {
            const af = document.getElementById('calendarAssigneeFilter')?.value;
            const ff = document.getElementById('calendarFunctionFilter')?.value;
            const myBtn = document.getElementById('calendarMyBtn');
            if (myBtn) {
                if (af === currentUser?.uid) {
                    myBtn.style.background = 'var(--primary)';
                    myBtn.style.color = 'white';
                    myBtn.style.borderColor = 'var(--primary)';
                } else {
                    myBtn.style.background = '';
                    myBtn.style.color = '';
                    myBtn.style.borderColor = '';
                }
            }
            const countEl = document.getElementById('calendarFilterCount');
            if (countEl) {
                if (af || ff) {
                    const filtered = getCalendarFilteredTasks().length;
                    countEl.textContent = `${filtered} / ${tasks.filter(t => isTaskVisibleToUser(t)).length}`;
                } else {
                    countEl.textContent = '';
                }
            }
        }
        
        // Mobile Week Strip (Google Calendar style)
        function renderWeekStrip() {
            const container = document.getElementById('weekStripDays');
            if (!container) return;
            
            const today = new Date();
            const todayStr = today.toDateString();
            const selectedStr = calendarDate.toDateString();
            
            // Get start of current week
            const weekStart = new Date(calendarDate);
            weekStart.setDate(calendarDate.getDate() - ((calendarDate.getDay() + 6) % 7));
            
            const shortDays = ['Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Нд'];
            
            let html = '';
            
            for (let i = 0; i < 7; i++) {
                const day = new Date(weekStart);
                day.setDate(weekStart.getDate() + i);
                const dayStr = getLocalDateStr(day);
                
                const isToday = day.toDateString() === todayStr;
                const isSelected = day.toDateString() === selectedStr;
                
                // Get tasks for this day
                const dayTasks = getCalendarFilteredTasks().filter(task => {
                    if (!task.deadline) return false;
                    const taskDate = task.deadline.toDate ? task.deadline.toDate() : new Date(task.deadline);
                    return getLocalDateStr(taskDate) === dayStr;
                });
                
                // Generate task dots (max 3)
                const taskDots = dayTasks.slice(0, 3).map(t => 
                    `<div class="task-dot status-${t.status}"></div>`
                ).join('');
                
                const classes = ['week-strip-day'];
                if (isToday) classes.push('today');
                if (isSelected) classes.push('selected');
                if (dayTasks.length > 0) classes.push('has-tasks');
                
                html += `
                    <div class="${classes.join(' ')}" onclick="selectWeekStripDay('${dayStr}')">
                        <div class="day-label">${shortDays[i]}</div>
                        <div class="day-num">${day.getDate()}</div>
                        <div class="task-dots">${taskDots}</div>
                    </div>
                `;
            }
            
            container.innerHTML = html;
        }
        
        function selectWeekStripDay(dateStr) {
            calendarDate = new Date(dateStr);
            renderCalendar();
        }
        
        function updateCalendarTitle() {
            const titleEl = document.getElementById('calendarTitle');
            const isMobile = window.innerWidth <= 767;
            
            if (currentCalendarView === 'day') {
                if (isMobile) {
                    // Mobile: just month and year like Google Calendar
                    titleEl.textContent = `${monthNames[calendarDate.getMonth()]} ${calendarDate.getFullYear()}`;
                } else {
                    titleEl.textContent = `${calendarDate.getDate()} ${monthNames[calendarDate.getMonth()]} ${calendarDate.getFullYear()}`;
                }
            } else if (currentCalendarView === 'week') {
                const weekStart = new Date(calendarDate);
                weekStart.setDate(calendarDate.getDate() - ((calendarDate.getDay() + 6) % 7));
                const weekEnd = new Date(weekStart);
                weekEnd.setDate(weekStart.getDate() + 6);
                
                if (weekStart.getMonth() === weekEnd.getMonth()) {
                    titleEl.textContent = `${weekStart.getDate()} - ${weekEnd.getDate()} ${monthNames[weekStart.getMonth()]} ${weekStart.getFullYear()}`;
                } else {
                    titleEl.textContent = `${weekStart.getDate()} ${monthNames[weekStart.getMonth()].slice(0,3)} - ${weekEnd.getDate()} ${monthNames[weekEnd.getMonth()].slice(0,3)} ${weekEnd.getFullYear()}`;
                }
            } else if (currentCalendarView === 'month') {
                titleEl.textContent = `${monthNames[calendarDate.getMonth()]} ${calendarDate.getFullYear()}`;
            } else if (currentCalendarView === 'list') {
                titleEl.textContent = `${monthNames[calendarDate.getMonth()]} ${calendarDate.getFullYear()}`;
            } else if (currentCalendarView === 'kanban') {
                titleEl.textContent = 'Канбан: Статуси';
            } else if (currentCalendarView === 'deadlines') {
                titleEl.textContent = 'Канбан: Терміни';
            }
        }
        
        // Mobile Agenda View (Apple Calendar Style)
        function renderMobileAgenda() {
            const agendaList = document.getElementById('agendaList');
            const agendaHeader = document.getElementById('agendaHeader');
            const agendaSubheader = document.getElementById('agendaSubheader');
            
            if (!agendaList) return;
            
            const today = new Date();
            const todayStr = today.toDateString();
            const selectedStr = calendarDate.toDateString();
            const dayStr = getLocalDateStr(calendarDate);
            
            // Set header
            const isToday = selectedStr === todayStr;
            const isTomorrow = calendarDate.toDateString() === new Date(today.getTime() + 86400000).toDateString();
            const isYesterday = calendarDate.toDateString() === new Date(today.getTime() - 86400000).toDateString();
            
            if (isToday) {
                agendaHeader.textContent = 'Сьогодні';
            } else if (isTomorrow) {
                agendaHeader.textContent = 'Завтра';
            } else if (isYesterday) {
                agendaHeader.textContent = 'Вчора';
            } else {
                agendaHeader.textContent = calendarDate.toLocaleDateString('uk-UA', { weekday: 'long', day: 'numeric', month: 'long' });
            }
            
            // Subheader with full date
            agendaSubheader.textContent = calendarDate.toLocaleDateString('uk-UA', { day: 'numeric', month: 'long', year: 'numeric' });
            
            // Get tasks for selected day
            const dayTasks = getCalendarFilteredTasks().filter(task => {
                if (!task.deadline) return false;
                const taskDate = task.deadline.toDate ? task.deadline.toDate() : new Date(task.deadline);
                return getLocalDateStr(taskDate) === dayStr;
            }).sort((a, b) => {
                const aDate = a.deadline?.toDate ? a.deadline.toDate() : new Date(a.deadline);
                const bDate = b.deadline?.toDate ? b.deadline.toDate() : new Date(b.deadline);
                return aDate - bDate;
            });
            
            if (dayTasks.length === 0) {
                agendaList.innerHTML = `
                    <div class="agenda-empty">
                        <div class="agenda-empty-icon"><i data-lucide="calendar" class="icon icon-xl"></i></div>
                        <div class="agenda-empty-text">${t('noTasksLabel')}</div>
                    </div>
                `;
                return;
            }
            
            let html = '';
            
            dayTasks.forEach(task => {
                const deadline = task.deadline?.toDate ? task.deadline.toDate() : new Date(task.deadline);
                const timeStr = deadline.toLocaleTimeString('uk-UA', { hour: '2-digit', minute: '2-digit' });
                const isDone = task.status === 'done';
                const durationStr = task.estimatedTime ? formatDuration(parseInt(task.estimatedTime)) : '';
                
                html += `
                    <div class="agenda-item ${isDone ? 'done' : ''}" onclick="showTaskQuickMenu(event, '${escId(task.id)}')">
                        <div class="agenda-item-color status-${task.status}"></div>
                        <div class="agenda-item-content">
                            <div class="agenda-item-title">${esc(task.title)}</div>
                            <div class="agenda-item-meta">
                                <span class="agenda-item-time">${timeStr}</span>
                                ${durationStr ? ` • ${durationStr}` : ''}
                                ${task.assigneeName ? ` • ${esc(task.assigneeName)}` : ''}
                            </div>
                        </div>
                        <div class="agenda-item-check" onclick="event.stopPropagation();toggleTaskFromAgenda('${escId(task.id)}')">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><polyline points="20 6 9 17 4 12"/></svg>
                        </div>
                    </div>
                `;
            });
            
            agendaList.innerHTML = html;
        }
        
        // Toggle task completion from agenda
        async function toggleTaskFromAgenda(taskId) {
            // Haptic feedback
            if (navigator.vibrate) navigator.vibrate(10);
            
            const taskIndex = tasks.findIndex(t => t.id === taskId);
            if (taskIndex < 0) return;
            
            const originalTask = deepCloneTask(tasks[taskIndex]);
            
            // Блокуємо toggle для review tasks — тільки постановник може accept/reject
            if (originalTask.status === 'review') {
                if (originalTask.creatorId === currentUser?.uid && originalTask.assigneeId !== currentUser?.uid) {
                    // Постановник — пропонуємо accept
                    acceptReviewTask(taskId);
                } else {
                    showToast(t('awaitingReview'), 'info');
                }
                return;
            }
            
            const needsReview = shouldSendForReview(originalTask);
            const newStatus = originalTask.status === 'done' 
                ? 'progress' 
                : (needsReview ? 'review' : 'done');
            
            // Оптимістичне оновлення
            tasks[taskIndex].status = newStatus;
            tasks[taskIndex].completedAt = newStatus === 'done' || newStatus === 'review' ? new Date().toISOString() : null;
            if (needsReview) tasks[taskIndex].sentForReviewAt = new Date().toISOString();
            renderMyDay();
            renderCalendar();
            
            try {
                if (newStatus === 'done' && originalTask.calendarEventId && googleAccessToken) {
                    deleteCalendarEvent(originalTask.calendarEventId).catch(err => console.warn("[Calendar] Delete sync failed:", err));
                }
                
                const updateData = {
                    status: newStatus,
                    completedAt: newStatus === 'done' || newStatus === 'review' ? firebase.firestore.FieldValue.serverTimestamp() : null
                };
                if (needsReview) updateData.sentForReviewAt = firebase.firestore.FieldValue.serverTimestamp();
                
                await db.collection('companies').doc(currentCompany).collection('tasks').doc(taskId).update(updateData);
                // AUDIT LOG
                logTaskChange(taskId, updateData.status === 'done' ? 'complete' : 'status', { status: updateData.status }, { status: originalTask?.status });
                
                if (needsReview) {
                    showToast(t('taskSentForReview'), 'info');
                }
                // Автостатус проєкту
                if (originalTask?.projectId) autoUpdateProjectStatus(originalTask.projectId);
            } catch (error) {
                // Rollback
                tasks[taskIndex] = originalTask;
                renderMyDay();
                renderCalendar();
                console.error('toggleTaskFromAgenda error:', error);
            }
        }
        
        function renderDayView() {
            // Hide other views
            document.getElementById('calendarDayView').style.display = 'block';
            document.getElementById('calendarWeekView').style.display = 'none';
            document.getElementById('calendarMonthView').style.display = 'none';
            
            // Render mobile agenda
            renderMobileAgenda();
            
            const today = new Date();
            const isToday = calendarDate.toDateString() === today.toDateString();
            
            // Update header
            const headerEl = document.getElementById('dayColumnHeader');
            headerEl.className = 'calendar-day-column-header' + (isToday ? ' today' : '');
            headerEl.innerHTML = `
                <div class="day-name">${dayNames[calendarDate.getDay()]}</div>
                <div class="day-number">${calendarDate.getDate()}</div>
            `;
            
            // Build time slots
            const timeSlotsEl = document.getElementById('calendarTimeSlots');
            const eventsContainerEl = document.getElementById('calendarEventsContainer');
            
            const dayStr = getLocalDateStr(calendarDate);
            
            let timeSlotsHTML = '';
            let hoursHTML = '';
            
            for (let hour = 0; hour < 24; hour++) {
                const timeStr = hour.toString().padStart(2, '0') + ':00';
                timeSlotsHTML += `<div class="calendar-time-slot">${timeStr}</div>`;
                hoursHTML += `<div class="calendar-hour-row" data-hour="${hour}" data-date="${dayStr}" onclick="openTaskAtTime('${dayStr}', ${hour})" ondragover="onHourDragOver(event)" ondragleave="onHourDragLeave(event)" ondrop="onHourDrop(event, '${dayStr}', ${hour})"></div>`;
            }
            
            timeSlotsEl.innerHTML = timeSlotsHTML;
            
            // Keep current time line
            const currentTimeLineHTML = '<div class="calendar-current-time" id="currentTimeLine" style="display:none;"></div>';
            eventsContainerEl.innerHTML = hoursHTML + currentTimeLineHTML;
            
            // Filter tasks for this day
            const dayTasks = getCalendarFilteredTasks().filter(task => {
                if (!task.deadline) return false;
                const taskDate = task.deadline.toDate ? task.deadline.toDate() : new Date(task.deadline);
                return getLocalDateStr(taskDate) === dayStr;
            });
            
            // Separate all-day and timed tasks
            const allDayTasks = [];
            const timedTasks = [];
            
            dayTasks.forEach(task => {
                const deadline = task.deadline.toDate ? task.deadline.toDate() : new Date(task.deadline);
                const hours = deadline.getHours();
                const minutes = deadline.getMinutes();
                
                // If task has no specific time (00:00) and no estimated time, treat as all-day
                if (hours === 0 && minutes === 0 && !task.estimatedTime) {
                    allDayTasks.push(task);
                } else {
                    timedTasks.push({ ...task, deadlineDate: deadline });
                }
            });
            
            // Render all-day section
            const alldayEl = document.getElementById('calendarAllday');
            if (allDayTasks.length > 0) {
                alldayEl.style.display = 'block';
                alldayEl.innerHTML = `
                    <div class="calendar-allday-label">${t('noTimeLabel')} (${allDayTasks.length})</div>
                    ${allDayTasks.map(task => `
                        <div class="calendar-allday-event calendar-event status-${task.status}" onclick="showTaskQuickMenu(event, '${escId(task.id)}')">
                            ${task.status === 'done' ? '<span style="margin-right:4px;"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" style="vertical-align:-2px;"><polyline points="20 6 9 17 4 12"/></svg></span>' : ''}
                            ${esc(task.title)}
                        </div>
                    `).join('')}
                `;
            } else {
                alldayEl.style.display = 'none';
            }
            
            // Render timed events
            timedTasks.forEach(task => {
                const deadline = task.deadlineDate;
                const startHour = deadline.getHours();
                const startMinute = deadline.getMinutes();
                
                // Calculate duration (use estimatedTime or default to 60 min)
                const durationMinutes = task.estimatedTime ? parseInt(task.estimatedTime) : 60;
                
                // Calculate position and height
                const topOffset = startHour * 60 + startMinute;
                const height = Math.max(durationMinutes, 20); // Minimum 20px height
                
                const eventHTML = `
                    <div class="calendar-event status-${task.status}" 
                         style="top: ${topOffset}px; height: ${height}px;"
                         onclick="showTaskQuickMenu(event, '${escId(task.id)}')"
                         draggable="true"
                         ondragstart="onTaskDragStart(event, '${escId(task.id)}')"
                         title="${esc(task.title)}">
                        ${task.status === 'done' ? '<div class="calendar-event-done-mark"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><polyline points="20 6 9 17 4 12"></polyline></svg></div>' : ''}
                        <div class="calendar-event-title">${esc(task.title)}</div>
                        <div class="calendar-event-time">${startHour.toString().padStart(2,'0')}:${startMinute.toString().padStart(2,'0')} • ${formatDuration(durationMinutes)}</div>
                    </div>
                `;
                eventsContainerEl.insertAdjacentHTML('beforeend', eventHTML);
            });
            
            // Show current time line if viewing today
            if (isToday) {
                updateCurrentTimeLine();
            }
        }
        
        function formatDuration(minutes) {
            if (minutes < 60) return `${minutes} хв`;
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            return mins > 0 ? `${hours} год ${mins} хв` : `${hours} год`;
        }
        
        function updateCurrentTimeLine() {
            const now = new Date();
            const today = new Date();
            const line = document.getElementById('currentTimeLine');
            if (!line) return;
            
            if (calendarDate.toDateString() !== today.toDateString()) {
                line.style.display = 'none';
                return;
            }
            
            const topOffset = now.getHours() * 60 + now.getMinutes();
            line.style.display = 'block';
            line.style.top = topOffset + 'px';
        }
        
        function renderWeekView() {
            document.getElementById('calendarDayView').style.display = 'none';
            document.getElementById('calendarWeekView').style.display = 'block';
            document.getElementById('calendarMonthView').style.display = 'none';
            
            const weekStart = new Date(calendarDate);
            weekStart.setDate(calendarDate.getDate() - ((calendarDate.getDay() + 6) % 7));
            
            const today = new Date();
            const todayStr = today.toDateString();
            
            // Build header
            const headerEl = document.getElementById('weekHeader');
            let headerHTML = '<div class="calendar-time-gutter"></div>';
            
            for (let i = 0; i < 7; i++) {
                const day = new Date(weekStart);
                day.setDate(weekStart.getDate() + i);
                const isToday = day.toDateString() === todayStr;
                
                headerHTML += `
                    <div class="calendar-week-day-header ${isToday ? 'today' : ''}">
                        <div class="day-name">${dayNamesShort[i]}</div>
                        <div class="day-number" ${isToday ? 'style="background:var(--primary);color:white;border-radius:50%;width:28px;height:28px;display:inline-flex;align-items:center;justify-content:center;"' : ''}>${day.getDate()}</div>
                    </div>
                `;
            }
            headerEl.innerHTML = headerHTML;
            
            // Build body with time slots
            const bodyEl = document.getElementById('weekBody');
            let bodyHTML = '<div class="calendar-time-slots">';
            
            for (let hour = 0; hour < 24; hour++) {
                bodyHTML += `<div class="calendar-time-slot">${hour.toString().padStart(2, '0')}:00</div>`;
            }
            bodyHTML += '</div>';
            
            // PRE-BUILD: date → tasks map for week (O(n) instead of O(7*n))
            const weekFilteredTasks = getCalendarFilteredTasks();
            const weekTasksByDate = {};
            weekFilteredTasks.forEach(task => {
                if (!task.deadline) return;
                const taskDate = task.deadline.toDate ? task.deadline.toDate() : new Date(task.deadline);
                const dateKey = getLocalDateStr(taskDate);
                if (!weekTasksByDate[dateKey]) weekTasksByDate[dateKey] = [];
                weekTasksByDate[dateKey].push(task);
            });
            
            // Build columns for each day
            for (let i = 0; i < 7; i++) {
                const day = new Date(weekStart);
                day.setDate(weekStart.getDate() + i);
                const dayStr = getLocalDateStr(day);
                
                bodyHTML += `<div class="calendar-week-day-column" data-date="${dayStr}">`;
                
                // Hour rows
                for (let hour = 0; hour < 24; hour++) {
                    bodyHTML += `<div class="calendar-hour-row" data-hour="${hour}" onclick="openTaskAtTime('${dayStr}', ${hour})" ondragover="onHourDragOver(event)" ondragleave="onHourDragLeave(event)" ondrop="onHourDrop(event, '${dayStr}', ${hour})"></div>`;
                }
                
                // Get tasks for this day (O(1) lookup)
                const dayTasks = weekTasksByDate[dayStr] || [];
                
                // Render events
                dayTasks.forEach(task => {
                    const deadline = task.deadline.toDate ? task.deadline.toDate() : new Date(task.deadline);
                    const startHour = deadline.getHours();
                    const startMinute = deadline.getMinutes();
                    const durationMinutes = task.estimatedTime ? parseInt(task.estimatedTime) : 60;
                    
                    const topOffset = startHour * 60 + startMinute;
                    const height = Math.max(durationMinutes, 20);
                    
                    bodyHTML += `
                        <div class="calendar-event status-${task.status}" 
                             style="position:absolute; top:${topOffset}px; height:${height}px; left:2px; right:2px;"
                             onclick="showTaskQuickMenu(event, '${escId(task.id)}')"
                             draggable="true"
                             ondragstart="onTaskDragStart(event, '${escId(task.id)}')"
                             title="${esc(task.title)}">
                            <div class="calendar-event-title" style="font-size:0.7rem;">${esc(task.title)}</div>
                        </div>
                    `;
                });
                
                bodyHTML += '</div>';
            }
            
            bodyEl.innerHTML = bodyHTML;
        }
        
        function renderMonthView() {
            document.getElementById('calendarDayView').style.display = 'none';
            document.getElementById('calendarWeekView').style.display = 'none';
            document.getElementById('calendarMonthView').style.display = 'block';
            
            // Оновлюємо заголовки днів тижня
            const monthDayNamesEl = document.getElementById('calendarMonthDayNames');
            if (monthDayNamesEl) {
                const shortDays = getDayNamesShort();
                monthDayNamesEl.innerHTML = shortDays.map(d => `<div class="calendar-month-day-name">${d}</div>`).join('');
            }
            
            const year = calendarDate.getFullYear();
            const month = calendarDate.getMonth();
            
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            const startDay = (firstDay.getDay() + 6) % 7; // Monday-based (0 = Monday)
            const daysInMonth = lastDay.getDate();
            
            const today = new Date();
            const todayStr = getLocalDateStr(today);
            
            // Get prev month's last days
            const prevMonthLastDay = new Date(year, month, 0).getDate();
            
            const bodyEl = document.getElementById('monthBody');
            let html = '';
            
            // PRE-BUILD: date → tasks map (O(n) instead of O(42*n))
            const filteredTasks = getCalendarFilteredTasks();
            const tasksByDate = {};
            filteredTasks.forEach(task => {
                if (!task.deadline) return;
                const taskDate = task.deadline.toDate ? task.deadline.toDate() : new Date(task.deadline);
                const dateKey = getLocalDateStr(taskDate);
                if (!tasksByDate[dateKey]) tasksByDate[dateKey] = [];
                tasksByDate[dateKey].push(task);
            });
            
            let dayCounter = 1;
            let nextMonthDay = 1;
            
            // Calculate total cells needed (6 weeks max)
            const totalCells = 42;
            
            for (let i = 0; i < totalCells; i++) {
                let dayNum, dateStr, isOtherMonth = false;
                
                if (i < startDay) {
                    // Previous month
                    dayNum = prevMonthLastDay - startDay + i + 1;
                    const prevMonth = month === 0 ? 11 : month - 1;
                    const prevYear = month === 0 ? year - 1 : year;
                    dateStr = `${prevYear}-${(prevMonth + 1).toString().padStart(2, '0')}-${dayNum.toString().padStart(2, '0')}`;
                    isOtherMonth = true;
                } else if (dayCounter <= daysInMonth) {
                    // Current month
                    dayNum = dayCounter;
                    dateStr = `${year}-${(month + 1).toString().padStart(2, '0')}-${dayNum.toString().padStart(2, '0')}`;
                    dayCounter++;
                } else {
                    // Next month
                    dayNum = nextMonthDay;
                    const nextMonth = month === 11 ? 0 : month + 1;
                    const nextYear = month === 11 ? year + 1 : year;
                    dateStr = `${nextYear}-${(nextMonth + 1).toString().padStart(2, '0')}-${dayNum.toString().padStart(2, '0')}`;
                    nextMonthDay++;
                    isOtherMonth = true;
                }
                
                const isToday = dateStr === todayStr;
                
                // Get tasks for this day (O(1) lookup from pre-built map)
                const dayTasks = tasksByDate[dateStr] || [];
                
                html += `
                    <div class="calendar-month-day ${isOtherMonth ? 'other-month' : ''} ${isToday ? 'today' : ''}" 
                         data-date="${dateStr}"
                         onclick="goToDay('${dateStr}')">
                        <div class="month-day-number">${dayNum}</div>
                        ${dayTasks.slice(0, 3).map(task => `
                            <div class="calendar-month-event status-${task.status}" 
                                 onclick="event.stopPropagation(); showTaskQuickMenu(event, '${escId(task.id)}')"
                                 title="${esc(task.title)}">
                                ${esc(task.title)}
                            </div>
                        `).join('')}
                        ${dayTasks.length > 3 ? `<div class="calendar-month-more">+${dayTasks.length - 3} ще</div>` : ''}
                    </div>
                `;
            }
            
            bodyEl.innerHTML = html;
        }
        
        function goToDay(dateStr) {
            calendarDate = new Date(dateStr);
            setCalendarView('day');
        }
        
        // Initialize calendar
        function initCalendar() {
            // Load saved view preference
            const savedView = localStorage.getItem('calendarView') || 'day';
            setCalendarView(savedView);
            
            // Гарантія: при list view calendarFiltersRow прихований
            if (savedView === 'list') {
                const cfr = document.getElementById('calendarFiltersRow');
                if (cfr) cfr.style.display = 'none';
            }
            
            // Generate time slots
            renderCalendar();
            
            // Update current time line every minute
            setInterval(updateCurrentTimeLine, 60000);
            
            // Setup swipe navigation for mobile
            setupCalendarSwipe();
        }
        
        // Swipe navigation for mobile calendar
        function setupCalendarSwipe() {
            const dayView = document.getElementById('calendarDayView');
            const weekView = document.getElementById('calendarWeekView');
            const weekStrip = document.getElementById('mobileWeekStrip');
            
            [dayView, weekView, weekStrip].forEach(view => {
                if (!view) return;
                
                let touchStartX = 0;
                let touchStartY = 0;
                let touchEndX = 0;
                let isSwiping = false;
                
                view.addEventListener('touchstart', (e) => {
                    touchStartX = e.changedTouches[0].screenX;
                    touchStartY = e.changedTouches[0].screenY;
                    isSwiping = true;
                }, { passive: true });
                
                view.addEventListener('touchmove', (e) => {
                    if (!isSwiping) return;
                    const diffY = Math.abs(e.changedTouches[0].screenY - touchStartY);
                    // Cancel swipe if scrolling vertically
                    if (diffY > 30) {
                        isSwiping = false;
                    }
                }, { passive: true });
                
                view.addEventListener('touchend', (e) => {
                    if (!isSwiping) return;
                    touchEndX = e.changedTouches[0].screenX;
                    handleCalendarSwipe(touchStartX, touchEndX, view === weekStrip);
                    isSwiping = false;
                }, { passive: true });
            });
        }
        
        function handleCalendarSwipe(startX, endX, isWeekStrip) {
            const swipeThreshold = 70;
            const diff = startX - endX;
            
            if (Math.abs(diff) < swipeThreshold) return;
            
            if (isWeekStrip) {
                // Swipe on week strip → change week
                if (diff > 0) {
                    calendarDate.setDate(calendarDate.getDate() + 7);
                } else {
                    calendarDate.setDate(calendarDate.getDate() - 7);
                }
                renderCalendar();
            } else {
                if (diff > 0) {
                    // Swipe left → next day/week
                    navigateCalendar(1);
                } else {
                    // Swipe right → prev day/week
                    navigateCalendar(-1);
                }
            }
        }
        
        function navigateCalendar(direction) {
            if (currentCalendarView === 'day') {
                calendarDate.setDate(calendarDate.getDate() + direction);
            } else if (currentCalendarView === 'week') {
                calendarDate.setDate(calendarDate.getDate() + (direction * 7));
            } else if (currentCalendarView === 'month') {
                calendarDate.setMonth(calendarDate.getMonth() + direction);
            }
            renderCalendar();
        }

        function handleDateFilter() {
            const df = document.getElementById('dateFilter').value;
            const customRange = document.getElementById('customDateRange');
            
            if (df === 'custom') {
                customRange.style.display = 'flex';
                // Встановлюємо значення за замовчуванням
                const today = getLocalDateStr();
                const weekLater = new Date();
                weekLater.setDate(weekLater.getDate() + 7);
                document.getElementById('dateFrom').value = today;
                document.getElementById('dateTo').value = getLocalDateStr(weekLater);
            } else {
                customRange.style.display = 'none';
            }
            renderTasks();
        }
        
        // =====================
        // MY DAY RENDERING
        // =====================
        function renderMyDay() {
            _visibleTaskIds = null; // Invalidate visibility cache
            const container = document.getElementById('mydayContent');
            if (!container) return;
            
            const today = new Date();
            const todayStr = getLocalDateStr(today);
            const todayDay = today.getDay();
            
            // Форматуємо дату
            const dayNames = getDayNames();
            const monthGenitive = { ua: ['січня', 'лютого', 'березня', 'квітня', 'травня', 'червня', 'липня', 'серпня', 'вересня', 'жовтня', 'листопада', 'грудня'],
                ru: ['января', 'февраля', 'марта', 'апреля', 'мая', 'июня', 'июля', 'августа', 'сентября', 'октября', 'ноября', 'декабря'],
                pl: ['stycznia', 'lutego', 'marca', 'kwietnia', 'maja', 'czerwca', 'lipca', 'sierpnia', 'września', 'października', 'listopada', 'grudnia'] };
            const monthNames = monthGenitive[currentLang] || monthGenitive['ua'];
            
            const dateText = `${dayNames[todayDay]}, ${today.getDate()} ${monthNames[today.getMonth()]}`;
            document.getElementById('mydayDateText').textContent = dateText;
            
            // Збираємо всі завдання на сьогодні для поточного користувача
            const myTasks = [];
            
            // PRE-BUILD: lookup maps для O(1) пошуку (замість O(n) find кожного разу)
            const myTaskIds = new Set();
            const funcByName = {};
            functions.forEach(f => { funcByName[f.name] = f; });
            
            // Index для швидкого пошуку згенерованих regular tasks
            const generatedTaskIndex = {};
            tasks.forEach(t => {
                if (t.regularTaskId && t.deadlineDate === todayStr && t.assigneeId === currentUser?.uid) {
                    // Зберігаємо перший знайдений (масив desc по createdAt → перший = найновіший)
                    if (!generatedTaskIndex[t.regularTaskId]) {
                        generatedTaskIndex[t.regularTaskId] = t;
                    }
                }
            });
            
            // 1. Разові завдання з дедлайном сьогодні або прострочені
            tasks.filter(t => {
                if (t.assigneeId !== currentUser.uid) return false;
                if (t.deadlineDate === todayStr) return true;
                if (t.deadlineDate < todayStr && t.status !== 'done' && t.status !== 'review') return true;
                return false;
            }).forEach(t => {
                myTaskIds.add(t.id);
                myTasks.push({
                    id: t.id,
                    title: t.title,
                    time: t.deadlineTime || '',
                    function: t.function || '',
                    type: 'task',
                    done: t.status === 'done',
                    review: t.status === 'review',
                    overdue: t.deadlineDate < todayStr && t.status !== 'done' && t.status !== 'review',
                    priority: t.priority || 'medium',
                    originalTask: t
                });
            });
            
            // 1.5. Завдання на перевірці де поточний юзер — постановник (не виконавець)
            tasks.filter(t => {
                if (t.status !== 'review') return false;
                if (t.creatorId !== currentUser.uid) return false;
                if (t.assigneeId === currentUser.uid) return false; // вже покриті вище
                // Не дублюємо якщо вже є в myTasks (O(1) Set lookup)
                return !myTaskIds.has(t.id);
            }).forEach(t => {
                myTasks.push({
                    id: t.id,
                    title: t.title,
                    time: t.deadlineTime || '',
                    function: t.function || '',
                    type: 'task',
                    done: false,
                    review: true,
                    overdue: false,
                    priority: t.priority || 'medium',
                    originalTask: t
                });
            });
            
            // 2. Регулярні завдання на сьогодні
            regularTasks.forEach(rt => {
                // Перевіряємо чи поточний користувач є виконавцем функції (O(1) map lookup)
                const func = funcByName[rt.function];
                if (!func || !func.assigneeIds?.includes(currentUser.uid)) return;
                
                // Перевіряємо чи сьогодні день цього завдання
                let isToday = false;
                
                // Підтримка старого формату daily
                if (rt.period === 'daily') {
                    isToday = true;
                } else if (rt.period === 'weekly') {
                    if (rt.daysOfWeek && Array.isArray(rt.daysOfWeek)) {
                        isToday = rt.daysOfWeek.includes(todayDay.toString());
                    } else if (rt.dayOfWeek) {
                        isToday = rt.dayOfWeek === todayDay.toString();
                    }
                } else if (rt.period === 'monthly') {
                    const todayDate = today.getDate();
                    if (rt.dayOfMonth === 'last') {
                        const lastDay = new Date(today.getFullYear(), today.getMonth() + 1, 0).getDate();
                        isToday = todayDate === lastDay;
                    } else {
                        isToday = todayDate === parseInt(rt.dayOfMonth);
                    }
                } else if (rt.period === 'quarterly') {
                    const quarterStartMonth = Math.floor(today.getMonth() / 3) * 3;
                    if (today.getMonth() === quarterStartMonth) {
                        const todayDate = today.getDate();
                        if (rt.dayOfMonth === 'last') {
                            const lastDay = new Date(today.getFullYear(), today.getMonth() + 1, 0).getDate();
                            isToday = todayDate === lastDay;
                        } else {
                            isToday = todayDate === parseInt(rt.dayOfMonth);
                        }
                    }
                }
                
                if (!isToday) return;
                
                // Перевіряємо чи виконано (O(1) index lookup замість O(n) find)
                const generatedTask = generatedTaskIndex[rt.id] || null;
                
                myTasks.push({
                    id: rt.id,
                    title: rt.title,
                    time: rt.timeStart || rt.time || '',
                    function: rt.function || '',
                    type: 'regular',
                    done: generatedTask?.status === 'done',
                    review: generatedTask?.status === 'review',
                    overdue: false,
                    generatedTaskId: generatedTask?.id,
                    originalTask: generatedTask || rt
                });
            });
            
            // Сортуємо: спочатку не виконані, потім review, потім по часу
            myTasks.sort((a, b) => {
                // done внизу
                if (a.done !== b.done) return a.done ? 1 : -1;
                // review після pending
                if (a.review !== b.review) return a.review ? 1 : -1;
                if (a.overdue !== b.overdue) return a.overdue ? -1 : 1;
                return (a.time || '99:99').localeCompare(b.time || '99:99');
            });
            
            // Статистика
            const total = myTasks.length;
            const done = myTasks.filter(t => t.done).length;
            const progressPercent = total > 0 ? Math.round((done / total) * 100) : 0;
            
            document.getElementById('mydayProgressFill').style.width = progressPercent + '%';
            document.getElementById('mydayProgressText').textContent = `${done}/${total}`;
            
            // Рендеримо
            if (myTasks.length === 0) {
                container.innerHTML = `
                    <div class="myday-empty">
                        <div class="myday-empty-icon"><i data-lucide="clipboard-list" class="icon icon-xl" style="width:48px;height:48px;color:var(--gray);"></i></div>
                        <h3>${t('noTasksForToday')}</h3>
                        <p style="color:var(--gray);margin-top:0.5rem;">${t('timeToRest')}</p>
                    </div>`;
                lucide.createIcons();
                return;
            }
            
            // Всі виконані?
            if (done === total && total > 0) {
                container.innerHTML = `
                    <div class="myday-all-done">
                        <div class="myday-all-done-icon"><i data-lucide="party-popper" class="icon" style="width:48px;height:48px;color:var(--success);"></i></div>
                        <h3>${t('allTasksDone')}</h3>
                        <p style="color:var(--gray);">${t('greatJob')}</p>
                    </div>
                    <div class="myday-section" style="margin-top:1rem;">
                        <div class="myday-section-title">
                            <i data-lucide="check-circle" class="icon icon-sm" style="color:var(--success);"></i>
                            ${t('doneToday')} (${done})
                        </div>
                        ${myTasks.map(t => renderMyDayItem(t)).join('')}
                    </div>`;
                lucide.createIcons();
                return;
            }
            
            // Розділяємо на категорії
            const overdueTasks = myTasks.filter(t => t.overdue && !t.done && !t.review);
            const pendingTasks = myTasks.filter(t => !t.done && !t.overdue && !t.review);
            const reviewTasks = myTasks.filter(t => t.review);
            const doneTasks = myTasks.filter(t => t.done);
            
            let html = '';
            
            // Прострочені
            if (overdueTasks.length > 0) {
                html += `
                    <div class="myday-section">
                        <div class="myday-section-title" style="color:var(--danger);">
                            <i data-lucide="alert-circle" class="icon icon-sm"></i>
                            ${t('overdueStatus')} (${overdueTasks.length})
                        </div>
                        ${overdueTasks.map(t => renderMyDayItem(t)).join('')}
                    </div>`;
            }
            
            // Очікують виконання
            if (pendingTasks.length > 0) {
                html += `
                    <div class="myday-section">
                        <div class="myday-section-title">
                            <i data-lucide="circle" class="icon icon-sm"></i>
                            ${t('toDo')} (${pendingTasks.length})
                        </div>
                        ${pendingTasks.map(t => renderMyDayItem(t)).join('')}
                    </div>`;
            }
            
            // На перевірці
            if (reviewTasks.length > 0) {
                html += `
                    <div class="myday-section">
                        <div class="myday-section-title" style="color:#8b5cf6;">
                            <i data-lucide="eye" class="icon icon-sm"></i>
                            ${t('onReview')} (${reviewTasks.length})
                        </div>
                        ${reviewTasks.map(t => renderMyDayItem(t)).join('')}
                    </div>`;
            }
            
            // Виконані
            if (doneTasks.length > 0) {
                html += `
                    <div class="myday-section">
                        <div class="myday-section-title" style="color:var(--success);">
                            <i data-lucide="check-circle" class="icon icon-sm"></i>
                            ${t('completedStatus')} (${doneTasks.length})
                        </div>
                        ${doneTasks.map(t => renderMyDayItem(t)).join('')}
                    </div>`;
            }
            
            container.innerHTML = html;
            lucide.createIcons();
            updateOverdueBadge();
        }
        
        function renderMyDayItem(task) {
            const checkClass = task.done ? 'checked' : (task.review ? 'checked' : '');
            const itemClass = task.done ? 'done' : (task.review ? 'review' : (task.overdue ? 'overdue' : ''));
            const tagClass = task.type === 'regular' ? 'regular' : '';
            const tagText = task.type === 'regular' 
                ? (t('regularType'))
                : (t('oneTimeType'));
            
            // Визначаємо чи поточний юзер — постановник цього завдання
            const isCreator = task.originalTask?.creatorId === currentUser?.uid;
            const showReviewActions = task.review && isCreator && task.originalTask?.assigneeId !== currentUser?.uid;
            
            let reviewActionsHtml = '';
            if (showReviewActions) {
                const taskId = task.type === 'regular' ? (task.generatedTaskId || task.id) : task.id;
                reviewActionsHtml = `
                    <div style="display:flex;gap:0.4rem;margin-top:0.5rem;" onclick="event.stopPropagation();">
                        <button onclick="acceptReviewTask('${escId(taskId)}')" 
                                style="flex:1;padding:0.4rem 0.6rem;border:none;border-radius:8px;background:#22c55e;color:white;font-weight:600;cursor:pointer;font-size:0.8rem;">
                            <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" style="vertical-align:-2px;"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg> ${t('acceptTask')}
                        </button>
                        <button onclick="rejectReviewTask('${escId(taskId)}')" 
                                style="flex:1;padding:0.4rem 0.6rem;border:none;border-radius:8px;background:#f59e0b;color:white;font-weight:600;cursor:pointer;font-size:0.8rem;">
                            ↩ ${t('rejectTask')}
                        </button>
                    </div>`;
            }
            
            let reviewBadge = '';
            if (task.review) {
                reviewBadge = `<span style="font-size:0.7rem;padding:2px 6px;border-radius:4px;background:#f3e8ff;color:#7c3aed;font-weight:500;"><svg width="11" height="11" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" style="vertical-align:-1px;"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg> ${t('reviewLabel')}</span>`;
            }
            
            return `
                <div class="myday-item ${itemClass}" onclick="openMyDayTask('${escId(task.id)}', '${escId(task.type)}', '${escId(task.generatedTaskId || '')}')">
                    <div class="myday-checkbox ${checkClass}" ${!task.review ? `onclick="event.stopPropagation(); toggleMyDayTask(event, '${escId(task.id)}', '${escId(task.type)}', '${escId(task.generatedTaskId || '')}', ${task.done || task.review})"` : ''} ${task.review ? 'style="background:#8b5cf6;border-color:#8b5cf6;"' : ''}>
                        ${task.done ? '<i data-lucide="check" class="icon icon-sm"></i>' : ''}
                        ${task.review ? '<i data-lucide="eye" class="icon icon-sm" style="color:white;"></i>' : ''}
                    </div>
                    <div class="myday-item-content">
                        <div class="myday-item-title">${esc(task.title)}</div>
                        <div class="myday-item-meta">
                            ${task.time ? `<span class="myday-item-time">${esc(task.time)}</span>` : ''}
                            ${task.function ? `<span>${esc(task.function)}</span>` : ''}
                            <span class="myday-item-tag ${tagClass}">${tagText}</span>
                            ${reviewBadge}
                            ${!task.done ? getAiHelpButton(task.title, task.originalTask?.description || task.originalTask?.instruction || '', task.function, 'small') : ''}
                        </div>
                        ${reviewActionsHtml}
                    </div>
                    ${task.overdue ? '<i data-lucide="alert-triangle" class="icon" style="color:var(--danger);"></i>' : ''}
                </div>`;
        }
        
        async function toggleMyDayTask(e, id, type, generatedTaskId, currentDone) {
            
            // Haptic feedback
            if (navigator.vibrate) navigator.vibrate(currentDone ? 10 : [10, 50, 10]);
            
            // Visual feedback - знаходимо елемент і анімуємо
            const checkbox = e?.target?.closest('.myday-checkbox');
            const item = checkbox?.closest('.myday-item');
            
            if (checkbox && !currentDone) {
                checkbox.classList.add('checked');
                checkbox.innerHTML = '<i data-lucide="check" class="icon icon-sm"></i>';
                lucide.createIcons();
            }
            if (item && !currentDone) {
                item.style.transform = 'scale(0.98)';
                item.style.opacity = '0.7';
            }
            
            try {
                if (type === 'regular') {
                    // Для регулярних - змінюємо статус згенерованого завдання
                    const todayStr = getLocalDateStr();
                    
                    
                    // Спочатку шукаємо завдання для ПОТОЧНОГО користувача
                    let taskToUpdate = null;
                    
                    if (generatedTaskId) {
                        // Перевіряємо чи це завдання дійсно належить поточному користувачу
                        taskToUpdate = tasks.find(t => t.id === generatedTaskId && t.assigneeId === currentUser.uid);
                    }
                    
                    // Якщо не знайшли по generatedTaskId - шукаємо по regularTaskId
                    if (!taskToUpdate) {
                        taskToUpdate = tasks.find(t => 
                            t.regularTaskId === id && 
                            t.deadlineDate === todayStr &&
                            t.assigneeId === currentUser.uid
                        );
                    }
                    
                    
                    if (taskToUpdate) {
                        // Оновлюємо існуюче завдання
                        const newStatus = currentDone ? 'new' : 'done';
                        await db.collection('companies').doc(currentCompany).collection('tasks').doc(taskToUpdate.id).update({
                            status: newStatus,
                            completedAt: newStatus === 'done' ? firebase.firestore.FieldValue.serverTimestamp() : null
                        });
                        // AUDIT LOG
                        logTaskChange(taskToUpdate.id, newStatus === 'done' ? 'complete' : 'reopen', { status: newStatus }, { status: currentDone ? 'done' : 'new' });
                    } else if (!currentDone) {
                        // Завдання не існує в локальному масиві - перевіряємо Firestore напряму
                        const todayStr2 = getLocalDateStr();
                        const existCheck = await db.collection('companies').doc(currentCompany)
                            .collection('tasks')
                            .where('regularTaskId', '==', id)
                            .where('deadlineDate', '==', todayStr2)
                            .where('assigneeId', '==', currentUser.uid)
                            .limit(1).get();
                        
                        if (!existCheck.empty) {
                            // Вже існує в Firestore — оновлюємо замість створення
                            const existingDoc = existCheck.docs[0];
                            await existingDoc.ref.update({
                                status: 'done',
                                completedAt: firebase.firestore.FieldValue.serverTimestamp()
                            });
                        } else {
                        // Створюємо нове
                        const rt = regularTasks.find(r => r.id === id);
                        if (rt) {
                            const newTaskRef = await db.collection('companies').doc(currentCompany).collection('tasks').add({
                                title: rt.title,
                                function: rt.function,
                                assigneeId: currentUser.uid,
                                assigneeName: currentUserData?.name || currentUser.email,
                                deadlineDate: todayStr2,
                                deadlineTime: rt.timeStart || rt.time || '18:00',
                                deadline: todayStr2 + 'T' + (rt.timeStart || rt.time || '18:00'),
                                expectedResult: rt.expectedResult || '',
                                reportFormat: rt.reportFormat || '',
                                description: rt.instruction || '',
                                status: 'done',
                                priority: 'medium',
                                pinned: false,
                                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                                createdDate: todayStr2,
                                creatorName: t('systemUser'),
                                regularTaskId: id,
                                autoGenerated: true,
                                completedAt: firebase.firestore.FieldValue.serverTimestamp()
                            });
                        } else {
                            console.error('Could not find regular task template:', id);
                            throw new Error('Регулярне завдання не знайдено');
                        }
                        } // close existCheck else
                    } else {
                        console.error('Cannot uncheck - task not found for user');
                        throw new Error('Завдання не знайдено');
                    }
                } else {
                    // Для разових - перевіряємо чи потрібна перевірка
                    const taskObj = tasks.find(t => t.id === id);
                    const needsReview = !currentDone && shouldSendForReview(taskObj);
                    const newStatus = currentDone ? 'new' : (needsReview ? 'review' : 'done');
                    
                    await db.collection('companies').doc(currentCompany).collection('tasks').doc(id).update({
                        status: newStatus,
                        completedAt: newStatus === 'done' || newStatus === 'review' ? firebase.firestore.FieldValue.serverTimestamp() : null,
                        ...(needsReview ? { sentForReviewAt: firebase.firestore.FieldValue.serverTimestamp() } : {})
                    });
                    // AUDIT LOG
                    logTaskChange(id, newStatus === 'done' || newStatus === 'review' ? 'complete' : 'reopen', { status: newStatus }, { status: currentDone ? 'done' : 'new' });
                    
                    if (needsReview) {
                        showToast(t('taskSentForReview'), 'info');
                    }
                }
                
                // Локальне оновлення замість loadAllData
                if (type === 'regular') {
                    const todayStr = getLocalDateStr();
                    let taskToUpdate = tasks.find(t => 
                        t.regularTaskId === id && 
                        t.deadlineDate === todayStr && 
                        t.assigneeId === currentUser.uid
                    );
                    if (taskToUpdate) {
                        taskToUpdate.status = currentDone ? 'new' : 'done';
                        taskToUpdate.completedAt = currentDone ? null : new Date().toISOString();
                        if (taskToUpdate.projectId) autoUpdateProjectStatus(taskToUpdate.projectId);
                    }
                } else {
                    const task = tasks.find(t => t.id === id);
                    if (task) {
                        const needsReview = !currentDone && shouldSendForReview(task);
                        task.status = currentDone ? 'new' : (needsReview ? 'review' : 'done');
                        task.completedAt = currentDone ? null : new Date().toISOString();
                        // Автопросування процесу
                        if (!needsReview && !currentDone) {
                            advanceProcessIfLinked(task.id);
                        }
                        // Автостатус проєкту
                        if (task.projectId) autoUpdateProjectStatus(task.projectId);
                    }
                }
                
                renderMyDay();
            } catch (error) {
                console.error('Error toggling task:', error);
                alert(t('error') + ': ' + error.message);
                // Відновлюємо UI при помилці
                if (checkbox && !currentDone) {
                    checkbox.classList.remove('checked');
                    checkbox.innerHTML = '';
                }
                if (item) {
                    item.style.transform = '';
                    item.style.opacity = '';
                }
            }
        }
        
        function openMyDayTask(id, type, generatedTaskId) {
            if (type === 'regular' && generatedTaskId) {
                openTaskModal(generatedTaskId);
            } else if (type === 'task') {
                openTaskModal(id);
            } else {
                // Регулярне без згенерованого - відкриваємо регулярне
                openRegularTaskModal(id);
            }
        }
        
        async function refreshMyDay() {
            const btn = document.querySelector('.myday-refresh-btn');
            if (btn) {
                btn.classList.add('spinning');
            }
            if (navigator.vibrate) navigator.vibrate(10);
            
            try {
                await loadAllData();
                renderMyDay();
            } finally {
                setTimeout(() => {
                    if (btn) btn.classList.remove('spinning');
                }, 500);
            }
        }
        
        // =====================
        // STATUS MULTI-SELECT FILTER
        // =====================
        function toggleStatusDropdown(e) {
            e.stopPropagation();
            const dd = document.getElementById('statusDropdown');
            const toggle = dd.previousElementSibling;
            const isOpen = dd.classList.contains('show');
            closeStatusDropdown();
            if (!isOpen) {
                dd.classList.add('show');
                toggle.classList.add('open');
            }
        }
        
        function closeStatusDropdown() {
            const dd = document.getElementById('statusDropdown');
            if (dd) {
                dd.classList.remove('show');
                dd.previousElementSibling.classList.remove('open');
            }
        }
        
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.status-multiselect')) {
                closeStatusDropdown();
            }
        });
        
        function getSelectedStatuses() {
            const checks = document.querySelectorAll('#statusDropdown .status-multiselect-item:not(.status-multiselect-all) input[type="checkbox"]');
            const selected = [];
            checks.forEach(cb => { if (cb.checked) selected.push(cb.value); });
            return selected;
        }
        
        function onStatusCheckChange() {
            const checks = document.querySelectorAll('#statusDropdown .status-multiselect-item:not(.status-multiselect-all) input[type="checkbox"]');
            const allCb = document.getElementById('statusAll');
            const total = checks.length;
            const checked = [...checks].filter(cb => cb.checked).length;
            allCb.checked = (checked === total);
            allCb.indeterminate = (checked > 0 && checked < total);
            updateStatusFilterLabel();
            renderTasks();
        }
        
        function toggleAllStatuses(e) {
            e.preventDefault();
            const allCb = document.getElementById('statusAll');
            const checks = document.querySelectorAll('#statusDropdown .status-multiselect-item:not(.status-multiselect-all) input[type="checkbox"]');
            // If all checked -> uncheck all; otherwise check all
            const allChecked = [...checks].every(cb => cb.checked);
            const newState = !allChecked;
            checks.forEach(cb => cb.checked = newState);
            allCb.checked = newState;
            allCb.indeterminate = false;
            updateStatusFilterLabel();
            renderTasks();
        }
        
        function updateStatusFilterLabel() {
            const label = document.getElementById('statusFilterLabel');
            const toggle = label.closest('.status-multiselect-toggle');
            const selected = getSelectedStatuses();
            const statusNames = { new: 'Нові', progress: 'В роботі', review: 'Перевірка', done: 'Готово' };
            
            // Remove old count badge
            const oldBadge = toggle.querySelector('.status-multiselect-count');
            if (oldBadge) oldBadge.remove();
            
            if (selected.length === 0 || selected.length === 4) {
                label.textContent = t('statusesLabel');
                label.classList.add('placeholder');
            } else if (selected.length === 1) {
                label.textContent = statusNames[selected[0]] || selected[0];
                label.classList.remove('placeholder');
            } else {
                label.textContent = selected.map(s => statusNames[s]).join(', ');
                label.classList.remove('placeholder');
                // Add count badge
                const badge = document.createElement('span');
                badge.className = 'status-multiselect-count';
                badge.textContent = selected.length;
                toggle.insertBefore(badge, toggle.querySelector('.status-multiselect-arrow'));
            }
        }
        
        function setStatusFilterFromArray(arr) {
            const checks = document.querySelectorAll('#statusDropdown .status-multiselect-item:not(.status-multiselect-all) input[type="checkbox"]');
            const allCb = document.getElementById('statusAll');
            if (!arr || arr.length === 0) {
                checks.forEach(cb => cb.checked = false);
                allCb.checked = false;
                allCb.indeterminate = false;
            } else {
                checks.forEach(cb => cb.checked = arr.includes(cb.value));
                const checked = [...checks].filter(cb => cb.checked).length;
                allCb.checked = (checked === checks.length);
                allCb.indeterminate = (checked > 0 && checked < checks.length);
            }
            updateStatusFilterLabel();
        }
        
        function renderTasks() {
            // If kanban view is active, render kanban instead
            if (currentCalendarView === 'kanban' || currentCalendarView === 'deadlines') {
                renderKanbanBoard(currentCalendarView);
                return;
            }
            tasksVisibleCount = TASKS_PAGE_SIZE; // Reset pagination on filter change
            const c = document.getElementById('tasksContainer');
            const selectedStatuses = getSelectedStatuses();
            const ff = document.getElementById('functionFilter')?.value;
            const af = document.getElementById('assigneeFilter')?.value;
            const df = document.getElementById('dateFilter')?.value;
            const tf = document.getElementById('taskTypeFilter')?.value;
            const searchQuery = (document.getElementById('taskSearchInput')?.value || '').toLowerCase().trim();
            
            const today = getLocalDateStr();
            
            let f = tasks.filter(task => {
                if (!isTaskVisibleToUser(task)) return false;
                if (hideCompletedTasks && task.status === 'done') return false;
                if (selectedStatuses.length > 0 && !selectedStatuses.includes(task.status)) return false;
                if (ff && task.function !== ff) return false;
                if (af && task.assigneeId !== af) return false;
                if (tf === 'my' && task.assigneeId !== currentUser.uid) return false;
                if (tf === 'created' && task.creatorId !== currentUser.uid) return false;
                if (searchQuery && !(task.title || '').toLowerCase().includes(searchQuery) && 
                    !(task.description || '').toLowerCase().includes(searchQuery) &&
                    !(task.assigneeName || '').toLowerCase().includes(searchQuery)) return false;
                
                const taskDate = parseDeadline(task).date;
                
                if (df === 'today' && taskDate !== today) return false;
                if (df === 'overdue') {
                    if (taskDate >= today || task.status === 'done') return false;
                }
                if (df === 'week') {
                    const weekLater = new Date();
                    weekLater.setDate(weekLater.getDate() + 7);
                    if (taskDate > getLocalDateStr(weekLater) || taskDate < today) return false;
                }
                if (df === 'month') {
                    const monthLater = new Date();
                    monthLater.setMonth(monthLater.getMonth() + 1);
                    if (taskDate > getLocalDateStr(monthLater) || taskDate < today) return false;
                }
                if (df === 'custom') {
                    const dateFrom = document.getElementById('dateFrom')?.value;
                    const dateTo = document.getElementById('dateTo')?.value;
                    if (dateFrom && taskDate < dateFrom) return false;
                    if (dateTo && taskDate > dateTo) return false;
                }
                return true;
            });
            
            f.sort((a, b) => {
                if (a.pinned && !b.pinned) return -1;
                if (!a.pinned && b.pinned) return 1;
                
                // Custom sort
                if (taskSortField) {
                    let valA, valB;
                    const statusOrder = { new: 0, progress: 1, review: 2, done: 3 };
                    switch(taskSortField) {
                        case 'title': valA = (a.title || '').toLowerCase(); valB = (b.title || '').toLowerCase(); break;
                        case 'assignee': valA = (a.assigneeName || '').toLowerCase(); valB = (b.assigneeName || '').toLowerCase(); break;
                        case 'creator': valA = (a.creatorName || '').toLowerCase(); valB = (b.creatorName || '').toLowerCase(); break;
                        case 'deadline': valA = a.deadlineDate || '9999'; valB = b.deadlineDate || '9999'; break;
                        case 'status': 
                            valA = statusOrder[a.status] ?? 9; valB = statusOrder[b.status] ?? 9; break;
                        case 'function': valA = (a.function || '').toLowerCase(); valB = (b.function || '').toLowerCase(); break;
                        default: valA = a.deadlineDate || '9999'; valB = b.deadlineDate || '9999';
                    }
                    const cmp = typeof valA === 'number' ? valA - valB : String(valA).localeCompare(String(valB));
                    return taskSortDir === 'desc' ? -cmp : cmp;
                }
                
                const dateA = parseDeadline(a).date || '9999';
                const dateB = parseDeadline(b).date || '9999';
                return dateA.localeCompare(dateB);
            });
            
            // Рахуємо загальний час
            let totalMinutes = 0;
            f.filter(task => task.status !== 'done').forEach(task => {
                if (task.estimatedTime) totalMinutes += parseInt(task.estimatedTime);
            });
            const totalHours = Math.floor(totalMinutes / 60);
            const totalMins = totalMinutes % 60;
            const totalTimeStr = totalMinutes > 0 ? `<svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align:-2px;"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg> ${totalHours > 0 ? totalHours + (t('hourShort')) : ''}${totalMins > 0 ? totalMins + (t('minShort')) : ''}` : '';
            
            document.getElementById('totalTimeInfo').innerHTML = totalTimeStr ? `<span class="total-time-badge">${totalTimeStr} (${f.filter(x=>x.status!=='done').length} ${t('tasks')})</span>` : '';
            
            if (f.length === 0) {
                c.innerHTML = `<div class="empty-table"><h3>${t('noTasksFound')}</h3><p>${t('changeFilters')}</p></div>`;
                return;
            }
            
            const st = { new: t('statusNew'), progress: t('statusProgress'), review: t('statusReview'), done: t('statusDone') };
            
            // Desktop table
            const sortIcon = (field) => {
                if (taskSortField !== field) return '<span class="sort-icon">⇅</span>';
                return `<span class="sort-icon">${taskSortDir === 'asc' ? '↑' : '↓'}</span>`;
            };
            const sortClass = (field) => taskSortField === field ? 'sortable sort-active' : 'sortable';
            
            let html = `
                <table class="tasks-table" style="table-layout:fixed;">
                    <thead>
                        <tr>
                            <th class="${sortClass('title')}" onclick="sortTasksBy('title')">${t('task')}${sortIcon('title')}<div class="col-resize-handle"></div></th>
                            <th class="${sortClass('assignee')}" onclick="sortTasksBy('assignee')">${t('assignee')}${sortIcon('assignee')}<div class="col-resize-handle"></div></th>
                            <th class="${sortClass('creator')}" onclick="sortTasksBy('creator')">${t('createdBy')}${sortIcon('creator')}<div class="col-resize-handle"></div></th>
                            <th class="${sortClass('deadline')}" onclick="sortTasksBy('deadline')">${t('deadline')}${sortIcon('deadline')}<div class="col-resize-handle"></div></th>
                            <th class="${sortClass('status')}" onclick="sortTasksBy('status')">${t('status')}${sortIcon('status')}<div class="col-resize-handle"></div></th>
                            <th class="${sortClass('function')}" onclick="sortTasksBy('function')">${t('type')}${sortIcon('function')}<div class="col-resize-handle"></div></th>
                            <th>${t('actions')}</th>
                        </tr>
                    </thead>
                    <tbody>`;
            
            f.forEach(task => {
                const { date: taskDeadline, time: taskTime } = parseDeadline(task);
                const od = taskDeadline && taskDeadline < today && task.status !== 'done' && task.status !== 'review';
                const isToday = taskDeadline === today;
                const deadlineClass = od ? 'overdue' : (isToday ? 'today' : '');
                
                // Індикатор процесу
                const processIndicator = task.processId ? `<i data-lucide="git-branch" class="icon icon-sm" style="color:#8b5cf6;" title="${t('taskFromProcess')}"></i> ` : '';
                
                html += `
                    <tr>
                        <td class="task-title-cell">
                            <span class="task-title-text ${task.pinned ? 'pinned' : ''}" onclick="openTaskModal('${escId(task.id)}')">${task.pinned ? '<i data-lucide="pin" class="icon icon-sm" style="color:#e74c3c"></i> ' : ''}${processIndicator}${esc(task.title)}</span>
                        </td>
                        <td>${esc(task.assigneeName) || '-'}</td>
                        <td>${esc(task.creatorName) || '-'}</td>
                        <td class="deadline-text ${deadlineClass}" onclick="inlineEditDeadline(event, '${escId(task.id)}', '${task.deadlineDate || ''}')" style="cursor:pointer;" title="Натисніть щоб змінити дату">${taskDeadline ? formatDateShort(taskDeadline) : '-'} ${taskTime || ''}</td>
                        <td><span class="status-badge status-${task.status}" style="cursor:pointer;" onclick="cycleTaskStatus('${escId(task.id)}',event)">${st[task.status] || task.status}</span></td>
                        <td>${esc(task.function) || '-'}</td>
                        <td>
                            <div class="action-btns">
                                ${task.status === 'review' && task.creatorId === currentUser?.uid && task.assigneeId !== currentUser?.uid ? `
                                    <button class="action-btn" onclick="acceptReviewTask('${escId(task.id)}')" title="${t('acceptTask')}" style="color:#22c55e;"><i data-lucide="check-circle" class="icon icon-sm"></i></button>
                                    <button class="action-btn" onclick="rejectReviewTask('${escId(task.id)}')" title="${t('rejectTask')}" style="color:#f59e0b;"><i data-lucide="rotate-ccw" class="icon icon-sm"></i></button>
                                ` : ''}
                                <button class="action-btn" onclick="togglePin('${escId(task.id)}')" title="Pin"><i data-lucide="pin" class="icon icon-sm"></i></button>
                                <button class="action-btn" onclick="openTaskModal('${escId(task.id)}')" title="Edit"><i data-lucide="pencil" class="icon icon-sm"></i></button>
                                <button class="action-btn" onclick="deleteTask('${escId(task.id)}')" title="Delete"><i data-lucide="trash-2" class="icon icon-sm"></i></button>
                            </div>
                        </td>
                    </tr>`;
            });
            
            html += `</tbody></table>`;
            
            // Mobile cards with swipe support and date grouping
            html += `<div class="mobile-tasks-list" id="mobileTasksList">`;
            
            // Group tasks by date
            const groups = {
                overdue: [],
                today: [],
                tomorrow: [],
                thisWeek: [],
                later: [],
                noDueDate: []
            };
            
            const tomorrow = new Date();
            tomorrow.setDate(tomorrow.getDate() + 1);
            const tomorrowStr = getLocalDateStr(tomorrow);
            
            const weekEnd = new Date();
            weekEnd.setDate(weekEnd.getDate() + 7);
            const weekEndStr = getLocalDateStr(weekEnd);
            
            f.forEach(task => {
                const taskDeadline = parseDeadline(task).date;
                
                if (!taskDeadline) {
                    groups.noDueDate.push(task);
                } else if (taskDeadline < today && task.status !== 'done' && task.status !== 'review') {
                    groups.overdue.push(task);
                } else if (taskDeadline === today) {
                    groups.today.push(task);
                } else if (taskDeadline === tomorrowStr) {
                    groups.tomorrow.push(task);
                } else if (taskDeadline <= weekEndStr) {
                    groups.thisWeek.push(task);
                } else {
                    groups.later.push(task);
                }
            });
            
            const groupLabels = {
                overdue: { label: t('overdueLabel2'), class: 'overdue' },
                today: { label: t('todayLabel'), class: 'today' },
                tomorrow: { label: t('tomorrowLabel'), class: 'tomorrow' },
                thisWeek: { label: t('thisWeekLabel'), class: '' },
                later: { label: t('laterLabel'), class: '' },
                noDueDate: { label: t('noDateLabel'), class: '' }
            };
            
            Object.keys(groups).forEach(groupKey => {
                const group = groups[groupKey];
                if (group.length === 0) return;
                
                const { label, class: headerClass } = groupLabels[groupKey];
                
                html += `
                <div class="date-group-header ${headerClass}">
                    <span class="date-label">${label}</span>
                    <span class="task-count">${group.length}</span>
                </div>`;
                
                group.forEach(task => {
                    const { date: taskDeadline, time: taskTime } = parseDeadline(task);
                    const od = taskDeadline && taskDeadline < today && task.status !== 'done' && task.status !== 'review';
                    const isToday = taskDeadline === today;
                    const deadlineClass = od ? 'deadline-overdue' : (isToday ? 'deadline-today' : '');
                    const cardClass = od ? 'overdue' : (task.pinned ? 'pinned' : `status-${task.status}`);
                    const canSwipeComplete = task.status !== 'done' && task.status !== 'review';
                    const isReviewForCreator = task.status === 'review' && task.creatorId === currentUser?.uid && task.assigneeId !== currentUser?.uid;
                    
                    html += `
                    <div class="mobile-task-card ${cardClass}" data-task-id="${task.id}" data-can-complete="${canSwipeComplete}">
                        <!-- Swipe backgrounds -->
                        <div class="swipe-action-bg left"><i data-lucide="check" class="icon"></i> ${t('statusDone')}</div>
                        <div class="swipe-action-bg right"><i data-lucide="trash-2" class="icon"></i> ${t('delete')}</div>
                        
                        <!-- Card content -->
                        <div class="mobile-task-content" onclick="openTaskModal('${escId(task.id)}')">
                            <div class="mobile-task-header">
                                <div class="mobile-task-title ${task.status === 'done' ? 'mobile-task-title-done' : ''}">
                                    ${task.pinned ? '<i data-lucide="pin" class="icon icon-sm" style="color:#e74c3c;width:14px;height:14px;"></i> ' : ''}${esc(task.title)}
                                </div>
                                ${(() => {
                                    if (!taskDeadline) return '';
                                    if (od) {
                                        const daysAgo = Math.floor((new Date(today) - new Date(taskDeadline)) / 86400000);
                                        const label = daysAgo === 1 ? '1 день тому' : daysAgo < 5 ? daysAgo + ' дні тому' : daysAgo + ' днів тому';
                                        return `<span class="mobile-task-deadline-badge overdue">${label}</span>`;
                                    }
                                    if (isToday) return `<span class="mobile-task-deadline-badge today">${taskTime || 'сьогодні'}</span>`;
                                    // Format date compactly
                                    const dp = taskDeadline.split('-');
                                    const dayNum = parseInt(dp[2]);
                                    const monthShort = ['січ','лют','бер','кві','тра','чер','лип','сер','вер','жов','лис','гру'][parseInt(dp[1]) - 1];
                                    return `<span class="mobile-task-deadline-badge upcoming">${dayNum} ${monthShort}</span>`;
                                })()}
                            </div>
                            
                            <div class="mobile-task-meta">
                                ${(() => {
                                    // Аватар з ініціалами
                                    const name = task.assigneeName || '';
                                    const initials = name.split(' ').map(w => w[0] || '').join('').toUpperCase().slice(0, 2) || '?';
                                    const colors = ['#3b82f6','#ef4444','#f59e0b','#8b5cf6','#ec4899','#06b6d4','#22c55e','#f97316'];
                                    const colorIdx = name.split('').reduce((a, c) => a + c.charCodeAt(0), 0) % colors.length;
                                    return `<div class="mobile-task-avatar" style="background:${colors[colorIdx]}">${initials}</div>`;
                                })()}
                                <span>${esc(task.assigneeName || '')}</span>
                                ${task.status !== 'done' ? `
                                    <span class="mobile-task-meta-sep">•</span>
                                    <span class="status-badge status-${task.status}" style="font-size:0.7rem;padding:0.1rem 0.4rem;cursor:pointer;" onclick="event.stopPropagation();cycleTaskStatus('${escId(task.id)}',event)">${st[task.status] || task.status}</span>
                                ` : ''}
                                ${task.function ? `<span class="mobile-task-meta-sep">•</span><span>${esc(task.function)}</span>` : ''}
                            </div>
                            
                            ${(() => {
                                // Badges: чеклист, коментарі, файли, співвиконавці
                                const badges = [];
                                const checklist = task.checklist || [];
                                if (checklist.length > 0) {
                                    const done = checklist.filter(c => c.checked).length;
                                    const cls = done === checklist.length ? 'has-items' : '';
                                    badges.push(`<span class="mobile-badge ${cls}"><i data-lucide="list-checks" class="icon"></i> ${done}/${checklist.length}</span>`);
                                }
                                const commentCount = task.commentCount || 0;
                                if (commentCount > 0) {
                                    badges.push(`<span class="mobile-badge has-items"><i data-lucide="message-circle" class="icon"></i> ${commentCount}</span>`);
                                }
                                const files = task.files || [];
                                if (files.length > 0) {
                                    badges.push(`<span class="mobile-badge has-items"><i data-lucide="paperclip" class="icon"></i> ${files.length}</span>`);
                                }
                                if (task.coExecutorIds?.length > 0) {
                                    badges.push(`<span class="mobile-badge"><i data-lucide="users" class="icon"></i> +${task.coExecutorIds.length}</span>`);
                                }
                                return badges.length > 0 ? `<div class="mobile-task-badges">${badges.join('')}</div>` : '';
                            })()}
                            
                            <div class="mobile-task-actions" onclick="event.stopPropagation()">
                                ${isReviewForCreator ? `
                                    <button class="mobile-action-btn complete" onclick="acceptReviewTask('${escId(task.id)}')" style="background:#22c55e;color:white;">
                                        <i data-lucide="check" class="icon icon-sm"></i> ${t('acceptTask')}
                                    </button>
                                    <button class="mobile-action-btn edit" onclick="rejectReviewTask('${escId(task.id)}')" style="background:#f59e0b;color:white;">
                                        <i data-lucide="rotate-ccw" class="icon icon-sm"></i> ${t('rejectTask')}
                                    </button>
                                ` : task.status === 'review' ? `
                                    <button class="mobile-action-btn edit" style="opacity:0.6;cursor:default;">
                                        <i data-lucide="eye" class="icon icon-sm"></i> ${t('reviewLabel')}
                                    </button>
                                ` : task.status !== 'done' ? `
                                    <button class="mobile-action-btn complete" onclick="quickCompleteTask('${escId(task.id)}')">
                                        <i data-lucide="check" class="icon icon-sm"></i> ${t('statusDone')}
                                    </button>
                                ` : `
                                    <button class="mobile-action-btn edit" onclick="reopenTask('${escId(task.id)}')">
                                        <i data-lucide="rotate-ccw" class="icon icon-sm"></i> ${t('reopen')}
                                    </button>
                                `}
                                <button class="mobile-action-btn edit" onclick="openTaskModal('${escId(task.id)}')">
                                    <i data-lucide="pencil" class="icon icon-sm"></i>
                                </button>
                                <button class="mobile-action-btn delete" onclick="if(confirm(t('deleteConfirm')))deleteTask('${escId(task.id)}')">
                                    <i data-lucide="trash-2" class="icon icon-sm"></i>
                                </button>
                            </div>
                        </div>
                    </div>`;
                });
            });
            
            html += `</div>`;
            c.innerHTML = html;
            
            // Pagination: show only first TASKS_PAGE_SIZE tasks, add "Load More"
            applyTasksPagination();
            
            refreshIcons();
            initSwipeHandlers();
            initTableColumnResize();
            restoreColumnWidths();
            updateOverdueBadge();
            
            // Infinite scroll для автопідвантаження
            setTimeout(initInfiniteScroll, 100);
        }
        
        // === TASKS PAGINATION ===
        const TASKS_PAGE_SIZE = 50;
        let tasksVisibleCount = TASKS_PAGE_SIZE;
        
        function applyTasksPagination() {
            // Desktop table rows
            const tableRows = document.querySelectorAll('.tasks-table tbody tr');
            if (tableRows.length > 0) {
                tableRows.forEach((row, i) => {
                    row.style.display = i < tasksVisibleCount ? '' : 'none';
                });
                
                // Remove old "load more" button if exists
                const oldBtn = document.getElementById('loadMoreTasksBtn');
                if (oldBtn) oldBtn.remove();
                
                if (tableRows.length > tasksVisibleCount) {
                    const loadMoreHTML = `<div id="loadMoreTasksBtn" style="text-align:center;padding:1rem;">
                        <button class="btn btn-small" onclick="loadMoreTasks()" style="padding:0.6rem 2rem;">
                            ${t('showMore')} (${tasksVisibleCount}/${tableRows.length})
                        </button>
                    </div>`;
                    document.querySelector('.tasks-table')?.insertAdjacentHTML('afterend', loadMoreHTML);
                }
            }
            
            // Mobile cards with proper date group header visibility
            const mobileList = document.getElementById('mobileTasksList');
            if (mobileList) {
                const mobileCards = mobileList.querySelectorAll('.mobile-task-card');
                const dateHeaders = mobileList.querySelectorAll('.date-group-header');
                
                if (mobileCards.length > 0) {
                    let visibleMobile = 0;
                    mobileCards.forEach(card => {
                        if (visibleMobile < tasksVisibleCount) {
                            card.style.display = '';
                            visibleMobile++;
                        } else {
                            card.style.display = 'none';
                        }
                    });
                    
                    // Hide date group headers where ALL cards in that group are hidden
                    dateHeaders.forEach(header => {
                        let nextEl = header.nextElementSibling;
                        let hasVisibleCard = false;
                        while (nextEl && !nextEl.classList.contains('date-group-header')) {
                            if (nextEl.classList.contains('mobile-task-card') && nextEl.style.display !== 'none') {
                                hasVisibleCard = true;
                                break;
                            }
                            nextEl = nextEl.nextElementSibling;
                        }
                        header.style.display = hasVisibleCard ? '' : 'none';
                    });
                    
                    const oldMobileBtn = document.getElementById('loadMoreTasksMobileBtn');
                    if (oldMobileBtn) oldMobileBtn.remove();
                    
                    if (mobileCards.length > tasksVisibleCount) {
                        mobileList.insertAdjacentHTML('beforeend', `<div id="loadMoreTasksMobileBtn" style="text-align:center;padding:1rem;">
                            <button class="btn btn-small" onclick="loadMoreTasks()" style="padding:0.6rem 2rem;width:100%;">
                                ${t('showMore')} (${tasksVisibleCount}/${mobileCards.length})
                            </button>
                        </div>`);
                    }
                }
            }
        }
        
        function loadMoreTasks() {
            tasksVisibleCount += TASKS_PAGE_SIZE;
            applyTasksPagination();
            refreshIcons();
            initSwipeHandlers();
        }
        
        // Infinite scroll — автоматичне підвантаження при скролі
        let infiniteScrollObserver = null;
        let infiniteScrollCooldown = false;
        
        function initInfiniteScroll() {
            if (infiniteScrollObserver) infiniteScrollObserver.disconnect();
            
            const sentinel = document.getElementById('loadMoreTasksMobileBtn') || document.getElementById('loadMoreTasksBtn');
            if (!sentinel) return;
            
            infiniteScrollObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting && !infiniteScrollCooldown) {
                        infiniteScrollCooldown = true;
                        loadMoreTasks();
                        // Cooldown + переініціалізація на новий sentinel
                        setTimeout(() => {
                            infiniteScrollCooldown = false;
                            initInfiniteScroll();
                        }, 300);
                    }
                });
            }, { rootMargin: '200px' });
            
            infiniteScrollObserver.observe(sentinel);
        }
        
        // =====================
        // TABLE COLUMN RESIZE + SORT
        // =====================
        let taskSortField = localStorage.getItem('taskSortField') || '';
        let taskSortDir = localStorage.getItem('taskSortDir') || 'asc';
        let hideCompletedTasks = localStorage.getItem('hideCompletedTasks') === 'true';
        
        function sortTasksBy(field) {
            if (taskSortField === field) {
                taskSortDir = taskSortDir === 'asc' ? 'desc' : 'asc';
            } else {
                taskSortField = field;
                taskSortDir = 'asc';
            }
            localStorage.setItem('taskSortField', taskSortField);
            localStorage.setItem('taskSortDir', taskSortDir);
            renderTasks();
        }
        
        function toggleHideCompleted() {
            hideCompletedTasks = !hideCompletedTasks;
            localStorage.setItem('hideCompletedTasks', hideCompletedTasks);
            const btn = document.getElementById('hideCompletedBtn');
            if (btn) btn.classList.toggle('active', hideCompletedTasks);
            renderTasks();
        }
        
        function initTableColumnResize() {
            const handles = document.querySelectorAll('.col-resize-handle');
            handles.forEach(handle => {
                handle.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    const th = handle.parentElement;
                    const startX = e.clientX;
                    const startWidth = th.offsetWidth;
                    handle.classList.add('resizing');
                    
                    const onMove = (e2) => {
                        const newWidth = Math.max(60, startWidth + (e2.clientX - startX));
                        th.style.width = newWidth + 'px';
                        th.style.minWidth = newWidth + 'px';
                        // Синхронізуємо TD цієї колонки
                        const colIndex = Array.from(th.parentElement.children).indexOf(th);
                        const rows = th.closest('table').querySelectorAll('tbody tr');
                        rows.forEach(row => {
                            const td = row.children[colIndex];
                            if (td) {
                                td.style.width = newWidth + 'px';
                                td.style.minWidth = newWidth + 'px';
                            }
                        });
                    };
                    const onUp = () => {
                        handle.classList.remove('resizing');
                        document.removeEventListener('mousemove', onMove);
                        document.removeEventListener('mouseup', onUp);
                        saveColumnWidths();
                    };
                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onUp);
                });
            });
        }
        
        function saveColumnWidths() {
            const ths = document.querySelectorAll('.tasks-table th');
            if (!ths.length) return;
            const widths = Array.from(ths).map(th => th.offsetWidth);
            localStorage.setItem('taskColumnWidths', JSON.stringify(widths));
        }
        
        function restoreColumnWidths() {
            const saved = localStorage.getItem('taskColumnWidths');
            if (!saved) return;
            try {
                const widths = JSON.parse(saved);
                const ths = document.querySelectorAll('.tasks-table th');
                const table = document.querySelector('.tasks-table');
                if (!ths.length || !table) return;
                ths.forEach((th, i) => {
                    if (widths[i]) {
                        th.style.width = widths[i] + 'px';
                        th.style.minWidth = widths[i] + 'px';
                    }
                });
                // Також TD
                const rows = table.querySelectorAll('tbody tr');
                rows.forEach(row => {
                    Array.from(row.children).forEach((td, i) => {
                        if (widths[i]) {
                            td.style.width = widths[i] + 'px';
                            td.style.minWidth = widths[i] + 'px';
                        }
                    });
                });
            } catch(e) {}
        }
        
        function setTaskTypeFilter(btn) {
            const val = btn.dataset.value;
            document.getElementById('taskTypeFilter').value = val;
            // Update tab styles
            document.querySelectorAll('.task-type-tab').forEach(t => {
                if (t.dataset.value === val) {
                    t.style.background = '#22c55e';
                    t.style.color = 'white';
                    t.classList.add('active');
                } else {
                    t.style.background = 'transparent';
                    t.style.color = '#555';
                    t.classList.remove('active');
                }
            });
            renderTasks();
        }
        
        function syncTaskTypeTabs() {
            const val = document.getElementById('taskTypeFilter').value;
            document.querySelectorAll('.task-type-tab').forEach(t => {
                if (t.dataset.value === val) {
                    t.style.background = '#22c55e';
                    t.style.color = 'white';
                    t.classList.add('active');
                } else {
                    t.style.background = 'transparent';
                    t.style.color = '#555';
                    t.classList.remove('active');
                }
            });
        }
        
        function clearTaskFilters() {
            document.getElementById('taskTypeFilter').value = '';
            document.getElementById('dateFilter').value = '';
            setStatusFilterFromArray([]);
            document.getElementById('functionFilter').value = '';
            document.getElementById('assigneeFilter').value = '';
            const searchInput = document.getElementById('taskSearchInput');
            if (searchInput) { searchInput.value = ''; searchInput.style.width = '130px'; }
            const mobileSearch = document.getElementById('mobileTaskSearchInput');
            if (mobileSearch) mobileSearch.value = '';
            document.getElementById('customDateRange').style.display = 'none';
            document.getElementById('dateFrom').value = '';
            document.getElementById('dateTo').value = '';
            syncTaskTypeTabs();
            renderTasks();
        }
        
        // Export dropdown
        function toggleExportDropdown(e) {
            e.stopPropagation();
            const dd = document.getElementById('exportDropdown');
            dd.style.display = dd.style.display === 'none' ? 'block' : 'none';
            if (dd.style.display === 'block') {
                refreshIcons();
                setTimeout(() => document.addEventListener('click', closeExportDropdown, { once: true }), 10);
            }
        }
        function closeExportDropdown() {
            document.getElementById('exportDropdown').style.display = 'none';
        }
        
        function getExportData() {
            const st = { new: 'Нове', progress: 'В роботі', review: 'Перевірка', done: 'Готово' };
            return tasks.filter(t => isTaskVisibleToUser(t)).map(task => {
                const { date, time } = parseDeadline(task);
                return {
                    'Назва': task.title || '',
                    'Виконавець': task.assigneeName || '',
                    'Створив': task.creatorName || '',
                    'Дедлайн': date ? (date + (time ? ' ' + time : '')) : '',
                    'Статус': st[task.status] || task.status,
                    'Функція': task.function || '',
                    'Пріоритет': task.priority === 'high' ? 'Високий' : task.priority === 'low' ? 'Низький' : 'Середній',
                    'Опис': task.description || task.instruction || ''
                };
            });
        }

        function exportTasksCSV() {
            const data = getExportData();
            if (data.length === 0) { showToast(t('noTasksForExport'), 'info'); return; }
            const headers = Object.keys(data[0]);
            let csv = headers.join(',') + '\n';
            data.forEach(row => {
                csv += headers.map(h => `"${(row[h] || '').replace(/"/g, '""')}"`).join(',') + '\n';
            });
            const blob = new Blob(['\ufeff' + csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'tasks_' + getLocalDateStr() + '.csv';
            link.click();
        }
        
        function exportTasksXLSX() {
            const data = getExportData();
            if (data.length === 0) { showToast(t('noTasksForExport'), 'info'); return; }
            const headers = Object.keys(data[0]);
            
            // Build XLSX using XML spreadsheet format (no library needed)
            let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
            xml += '<?mso-application progid="Excel.Sheet"?>\n';
            xml += '<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet" xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet">\n';
            xml += '<Styles><Style ss:ID="header"><Font ss:Bold="1" ss:Size="11"/><Interior ss:Color="#22c55e" ss:Pattern="Solid"/><Font ss:Color="#FFFFFF" ss:Bold="1"/></Style>';
            xml += '<Style ss:ID="wrap"><Alignment ss:WrapText="1" ss:Vertical="Top"/></Style></Styles>\n';
            xml += '<Worksheet ss:Name="Завдання"><Table>\n';
            
            // Column widths
            const colWidths = [250, 150, 120, 120, 80, 120, 80, 300];
            colWidths.forEach(w => { xml += `<Column ss:Width="${w}"/>\n`; });
            
            // Header row
            xml += '<Row ss:Height="24">';
            headers.forEach(h => { xml += `<Cell ss:StyleID="header"><Data ss:Type="String">${h}</Data></Cell>`; });
            xml += '</Row>\n';
            
            // Data rows
            data.forEach(row => {
                xml += '<Row>';
                headers.forEach(h => {
                    const val = (row[h] || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    xml += `<Cell ss:StyleID="wrap"><Data ss:Type="String">${val}</Data></Cell>`;
                });
                xml += '</Row>\n';
            });
            
            xml += '</Table></Worksheet></Workbook>';
            
            const blob = new Blob([xml], { type: 'application/vnd.ms-excel;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'tasks_' + getLocalDateStr() + '.xlsx';
            link.click();
        }
        
        // Inline status cycle: new → progress → done (або review)
        // Inline deadline editing — клік на дату в таблиці
        function inlineEditDeadline(event, taskId, currentDate) {
            event.stopPropagation();
            const td = event.currentTarget;
            
            // Якщо вже є input — не дублюємо
            if (td.querySelector('input')) return;
            
            const task = tasks.find(t => t.id === taskId);
            const originalHTML = td.innerHTML;
            
            const wrap = document.createElement('div');
            wrap.style.cssText = 'display:flex;gap:4px;align-items:center;';
            
            const dateInput = document.createElement('input');
            dateInput.type = 'date';
            dateInput.value = currentDate || '';
            dateInput.style.cssText = 'width:130px;padding:0.25rem;border:2px solid #22c55e;border-radius:8px;font-size:0.85rem;outline:none;';
            
            const timeInput = document.createElement('input');
            timeInput.type = 'time';
            timeInput.value = task?.deadlineTime || '';
            timeInput.style.cssText = 'width:90px;padding:0.25rem;border:2px solid #22c55e;border-radius:8px;font-size:0.85rem;outline:none;';
            
            wrap.appendChild(dateInput);
            wrap.appendChild(timeInput);
            td.innerHTML = '';
            td.appendChild(wrap);
            dateInput.focus();
            
            let saved = false;
            async function save() {
                if (saved) return;
                const newDate = dateInput.value;
                const newTime = timeInput.value;
                if (newDate === (currentDate || '') && newTime === (task?.deadlineTime || '')) {
                    td.innerHTML = originalHTML;
                    return;
                }
                saved = true;
                
                const oldDate = task?.deadlineDate;
                const oldTime = task?.deadlineTime;
                
                try {
                    const updateData = { 
                        deadlineDate: newDate || '', 
                        deadlineTime: newTime || '',
                        updatedAt: firebase.firestore.FieldValue.serverTimestamp() 
                    };
                    if (newDate) {
                        updateData.deadline = newDate + 'T' + (newTime || '23:59');
                    }
                    await db.collection('companies').doc(currentCompany).collection('tasks').doc(taskId).update(updateData);
                    
                    if (task) {
                        task.deadlineDate = newDate;
                        task.deadlineTime = newTime;
                    }
                    
                    logTaskChange(taskId, 'deadline', { deadlineDate: newDate, deadlineTime: newTime }, { deadlineDate: oldDate, deadlineTime: oldTime });
                    refreshCurrentView();
                    showToast(t('deadlineUpdated'), 'success');
                } catch (e) {
                    td.innerHTML = originalHTML;
                    showToast(t('error') + ': ' + e.message, 'error');
                }
            }
            
            dateInput.addEventListener('change', () => {}); // just update value
            timeInput.addEventListener('change', () => {}); // just update value
            
            function handleBlur() {
                setTimeout(() => {
                    if (wrap.contains(document.activeElement)) return; // still inside wrap
                    if (!saved) {
                        const newDate = dateInput.value;
                        const newTime = timeInput.value;
                        if (newDate !== (currentDate || '') || newTime !== (task?.deadlineTime || '')) {
                            save();
                        } else {
                            td.innerHTML = originalHTML;
                        }
                    }
                }, 200);
            }
            dateInput.addEventListener('blur', handleBlur);
            timeInput.addEventListener('blur', handleBlur);
            
            dateInput.addEventListener('keydown', (e) => { if (e.key === 'Escape') td.innerHTML = originalHTML; });
            timeInput.addEventListener('keydown', (e) => { if (e.key === 'Escape') td.innerHTML = originalHTML; });
        }
        
        async function cycleTaskStatus(taskId, e) {
            e.stopPropagation();
            const taskIndex = tasks.findIndex(t => t.id === taskId);
            if (taskIndex < 0) return;
            const task = tasks[taskIndex];
            
            // Permission check
            if (!canEditTask(task)) {
                showToast(t('noPermissionTask'), 'error');
                return;
            }
            
            // Визначаємо наступний статус
            let newStatus;
            if (task.status === 'new') newStatus = 'progress';
            else if (task.status === 'progress') newStatus = shouldSendForReview(task) ? 'review' : 'done';
            else if (task.status === 'review') {
                // Review → викликаємо повноцінний accept (з reviewedAt/reviewedBy)
                acceptReviewTask(taskId);
                return;
            }
            else if (task.status === 'done') newStatus = 'progress';
            else return;
            
            const originalTask = deepCloneTask(tasks[taskIndex]);
            
            tasks[taskIndex].status = newStatus;
            if (newStatus === 'done') tasks[taskIndex].completedAt = new Date().toISOString();
            else tasks[taskIndex].completedAt = null;
            
            renderMyDay();
            refreshCurrentView();
            
            try {
                const update = { status: newStatus, updatedAt: firebase.firestore.FieldValue.serverTimestamp() };
                if (newStatus === 'done') {
                    update.completedAt = firebase.firestore.FieldValue.serverTimestamp();
                    update.completedBy = currentUser.uid;
                } else {
                    update.completedAt = null;
                }
                if (newStatus === 'review') {
                    update.sentForReviewAt = firebase.firestore.FieldValue.serverTimestamp();
                }
                await db.collection('companies').doc(currentCompany).collection('tasks').doc(taskId).update(update);
                if (newStatus === 'done') advanceProcessIfLinked(taskId);
                if (newStatus === 'review') showToast(t('taskSentForReview'), 'info');
                // Автостатус проекту
                if (task.projectId) autoUpdateProjectStatus(task.projectId);
                // AUDIT LOG
                logTaskChange(taskId, newStatus === 'done' ? 'complete' : 'status', { status: newStatus }, { status: originalTask.status });
            } catch(err) {
                tasks[taskIndex] = originalTask;
                renderMyDay();
                refreshCurrentView();
                showToast(t('error') + ': ' + err.message, 'error');
            }
        }
        
        // Sync search inputs (desktop ↔ mobile)
        function syncSearchInputs(source) {
            const desktop = document.getElementById('taskSearchInput');
            const mobile = document.getElementById('mobileTaskSearchInput');
            if (source === desktop && mobile) mobile.value = desktop.value;
            else if (source === mobile && desktop) desktop.value = mobile.value;
        }
        
        function formatDateShort(dateStr) {
            if (!dateStr) return '-';
            try {
                const parts = dateStr.split('-');
                const year = parseInt(parts[0]);
                const month = parseInt(parts[1]) - 1;
                const day = parseInt(parts[2]);
                const monthShort = getMonthNames();
                return `${day} ${monthShort[month]}`;
            } catch(e) { return dateStr; }
        }

        // =====================
        // FUNCTIONS
        // =====================
        function openFunctionModal(id = null) {
            if (!isManagerOrAbove()) {
                showToast(t('noPermissionTask'), 'error');
                return;
            }

            document.getElementById('functionModal').style.display = 'block';
            updateFunctionAssignees();
            
            if (id) {
                editingId = id;
                const f = functions.find(x => x.id === id);
                if (f) {
                    document.getElementById('functionModalTitle').textContent = t('editTask');
                    document.getElementById('functionName').value = f.name || '';
                    document.getElementById('functionHead').value = f.headId || '';
                    document.getElementById('functionDescription').value = f.description || '';
                    setTimeout(() => {
                        document.querySelectorAll('#functionAssignees input').forEach(cb => {
                            cb.checked = f.assigneeIds?.includes(cb.value);
                        });
                    }, 50);
                }
            } else {
                editingId = null;
                document.getElementById('functionModalTitle').textContent = t('newFunction');
                document.getElementById('functionForm').reset();
            }
        }

        function updateFunctionAssignees() {
            const c = document.getElementById('functionAssignees');
            const h = document.getElementById('functionHead');
            c.innerHTML = users.map(u => `<label class="assignee-checkbox"><input type="checkbox" value="${esc(u.id)}">${esc(u.name || u.email)}</label>`).join('');
            h.innerHTML = `<option value="">${t('select')}</option>` + users.map(u => `<option value="${esc(u.id)}">${esc(u.name || u.email)}</option>`).join('');
        }

        async function saveFunction(e) {
            // Role guard: only owner/manager can manage functions
            if (currentUserData?.role === 'employee') {
                showToast(t('noPermissionTask'), 'error');
                return;
            }
            e.preventDefault();
            
            if (isSaving) return;
            
            // Rate limiting
            if (!rateLimiter.check('saveFunction')) {
                alert(t('tooManyRequests'));
                return;
            }
            
            // Валідація
            const funcData = {
                name: document.getElementById('functionName').value.trim(),
                headId: document.getElementById('functionHead').value
            };
            
            const errors = validateFunctionData(funcData);
            if (errors.length > 0) {
                alert(errors.join('\n'));
                return;
            }
            
            isSaving = true;
            
            const submitBtn = e.target.querySelector('button[type="submit"]');
            if (submitBtn) submitBtn.disabled = true;
            
            // Копіюємо editingId локально
            const currentEditingId = editingId;
            
            try {
                const headId = document.getElementById('functionHead').value;
                const head = users.find(u => u.id === headId);
                const assigneeIds = Array.from(document.querySelectorAll('#functionAssignees input:checked')).map(cb => cb.value);
                if (!assigneeIds.includes(headId)) assigneeIds.push(headId);
                
                const data = {
                    name: document.getElementById('functionName').value.trim(),
                    headId: headId,
                    headName: head?.name || head?.email || '',
                    description: document.getElementById('functionDescription').value.trim(),
                    assigneeIds: assigneeIds,
                    assigneeNames: assigneeIds.map(id => users.find(u => u.id === id)?.name || users.find(u => u.id === id)?.email || '').filter(Boolean)
                };
                
                if (currentEditingId) {
                    const oldFunc = functions.find(f => f.id === currentEditingId);
                    const oldName = oldFunc?.name;
                    data.updatedAt = firebase.firestore.FieldValue.serverTimestamp();
                    await db.collection('companies').doc(currentCompany).collection('functions').doc(currentEditingId).update(data);
                    // Каскадне оновлення імені функції
                    if (oldName && oldName !== data.name) {
                        const base = db.collection('companies').doc(currentCompany);
                        let batch = db.batch(); let bc = 0;
                        tasks.filter(tk => tk.function === oldName).forEach(tk => {
                            batch.update(base.collection('tasks').doc(tk.id), { function: data.name }); tk.function = data.name;
                            if (++bc >= 450) { await batch.commit(); batch = db.batch(); bc = 0; }
                        });
                        regularTasks.filter(rt => rt.function === oldName).forEach(rt => {
                            batch.update(base.collection('regularTasks').doc(rt.id), { function: data.name }); rt.function = data.name;
                            if (++bc >= 450) { await batch.commit(); batch = db.batch(); bc = 0; }
                        });
                        processTemplates.forEach(pt => {
                            if (pt.steps?.some(s => s.function === oldName)) {
                                const upSteps = pt.steps.map(s => s.function === oldName ? { ...s, function: data.name } : s);
                                batch.update(base.collection('processTemplates').doc(pt.id), { steps: upSteps }); pt.steps = upSteps;
                                if (++bc >= 450) { await batch.commit(); batch = db.batch(); bc = 0; }
                            }
                        });
                        if (bc > 0) await batch.commit();
                    }
                    const idx = functions.findIndex(f => f.id === currentEditingId);
                    if (idx >= 0) functions[idx] = { ...functions[idx], ...data };
                } else {
                    data.createdAt = firebase.firestore.FieldValue.serverTimestamp();
                    const docRef = await db.collection('companies').doc(currentCompany).collection('functions').add(data);
                    // Локальне додавання
                    functions.unshift({ id: docRef.id, ...data, createdAt: new Date() });
                }
                closeModal('functionModal');
                renderFunctions();
                updateSelects();
            } catch (error) {
                console.error('saveFunction error:', error);
                alert(t('error') + ': ' + error.message);
            } finally {
                isSaving = false;
                if (submitBtn) submitBtn.disabled = false;
            }
        }

        async function deleteFunction(id) {
            if (currentUserData?.role === 'employee') { showToast(t('noPermissionTask'), 'error'); return; }
            const func = functions.find(f => f.id === id);
            if (!func) return;
            
            const funcName = func.name || t('function');
            const usedInTemplates = processTemplates.filter(pt => pt.steps?.some(s => s.function === funcName));
            if (usedInTemplates.length > 0) {
                if (!confirm(funcName + ' → ' + usedInTemplates.map(pt => pt.name).join(', ') + '\n\n' + (t('deleteConfirm') || 'Видалити?'))) return;
            }
            
            // Оптимістичне видалення
            const funcCopy = { ...func };
            functions = functions.filter(f => f.id !== id);
            renderFunctions();
            
            // Показуємо toast з можливістю undo
            showUndoToast(funcName, funcCopy, 'function');
            
            try {
                await db.collection('companies').doc(currentCompany).collection('functions').doc(id).delete();
            } catch (error) {
                // Rollback
                if (!functions.find(f => f.id === id)) {
                    functions.unshift(funcCopy);
                }
                deletedItemsStack = deletedItemsStack.filter(d => d.item.id !== id);
                renderFunctions();
                hideUndoToast();
                console.error('deleteFunction error:', error);
                alert(t('error') + ': ' + error.message);
            }
        }

        function renderFunctions() {
            const c = document.getElementById('functionsContainer');
            // Фільтруємо архівовані функції
            const activeFunctions = functions.filter(f => f.status !== 'archived');
            
            if (activeFunctions.length === 0) {
                c.innerHTML = `<div class="empty-state" style="grid-column:1/-1;"><h3>${t('noFunctions')}</h3><p>${t('createFirstFunction')}</p></div>`;
                // Ховаємо кнопку об'єднання
                const mergeBtn = document.getElementById('mergeFunctionsBtn');
                if (mergeBtn) mergeBtn.style.display = 'none';
                return;
            }
            c.innerHTML = activeFunctions.map(f => {
                const mergedInfo = f.mergedFrom?.length ? `<div style="font-size:0.75rem;color:#6b7280;margin-top:0.25rem;"><i data-lucide="git-merge" class="icon icon-sm"></i> ${t('mergedFrom')}: ${f.mergedFrom.map(m => m.name).join(', ')}</div>` : '';
                return `
                <div class="function-card">
                    <div class="function-header">
                        <div class="function-title"><i data-lucide="settings" class="icon icon-sm"></i> ${esc(f.name)}</div>
                    </div>
                    ${f.description ? `<div class="function-description">${esc(f.description)}</div>` : ''}
                    ${mergedInfo}
                    <div class="function-assignees">
                        ${f.headName ? `<span class="assignee-badge head"><i data-lucide="crown" class="icon icon-sm"></i> ${esc(f.headName)}</span>` : ''}
                        ${f.assigneeNames?.filter(n => n !== f.headName).map(n => `<span class="assignee-badge">${esc(n)}</span>`).join('') || ''}
                    </div>
                    <div class="function-stats">
                        <span><i data-lucide="file-text" class="icon icon-sm"></i> ${tasks.filter(task => task.function === f.name).length} ${t('tasks')}</span>
                        <div>
                            <button class="btn btn-small" onclick="openFunctionModal('${escId(f.id)}')"><i data-lucide="pencil" class="icon icon-sm"></i></button>
                            <button class="btn btn-small btn-danger" onclick="deleteFunction('${escId(f.id)}')"><i data-lucide="trash-2" class="icon icon-sm"></i></button>
                        </div>
                    </div>
                </div>
            `}).join('');
            refreshIcons();
            
            // Показуємо кнопку об'єднання якщо є 2+ функції
            const mergeBtn = document.getElementById('mergeFunctionsBtn');
            if (mergeBtn) {
                mergeBtn.style.display = functions.length >= 2 ? 'flex' : 'none';
            }
        }

        // =====================
        // MERGE FUNCTIONS
        // =====================
        function openMergeFunctionsModal() {
            const list = document.getElementById('mergeFunctionsList');
            const activeFunctions = functions.filter(f => f.status !== 'archived');
            
            list.innerHTML = activeFunctions.map(f => {
                const taskCount = tasks.filter(t => t.function === f.name).length;
                const regularCount = regularTasks.filter(rt => rt.function === f.name).length;
                const assigneeCount = f.assigneeIds?.length || 0;
                return `
                    <label style="display:flex;align-items:center;gap:0.75rem;padding:0.75rem;border-bottom:1px solid #f3f4f6;cursor:pointer;transition:background 0.2s;" 
                           onmouseover="this.style.background='#f9fafb'" onmouseout="this.style.background='transparent'">
                        <input type="checkbox" name="mergeFunction" value="${esc(f.id)}" onchange="updateMergePreview()" 
                               style="width:18px;height:18px;accent-color:var(--primary);">
                        <div style="flex:1;">
                            <div style="font-weight:500;">${esc(f.name)}</div>
                            <div style="font-size:0.8rem;color:#6b7280;">
                                ${taskCount} ${t('tasksCount')} · ${regularCount} ${t('regularTasksCount')} · ${assigneeCount} ${t('assigneesCount')}
                            </div>
                        </div>
                    </label>
                `;
            }).join('');
            
            document.getElementById('mergedFunctionName').value = '';
            document.getElementById('mergePreview').style.display = 'none';
            document.getElementById('executeMergeBtn').disabled = true;
            
            document.getElementById('mergeFunctionsModal').style.display = 'block';
            refreshIcons();
        }
        
        function updateMergePreview() {
            const selected = Array.from(document.querySelectorAll('input[name="mergeFunction"]:checked')).map(cb => cb.value);
            const preview = document.getElementById('mergePreview');
            const content = document.getElementById('mergePreviewContent');
            const executeBtn = document.getElementById('executeMergeBtn');
            const nameInput = document.getElementById('mergedFunctionName');
            
            if (selected.length < 2) {
                preview.style.display = 'none';
                executeBtn.disabled = true;
                return;
            }
            
            if (selected.length > 5) {
                alert(t('mergeSelectMaxFive'));
                return;
            }
            
            // Рахуємо статистику
            const selectedFunctions = functions.filter(f => selected.includes(f.id));
            let totalTasks = 0;
            let totalRegular = 0;
            let allAssignees = new Set();
            
            selectedFunctions.forEach(f => {
                totalTasks += tasks.filter(t => t.function === f.name).length;
                totalRegular += regularTasks.filter(rt => rt.function === f.name).length;
                f.assigneeIds?.forEach(id => allAssignees.add(id));
            });
            
            content.innerHTML = `
                <div>• <strong>${totalTasks}</strong> ${t('tasksCount')}</div>
                <div>• <strong>${totalRegular}</strong> ${t('regularTasksCount')}</div>
                <div>• <strong>${allAssignees.size}</strong> ${t('assigneesCount')}</div>
                <div style="margin-top:0.5rem;font-size:0.85rem;color:#059669;">
                    ${t('mergedFrom')}: ${selectedFunctions.map(f => f.name).join(', ')}
                </div>
            `;
            
            preview.style.display = 'block';
            executeBtn.disabled = false;
            
            // Автозаповнення назви якщо порожня
            if (!nameInput.value) {
                nameInput.value = selectedFunctions[0]?.name || '';
            }
        }
        
        async function executeMergeFunctions() {
            const selected = Array.from(document.querySelectorAll('input[name="mergeFunction"]:checked')).map(cb => cb.value);
            const newName = document.getElementById('mergedFunctionName').value.trim();
            
            if (selected.length < 2) {
                alert(t('mergeSelectMinTwo'));
                return;
            }
            
            if (!newName) {
                alert(t('mergeEnterName'));
                return;
            }
            
            const executeBtn = document.getElementById('executeMergeBtn');
            executeBtn.disabled = true;
            executeBtn.innerHTML = '<span class="spinner" style="width:16px;height:16px;"></span>';
            
            try {
                const selectedFunctions = functions.filter(f => selected.includes(f.id));
                
                // Збираємо всіх виконавців
                let allAssigneeIds = new Set();
                let allAssigneeNames = [];
                let headId = null;
                let headName = null;
                
                selectedFunctions.forEach(f => {
                    f.assigneeIds?.forEach(id => allAssigneeIds.add(id));
                    if (f.headId && !headId) {
                        headId = f.headId;
                        headName = f.headName;
                    }
                });
                
                // Отримуємо імена всіх виконавців
                allAssigneeIds = Array.from(allAssigneeIds);
                allAssigneeNames = allAssigneeIds.map(id => {
                    const user = users.find(u => u.id === id);
                    return user?.name || user?.email || '';
                }).filter(n => n);
                
                // Створюємо нову функцію
                const mergedFunctionData = {
                    name: newName,
                    description: `${t('mergedFrom')}: ${selectedFunctions.map(f => f.name).join(', ')}`,
                    headId: headId,
                    headName: headName,
                    assigneeIds: allAssigneeIds,
                    assigneeNames: allAssigneeNames,
                    mergedFrom: selectedFunctions.map(f => ({ id: f.id, name: f.name, mergedAt: new Date().toISOString() })),
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    status: 'active'
                };
                
                const newFuncRef = await db.collection('companies').doc(currentCompany).collection('functions').add(mergedFunctionData);
                
                // Оновлюємо завдання - переносимо на нову функцію
                let batch = db.batch();
                let batchCount = 0;
                
                for (const f of selectedFunctions) {
                    // Оновлюємо tasks
                    const tasksToUpdate = tasks.filter(t => t.function === f.name);
                    for (const task of tasksToUpdate) {
                        const taskRef = db.collection('companies').doc(currentCompany).collection('tasks').doc(task.id);
                        batch.update(taskRef, { 
                            function: newName,
                            originalFunction: task.originalFunction || f.name
                        });
                        batchCount++;
                        
                        // Firebase batch limit = 500
                        if (batchCount >= 450) {
                            await batch.commit();
                            batch = db.batch();
                            batchCount = 0;
                        }
                    }
                    
                    // Оновлюємо regularTasks
                    const regularToUpdate = regularTasks.filter(rt => rt.function === f.name);
                    for (const rt of regularToUpdate) {
                        const rtRef = db.collection('companies').doc(currentCompany).collection('regularTasks').doc(rt.id);
                        batch.update(rtRef, { 
                            function: newName,
                            originalFunction: rt.originalFunction || f.name
                        });
                        batchCount++;
                        
                        if (batchCount >= 450) {
                            await batch.commit();
                            batch = db.batch();
                            batchCount = 0;
                        }
                    }
                    
                    // Архівуємо стару функцію (не видаляємо)
                    const funcRef = db.collection('companies').doc(currentCompany).collection('functions').doc(f.id);
                    batch.update(funcRef, {
                        status: 'archived',
                        archivedAt: new Date().toISOString(),
                        mergedInto: newFuncRef.id,
                        mergedIntoName: newName
                    });
                    batchCount++;
                }
                
                if (batchCount > 0) {
                    await batch.commit();
                }
                
                closeModal('mergeFunctionsModal');
                
                // Оновлюємо локальні дані
                await loadAllData();
                
                alert(t('mergeSuccess'));
                
            } catch (error) {
                console.error('Merge functions error:', error);
                alert(t('error') + ': ' + error.message);
            } finally {
                executeBtn.disabled = false;
                executeBtn.innerHTML = `<i data-lucide="git-merge" class="icon"></i> <span data-i18n="merge">${t('merge')}</span>`;
                refreshIcons();
            }
        }

        // =====================
        // PROCESSES (Направляючі форми)
        // =====================
        let processTemplates = [];
        let processes = [];
        let showCompletedProcesses = false;
        
        async function loadProcessData() {
            if (!currentCompany) return;
            
            try {
                // Завантажуємо шаблони
                const templatesSnap = await db.collection('companies').doc(currentCompany)
                    .collection('processTemplates').orderBy('name').get();
                processTemplates = templatesSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                // Завантажуємо процеси (активні або всі в залежності від фільтру)
                let processQuery = db.collection('companies').doc(currentCompany).collection('processes');
                if (!showCompletedProcesses) {
                    processQuery = processQuery.where('status', '==', 'active');
                }
                const processesSnap = await processQuery.get();
                processes = processesSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                updateProcessTemplateFilter();
            } catch (error) {
                console.error('loadProcessData error:', error);
            }
        }
        
        function toggleShowCompletedProcesses() {
            showCompletedProcesses = !showCompletedProcesses;
            const btn = document.getElementById('toggleCompletedBtn');
            if (btn) {
                btn.classList.toggle('active', showCompletedProcesses);
            }
            loadProcessData().then(() => renderProcessBoard());
        }
        
        function updateProcessTemplateFilter() {
            const select = document.getElementById('processTemplateFilter');
            if (!select) return;
            select.innerHTML = `<option value="">${t('allProcesses')}</option>` + 
                processTemplates.map(pt => `<option value="${esc(pt.id)}">${esc(pt.name)}</option>`).join('');
        }
        
        function renderProcessBoard() {
            const container = document.getElementById('processBoard');
            const emptyState = document.getElementById('processesEmptyState');
            const filterValue = document.getElementById('processTemplateFilter')?.value;
            const assigneeFilter = document.getElementById('processAssigneeFilter')?.value;
            
            // Оновлюємо select виконавців (одноразово)
            const paf = document.getElementById('processAssigneeFilter');
            if (paf && paf.options.length <= 1) {
                paf.innerHTML = `<option value="">${t('allAssignees')}</option>` + users.map(u => `<option value="${esc(u.id)}">${esc(u.name || u.email)}</option>`).join('');
            }
            
            // Фільтруємо процеси
            let filteredProcesses = processes;
            if (filterValue) {
                filteredProcesses = filteredProcesses.filter(p => p.templateId === filterValue);
            }
            if (assigneeFilter) {
                filteredProcesses = filteredProcesses.filter(p => {
                    const template = processTemplates.find(t => t.id === p.templateId);
                    if (!template?.steps?.length) return false;
                    const currentStepIndex = Math.min(p.currentStep || 0, template.steps.length - 1);
                    const stepFunc = template.steps[currentStepIndex]?.function;
                    if (!stepFunc) return false;
                    const func = functions.find(f => f.name === stepFunc);
                    return func?.assigneeIds?.includes(assigneeFilter);
                });
            }
            
            if (filteredProcesses.length === 0) {
                container.style.display = 'none';
                emptyState.style.display = 'block';
                refreshIcons();
                return;
            }
            
            container.style.display = 'flex';
            emptyState.style.display = 'none';
            
            const todayStr = getLocalDateStr();
            
            // Сортуємо: активні overdue першими, потім по прогресу (менший прогрес = вище), завершені внизу
            const sorted = filteredProcesses.map(p => {
                const template = processTemplates.find(t => t.id === p.templateId);
                const totalSteps = template?.steps?.length || 1;
                const currentStep = p.status === 'completed' ? totalSteps : Math.min(p.currentStep || 0, totalSteps - 1);
                const percent = Math.round((currentStep / totalSteps) * 100);
                const isOverdue = p.status !== 'completed' && p.deadline && p.deadline < todayStr;
                return { ...p, template, totalSteps, currentStep, percent, isOverdue };
            }).sort((a, b) => {
                if (a.status === 'completed' && b.status !== 'completed') return 1;
                if (a.status !== 'completed' && b.status === 'completed') return -1;
                if (a.isOverdue && !b.isOverdue) return -1;
                if (!a.isOverdue && b.isOverdue) return 1;
                return a.percent - b.percent;
            });
            
            container.innerHTML = sorted.map(p => renderProcessPipelineRow(p)).join('');
            
            // Оновлюємо лічильник
            const activeCount = processes.filter(p => p.status === 'active').length;
            const counter = document.getElementById('processesCounter');
            if (counter) {
                counter.textContent = activeCount > 0 ? activeCount : '';
                counter.style.display = activeCount > 0 ? 'inline' : 'none';
            }
            
            refreshIcons();
        }
        
        function renderProcessPipelineRow(process) {
            const template = process.template;
            if (!template?.steps?.length) return '';
            
            const totalSteps = process.totalSteps;
            const currentStep = process.currentStep;
            const percent = process.percent;
            const isCompleted = process.status === 'completed';
            const isOverdue = process.isOverdue;
            const todayStr = getLocalDateStr();
            
            // Знаходимо відповідального за поточний крок
            let currentAssignee = '';
            if (!isCompleted && template.steps[currentStep]) {
                const stepFunc = template.steps[currentStep].function;
                const func = functions.find(f => f.name === stepFunc);
                if (func?.assigneeIds?.length) {
                    const assignee = users.find(u => func.assigneeIds.includes(u.id));
                    currentAssignee = assignee?.name || '';
                }
            }
            
            // Pipeline steps — горизонтальні етапи
            const stepsHTML = template.steps.map((step, i) => {
                let cls = 'pending';
                if (isCompleted || i < currentStep) cls = 'done';
                else if (i === currentStep) cls = 'active';
                
                const label = step.function || `Крок ${i + 1}`;
                
                return `<div class="pipeline-step ${cls}" title="${esc(step.name || label)}">
                    <span class="pipeline-step-label">${esc(label)}</span>
                </div>`;
            }).join('<div class="pipeline-arrow">›</div>');
            
            // Deadline display
            let deadlineHTML = '';
            if (process.deadline) {
                if (isOverdue) {
                    const daysAgo = Math.floor((new Date(todayStr) - new Date(process.deadline)) / 86400000);
                    deadlineHTML = `<span class="overdue-badge"><i data-lucide="alert-circle" class="icon icon-sm"></i> ${daysAgo}д прострочено</span>`;
                } else {
                    const dp = process.deadline.split('-');
                    const dayNum = parseInt(dp[2]);
                    const monthShort = ['січ','лют','бер','кві','тра','чер','лип','сер','вер','жов','лис','гру'][parseInt(dp[1]) - 1];
                    deadlineHTML = `<span><i data-lucide="calendar" class="icon icon-sm"></i> ${dayNum} ${monthShort}</span>`;
                }
            }
            
            const rowClass = isCompleted ? 'completed' : (isOverdue ? 'overdue' : '');
            
            return `
                <div class="process-pipeline-row ${rowClass}" onclick="openViewProcessModal('${escId(process.id)}')">
                    <div class="process-row-top">
                        <div class="process-row-title">
                            ${isCompleted ? '<i data-lucide="check-circle" class="icon icon-sm" style="color:var(--primary);vertical-align:-2px;"></i> ' : ''}${esc(process.name)}
                        </div>
                        <div class="process-row-meta">
                            <span style="color:#888;font-size:0.75rem;">${esc(template.name)}</span>
                            ${currentAssignee ? `<span class="process-row-assignee"><i data-lucide="user" class="icon icon-sm"></i> ${esc(currentAssignee)}</span>` : ''}
                            ${deadlineHTML}
                            <span class="process-row-percent ${isCompleted ? 'complete' : ''}">${percent}%</span>
                        </div>
                    </div>
                    <div class="process-pipeline-steps">
                        ${stepsHTML}
                    </div>
                </div>
            `;
        }
        
        // =====================
        // PROJECTS
        // =====================
        let currentProjectView = 'grid';
        let openProjectId = null;
        
        function openProjectModal(projectId = null) {
            const project = projectId ? projects.find(p => p.id === projectId) : null;
            document.getElementById('projectEditId').value = projectId || '';
            document.getElementById('projectName').value = project?.name || '';
            document.getElementById('projectStartDate').value = project?.startDate || getLocalDateStr();
            document.getElementById('projectDeadline').value = project?.deadline || '';
            document.getElementById('projectDescription').value = project?.description || '';
            
            const color = project?.color || '#22c55e';
            // Reset all, then set matching
            document.querySelectorAll('input[name="projectColor"]').forEach(r => r.checked = false);
            const colorInput = document.querySelector(`input[name="projectColor"][value="${color}"]`);
            if (colorInput) colorInput.checked = true;
            else document.querySelector('input[name="projectColor"]').checked = true; // fallback to first
            
            document.getElementById('projectModalTitle').textContent = project ? t('editProject') : t('newProject');
            document.getElementById('projectModal').style.display = 'block';
            refreshIconsNow();
        }
        
        let isSavingProject = false;
        async function saveProject(e) {
            e.preventDefault();
            if (isSavingProject) return;
            isSavingProject = true;
            const submitBtn = document.querySelector('#projectForm button[type="submit"]');
            if (submitBtn) submitBtn.disabled = true;
            const id = document.getElementById('projectEditId').value;
            const data = {
                name: document.getElementById('projectName').value.trim(),
                startDate: document.getElementById('projectStartDate').value,
                deadline: document.getElementById('projectDeadline').value,
                description: document.getElementById('projectDescription').value.trim(),
                color: document.querySelector('input[name="projectColor"]:checked')?.value || '#22c55e'
            };
            if (!data.name) { isSavingProject = false; if (submitBtn) submitBtn.disabled = false; return; }
            
            try {
                const base = db.collection('companies').doc(currentCompany).collection('projects');
                if (id) {
                    // Не перезаписуємо status при редагуванні
                    data.updatedAt = firebase.firestore.FieldValue.serverTimestamp();
                    await base.doc(id).update(data);
                    const idx = projects.findIndex(p => p.id === id);
                    if (idx >= 0) projects[idx] = { ...projects[idx], ...data };
                } else {
                    data.status = 'active';
                    data.createdAt = firebase.firestore.FieldValue.serverTimestamp();
                    data.creatorId = currentUser.uid;
                    const ref = await base.add(data);
                    projects.unshift({ id: ref.id, ...data });
                }
                closeModal('projectModal');
                renderProjects();
                updateProjectSelects();
            } catch (err) {
                console.error('[Projects] Save error:', err);
                showToast(t('error') + ': ' + t('save'), 'error');
            } finally {
                isSavingProject = false;
                if (submitBtn) submitBtn.disabled = false;
            }
        }
        
        async function deleteProject(projectId) {
            if (currentUserData?.role === 'employee') { showToast(t('noPermissionTask'), 'error'); return; }
            const s = getProjectStats(projectId);
            const msg = s.total > 0 
                ? (t('deleteProjectWithTasks') || 'Видалити проєкт?').replace('{total}', s.total).replace('{undone}', s.total - s.done)
                : (t('deleteEmptyProject') || 'Видалити порожній проєкт?');
            if (!confirm(msg)) return;
            try {
                await db.collection('companies').doc(currentCompany).collection('projects').doc(projectId).delete();
                projects = projects.filter(p => p.id !== projectId);
                // Знімаємо projectId з задач (batch для атомарності)
                const orphaned = tasks.filter(t => t.projectId === projectId);
                if (orphaned.length > 0) {
                    const cleanBatch = db.batch();
                    orphaned.forEach(t => {
                        cleanBatch.update(
                            db.collection('companies').doc(currentCompany).collection('tasks').doc(t.id),
                            { projectId: '' }
                        );
                        t.projectId = '';
                    });
                    await cleanBatch.commit();
                }
                if (openProjectId === projectId) closeProjectDetail();
                renderProjects();
                updateProjectSelects();
                if (orphaned.length > 0) showToast(t('tasksUnlinked').replace('{n}', orphaned.length), 'info');
            } catch (err) {
                console.error('[Projects] Delete error:', err);
            }
        }
        
        function getProjectStats(projectId) {
            const projectTasks = tasks.filter(t => t.projectId === projectId && isTaskVisibleToUser(t));
            const total = projectTasks.length;
            const done = projectTasks.filter(t => t.status === 'done').length;
            const inProgress = projectTasks.filter(t => t.status === 'progress').length;
            const review = projectTasks.filter(t => t.status === 'review').length;
            const overdue = projectTasks.filter(t => t.deadlineDate && t.deadlineDate < getLocalDateStr() && t.status !== 'done' && t.status !== 'review').length;
            const percent = total > 0 ? Math.round((done / total) * 100) : 0;
            
            // FIX 3: Конфлікт дедлайнів
            const project = projects.find(p => p.id === projectId);
            const deadlineConflicts = [];
            if (project?.deadline) {
                projectTasks.forEach(t => {
                    if (t.deadlineDate && t.deadlineDate > project.deadline && t.status !== 'done') {
                        deadlineConflicts.push(t);
                    }
                });
            }
            
            return { total, done, inProgress, review, overdue, percent, tasks: projectTasks, deadlineConflicts };
        }
        
        // FIX 4: Автооновлення статусу проекту
        const _projectStatusTimers = {};
        
        async function autoUpdateProjectStatus(projectId) {
            if (!projectId) return;
            const project = projects.find(p => p.id === projectId);
            if (!project || project.status === 'paused') return;
            
            // Debounce: coalesce rapid updates (batch complete etc)
            if (_projectStatusTimers[projectId]) clearTimeout(_projectStatusTimers[projectId]);
            _projectStatusTimers[projectId] = setTimeout(() => {
                delete _projectStatusTimers[projectId];
                _doProjectStatusUpdate(projectId);
            }, 500);
        }
        
        async function _doProjectStatusUpdate(projectId) {
            const project = projects.find(p => p.id === projectId);
            if (!project || project.status === 'paused') return;
            
            const allProjectTasks = tasks.filter(t => t.projectId === projectId);
            const total = allProjectTasks.length;
            if (total === 0) return;
            
            const doneCount = allProjectTasks.filter(t => t.status === 'done').length;
            const activeCount = allProjectTasks.filter(t => t.status === 'progress' || t.status === 'review').length;
            
            let newStatus = project.status;
            if (doneCount === total) newStatus = 'completed';
            else if (project.status === 'completed' && doneCount < total) newStatus = 'active';
            else if (doneCount > 0 || activeCount > 0) newStatus = 'active';
            
            if (newStatus !== project.status) {
                const oldStatus = project.status;
                project.status = newStatus;
                try {
                    const projRef = db.collection('companies').doc(currentCompany).collection('projects').doc(projectId);
                    await db.runTransaction(async (tx) => {
                        const doc = await tx.get(projRef);
                        if (!doc.exists) return;
                        const serverStatus = doc.data().status;
                        // Only update if no one else changed it
                        if (serverStatus === oldStatus) {
                            tx.update(projRef, { status: newStatus, updatedAt: firebase.firestore.FieldValue.serverTimestamp() });
                        } else {
                            project.status = serverStatus; // sync from server
                        }
                    });
                    if (project.status === newStatus) {
                        const label = newStatus === 'completed' ? t('projectCompleted') : t('projectActive');
                        showToast(t('projectStatusChanged').replace('{name}', project.name).replace('{status}', label), 'success');
                    }
                } catch(e) {
                    project.status = oldStatus;
                    console.warn('autoUpdateProjectStatus error:', e);
                }
                renderProjects();
                if (openProjectId === projectId) renderProjectDetail(projectId);
            }
        }
        
        function setProjectView(view) {
            currentProjectView = view;
            const tab = document.getElementById('projectsTab');
            if (tab) tab.querySelectorAll('.calendar-view-btn').forEach(b => b.classList.toggle('active', b.dataset.view === view));
            renderProjects();
        }
        
        function renderProjects() {
            const container = document.getElementById('projectsContent');
            const emptyState = document.getElementById('projectsEmptyState');
            const detailView = document.getElementById('projectDetailView');
            const header = document.getElementById('projectsHeader');
            
            if (openProjectId) {
                container.style.display = 'none';
                emptyState.style.display = 'none';
                header.style.display = 'none';
                detailView.style.display = 'block';
                renderProjectDetail(openProjectId);
                return;
            }
            
            detailView.style.display = 'none';
            header.style.display = 'flex';
            
            const statusFilter = document.getElementById('projectStatusFilter')?.value || '';
            let filtered = projects;
            if (statusFilter) filtered = filtered.filter(p => p.status === statusFilter);
            
            const counter = document.getElementById('projectsCounter');
            const activeCount = projects.filter(p => p.status === 'active').length;
            if (counter) { counter.textContent = activeCount || ''; counter.style.display = activeCount ? 'inline' : 'none'; }
            
            if (filtered.length === 0) {
                container.style.display = 'none';
                emptyState.style.display = 'block';
                return;
            }
            
            container.style.display = 'block';
            emptyState.style.display = 'none';
            
            // Sync view switcher buttons
            const tab = document.getElementById('projectsTab');
            if (tab) tab.querySelectorAll('.calendar-view-btn').forEach(b => b.classList.toggle('active', b.dataset.view === currentProjectView));
            
            if (currentProjectView === 'grid') renderProjectsGrid(container, filtered);
            else if (currentProjectView === 'list') renderProjectsList(container, filtered);
            else if (currentProjectView === 'timeline') renderProjectsTimeline(container, filtered);
            
            refreshIcons();
        }
        
        function renderProjectsGrid(container, filtered) {
            const todayStr = getLocalDateStr();
            container.innerHTML = `<div class="projects-grid">${filtered.map(p => {
                const s = getProjectStats(p.id);
                const isOverdue = p.deadline && p.deadline < todayStr && p.status === 'active';
                return `
                <div class="project-card" style="--pc:${safeColor(p.color)};" onclick="openProjectDetail('${escId(p.id)}')">
                    <div style="position:absolute;top:0;left:0;right:0;height:4px;background:${safeColor(p.color)};border-radius:12px 12px 0 0;"></div>
                    <div class="project-card-header">
                        <div class="project-card-title">${esc(p.name)}</div>
                        <span class="project-card-status ${['active','paused','completed'].includes(p.status) ? p.status : 'active'}">${p.status === 'active' ? t('projectActive') : p.status === 'completed' ? t('projectCompleted') : t('projectPaused')}</span>
                    </div>
                    ${p.description ? `<div class="project-card-desc">${esc(p.description)}</div>` : ''}
                    <div class="project-card-stats">
                        <span><i data-lucide="clipboard-list" class="icon icon-sm"></i> ${s.total} завдань</span>
                        <span><i data-lucide="check-circle" class="icon icon-sm"></i> ${s.done} готово</span>
                        ${s.overdue > 0 ? `<span style="color:var(--danger);font-weight:600;"><i data-lucide="alert-circle" class="icon icon-sm"></i> ${s.overdue} прострочено</span>` : ''}
                        ${s.deadlineConflicts.length > 0 ? `<span style="color:#ea580c;font-weight:600;"><i data-lucide="alert-triangle" class="icon icon-sm"></i> ${s.deadlineConflicts.length} за дедлайном</span>` : ''}
                    </div>
                    <div class="project-progress-bar"><div class="project-progress-fill" style="width:${s.percent}%;background:${safeColor(p.color)};"></div></div>
                    <div class="project-progress-label"><span>${s.done}/${s.total}</span><span>${s.percent}%</span></div>
                    ${p.deadline ? `<div class="project-card-deadline ${isOverdue ? 'overdue' : ''}"><i data-lucide="calendar" class="icon icon-sm"></i> ${formatDateShort(p.deadline)}</div>` : ''}
                </div>`;
            }).join('')}</div>`;
        }
        
        function renderProjectsList(container, filtered) {
            const todayStr = getLocalDateStr();
            container.innerHTML = `<table class="projects-list-table"><thead><tr>
                <th>Назва</th><th>Статус</th><th>Завдання</th><th>Прогрес</th><th>Дедлайн</th><th></th>
            </tr></thead><tbody>${filtered.map(p => {
                const s = getProjectStats(p.id);
                const isOverdue = p.deadline && p.deadline < todayStr && p.status === 'active';
                return `<tr onclick="openProjectDetail('${escId(p.id)}')">
                    <td><span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:${safeColor(p.color)};margin-right:0.5rem;vertical-align:middle;"></span><strong>${esc(p.name)}</strong></td>
                    <td><span class="project-card-status ${['active','paused','completed'].includes(p.status) ? p.status : 'active'}">${p.status === 'active' ? t('projectActive') : p.status === 'completed' ? t('projectCompleted') : t('projectPaused')}</span></td>
                    <td>${s.done}/${s.total}</td>
                    <td><div class="project-progress-bar" style="width:100px;display:inline-block;vertical-align:middle;"><div class="project-progress-fill" style="width:${s.percent}%;background:${safeColor(p.color)};"></div></div> ${s.percent}%</td>
                    <td class="${isOverdue ? 'project-card-deadline overdue' : ''}">${p.deadline ? formatDateShort(p.deadline) : '—'}</td>
                    <td><button class="action-btn" onclick="event.stopPropagation();openProjectModal('${escId(p.id)}')" title="Edit"><i data-lucide="pencil" class="icon icon-sm"></i></button></td>
                </tr>`;
            }).join('')}</tbody></table>`;
        }
        
        function renderProjectsTimeline(container, filtered) {
            const todayStr = getLocalDateStr();
            const today = new Date();
            
            // Визначаємо діапазон: мін startDate — макс deadline (+30 днів)
            let minDate = new Date();
            let maxDate = new Date();
            maxDate.setDate(maxDate.getDate() + 60);
            
            filtered.forEach(p => {
                if (p.startDate) { const d = new Date(p.startDate); if (d < minDate) minDate = d; }
                if (p.deadline) { const d = new Date(p.deadline); if (d > maxDate) maxDate = d; }
            });
            
            minDate.setDate(minDate.getDate() - 7);
            maxDate.setDate(maxDate.getDate() + 7);
            
            const totalDays = Math.ceil((maxDate - minDate) / 86400000);
            
            // Генеруємо header тижнів
            const weeks = [];
            const d = new Date(minDate);
            while (d <= maxDate) {
                const weekNum = getWeekNumber(d);
                if (!weeks.length || weeks[weeks.length - 1].num !== weekNum) {
                    weeks.push({ num: weekNum, start: new Date(d), days: 0 });
                }
                weeks[weeks.length - 1].days++;
                d.setDate(d.getDate() + 1);
            }
            
            const headerHTML = weeks.map(w => {
                const pct = (w.days / totalDays * 100).toFixed(2);
                const monthShort = ['Січ','Лют','Бер','Кві','Тра','Чер','Лип','Сер','Вер','Жов','Лис','Гру'][w.start.getMonth()];
                return `<div class="timeline-header-label" style="flex:${pct};">${monthShort} T${w.num}</div>`;
            }).join('');
            
            const rowsHTML = filtered.map(p => {
                const s = getProjectStats(p.id);
                const start = p.startDate ? new Date(p.startDate) : today;
                const end = p.deadline ? new Date(p.deadline) : new Date(start.getTime() + 30 * 86400000);
                
                const leftPct = Math.max(0, (start - minDate) / (maxDate - minDate) * 100);
                const widthPct = Math.min(100 - leftPct, Math.max(2, (end - start) / (maxDate - minDate) * 100));
                
                return `
                <div class="timeline-row">
                    <div class="timeline-row-label" onclick="openProjectDetail('${escId(p.id)}')" style="color:${safeColor(p.color)};">${esc(p.name)}</div>
                    <div class="timeline-row-bar-area">
                        <div class="timeline-bar" title="${esc(p.name)}: ${s.percent}% (${s.done}/${s.total})" style="left:${leftPct}%;width:${widthPct}%;background:${safeColor(p.color)};" onclick="openProjectDetail('${escId(p.id)}')">
                            <div class="timeline-bar-progress" style="width:${s.percent}%;"></div>
                            ${s.percent}% (${s.done}/${s.total})
                        </div>
                    </div>
                </div>`;
            }).join('');
            
            // Лінія "Сьогодні" — рахуємо в JS
            const todayPctNum = ((today - minDate) / (maxDate - minDate) * 100);
            
            container.innerHTML = `
                <div class="project-timeline" style="overflow-x:auto;">
                    <div style="min-width:800px;">
                        <div class="timeline-header">${headerHTML}</div>
                        <div style="position:relative;">
                            <div style="position:absolute;left:calc(180px + (100% - 180px) * ${todayPctNum / 100});top:0;bottom:0;width:2px;background:#ef4444;opacity:0.5;z-index:1;"></div>
                            ${rowsHTML}
                        </div>
                    </div>
                </div>`;
        }
        
        function getWeekNumber(d) {
            const oneJan = new Date(d.getFullYear(), 0, 1);
            return Math.ceil(((d - oneJan) / 86400000 + oneJan.getDay() + 1) / 7);
        }
        
        // === PROJECT DETAIL VIEW ===
        function openProjectDetail(projectId) {
            openProjectId = projectId;
            renderProjects();
        }
        
        function openTaskForProject(projectId) {
            openTaskModal();
            // After modal opens and form resets, set projectId
            requestAnimationFrame(() => {
                setTimeout(() => {
                    updateProjectSelects(projectId);
                    const sel = document.getElementById('taskProject');
                    if (sel) sel.value = projectId;
                }, 0);
            });
        }
        
        function closeProjectDetail() {
            openProjectId = null;
            document.getElementById('projectDetailView').style.display = 'none';
            document.getElementById('projectsContent').style.display = 'block';
            document.getElementById('projectsHeader').style.display = 'flex';
            renderProjects();
        }
        
        function renderProjectDetail(projectId) {
            const project = projects.find(p => p.id === projectId);
            if (!project) { closeProjectDetail(); return; }
            
            const s = getProjectStats(projectId);
            const container = document.getElementById('projectDetailContent');
            
            const statusOptions = ['active', 'paused', 'completed'].map(st => 
                `<option value="${st}" ${project.status === st ? 'selected' : ''}>${st === 'active' ? t('projectActive') : st === 'completed' ? t('projectCompleted') : t('projectPaused')}</option>`
            ).join('');
            
            // Board columns
            const columns = [
                { key: 'new', label: t('statusNew'), color: '#3b82f6' },
                { key: 'progress', label: t('statusProgress'), color: '#f59e0b' },
                { key: 'review', label: t('statusReview'), color: '#8b5cf6' },
                { key: 'done', label: t('statusDone'), color: '#22c55e' }
            ];
            
            const boardHTML = columns.map(col => {
                const colTasks = s.tasks.filter(t => t.status === col.key);
                return `
                <div class="project-board-col">
                    <div class="project-board-col-header" style="border-bottom-color:${col.color};">
                        <span>${col.label}</span>
                        <span style="background:${col.color};color:white;font-size:0.7rem;padding:0.1rem 0.4rem;border-radius:8px;">${colTasks.length}</span>
                    </div>
                    <div class="project-board-col-cards">
                        ${colTasks.length === 0 ? '<div style="text-align:center;color:#ccc;font-size:0.8rem;padding:1rem;">—</div>' : ''}
                        ${colTasks.map(t => {
                            const assignee = t.assigneeName || '';
                            return `
                            <div class="project-task-card priority-${t.priority || 'medium'}" onclick="openTaskModal('${escId(t.id)}')">
                                <div class="project-task-card-title">${esc(t.title)}</div>
                                <div class="project-task-card-meta">
                                    ${assignee ? `<span><i data-lucide="user" class="icon icon-sm"></i> ${esc(assignee)}</span>` : ''}
                                    ${t.deadlineDate ? `<span><i data-lucide="calendar" class="icon icon-sm"></i> ${formatDateShort(t.deadlineDate)}</span>` : ''}
                                </div>
                            </div>`;
                        }).join('')}
                    </div>
                </div>`;
            }).join('');
            
            container.innerHTML = `
                <div class="project-detail-header">
                    <div class="project-detail-back" onclick="closeProjectDetail()">
                        <i data-lucide="arrow-left" class="icon"></i>
                        <span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:${safeColor(project.color)};"></span>
                        ${esc(project.name)}
                    </div>
                    <div style="display:flex;align-items:center;gap:0.5rem;">
                        <button class="btn btn-success btn-small" onclick="openTaskForProject('${escId(projectId)}')"><i data-lucide="plus" class="icon icon-sm"></i> Завдання</button>
                        <select class="filter-select" onchange="updateProjectStatus('${escId(projectId)}', this.value)" style="font-size:0.8rem;padding:0.3rem;">${statusOptions}</select>
                        <button class="btn btn-small" onclick="openProjectModal('${escId(projectId)}')"><i data-lucide="pencil" class="icon icon-sm"></i></button>
                        <button class="btn btn-small btn-danger" onclick="deleteProject('${escId(projectId)}')"><i data-lucide="trash-2" class="icon icon-sm"></i></button>
                    </div>
                </div>
                
                <div style="display:flex;gap:1.5rem;margin-bottom:1rem;flex-wrap:wrap;">
                    <div style="background:white;border-radius:10px;padding:0.75rem 1.25rem;border:1px solid #e5e7eb;flex:1;min-width:120px;">
                        <div style="font-size:0.75rem;color:var(--gray);">${t('totalTasks')}</div>
                        <div style="font-size:1.5rem;font-weight:700;">${s.total}</div>
                    </div>
                    <div style="background:white;border-radius:10px;padding:0.75rem 1.25rem;border:1px solid #e5e7eb;flex:1;min-width:120px;">
                        <div style="font-size:0.75rem;color:var(--gray);">${t('statusDone')}</div>
                        <div style="font-size:1.5rem;font-weight:700;color:var(--primary);">${s.done}</div>
                    </div>
                    <div style="background:white;border-radius:10px;padding:0.75rem 1.25rem;border:1px solid #e5e7eb;flex:1;min-width:120px;">
                        <div style="font-size:0.75rem;color:var(--gray);">${t('completionRate')}</div>
                        <div style="font-size:1.5rem;font-weight:700;color:${safeColor(project.color)};">${s.percent}%</div>
                    </div>
                    ${s.overdue > 0 ? `<div style="background:#fef2f2;border-radius:10px;padding:0.75rem 1.25rem;border:1px solid #fecaca;flex:1;min-width:120px;">
                        <div style="font-size:0.75rem;color:var(--danger);">${t('overdueLabel2')}</div>
                        <div style="font-size:1.5rem;font-weight:700;color:var(--danger);">${s.overdue}</div>
                    </div>` : ''}
                </div>
                
                <div class="project-progress-bar" style="height:8px;margin-bottom:1rem;">
                    <div class="project-progress-fill" style="width:${s.percent}%;background:${safeColor(project.color)};"></div>
                </div>
                
                ${s.deadlineConflicts.length > 0 ? `
                <div style="background:#fff7ed;border:1px solid #fed7aa;border-radius:10px;padding:0.75rem 1rem;margin-bottom:1rem;display:flex;gap:0.5rem;align-items:flex-start;">
                    <i data-lucide="alert-triangle" class="icon" style="width:18px;height:18px;color:#ea580c;flex-shrink:0;margin-top:2px;"></i>
                    <div>
                        <div style="font-weight:600;font-size:0.85rem;color:#c2410c;margin-bottom:0.25rem;">
                            ${s.deadlineConflicts.length} ${s.deadlineConflicts.length === 1 ? 'завдання виходить' : 'завдань виходять'} за дедлайн проєкту (${formatDateShort(project.deadline)})
                        </div>
                        <div style="font-size:0.8rem;color:#9a3412;">
                            ${s.deadlineConflicts.slice(0, 3).map(t => `• ${esc(t.title)} — ${formatDateShort(t.deadlineDate)}`).join('<br>')}
                            ${s.deadlineConflicts.length > 3 ? `<br>...та ще ${s.deadlineConflicts.length - 3}` : ''}
                        </div>
                    </div>
                </div>` : ''}
                
                <!-- View Switcher -->
                <div style="display:flex;gap:0.5rem;margin-bottom:1rem;">
                    <button class="calendar-view-btn active" onclick="switchProjectView('board', this)" style="padding:0.4rem 0.8rem;font-size:0.8rem;">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align:-2px;"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/></svg>
                        Kanban
                    </button>
                    <button class="calendar-view-btn" onclick="switchProjectView('gantt', this)" style="padding:0.4rem 0.8rem;font-size:0.8rem;">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align:-2px;"><line x1="4" y1="6" x2="16" y2="6"/><line x1="8" y1="12" x2="20" y2="12"/><line x1="4" y1="18" x2="14" y2="18"/></svg>
                        Gantt
                    </button>
                </div>
                
                <div id="projectBoardView" class="project-board-columns">${boardHTML}</div>
                <div id="projectGanttView" style="display:none;">${renderProjectGantt(s.tasks, project)}</div>
            `;
            
            refreshIcons();
        }
        
        function switchProjectView(view, btn) {
            document.getElementById('projectBoardView').style.display = view === 'board' ? '' : 'none';
            document.getElementById('projectGanttView').style.display = view === 'gantt' ? '' : 'none';
            btn.parentElement.querySelectorAll('.calendar-view-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
        }
        
        function renderProjectGantt(projectTasks, project) {
            if (!projectTasks.length) return '<div style="text-align:center;color:#999;padding:2rem;">Немає завдань для діаграми</div>';
            
            const today = new Date();
            const todayStr = getLocalDateStr(today);
            
            // Find date range
            const dates = projectTasks
                .filter(t => t.deadlineDate)
                .map(t => new Date(t.deadlineDate));
            
            if (dates.length === 0) return '<div style="text-align:center;color:#999;padding:2rem;">Завдання без дат — Gantt неможливий</div>';
            
            // Add today to range
            dates.push(today);
            
            let minDate = new Date(Math.min(...dates));
            let maxDate = new Date(Math.max(...dates));
            
            // Pad range: 2 days before, 3 days after
            minDate.setDate(minDate.getDate() - 2);
            maxDate.setDate(maxDate.getDate() + 3);
            
            // Generate day columns
            const days = [];
            const d = new Date(minDate);
            while (d <= maxDate) {
                days.push(new Date(d));
                d.setDate(d.getDate() + 1);
            }
            
            const totalDays = days.length;
            const dayWidth = Math.max(36, Math.floor(800 / totalDays));
            const chartWidth = dayWidth * totalDays;
            
            // Status colors
            const statusColors = {
                new: { bg: '#dbeafe', border: '#3b82f6' },
                progress: { bg: '#fef3c7', border: '#f59e0b' },
                review: { bg: '#e0e7ff', border: '#6366f1' },
                done: { bg: '#d1fae5', border: '#10b981' }
            };
            
            const statusLabels = { new: t('statusNew'), progress: t('statusProgress'), review: t('statusReview'), done: t('statusDone') };
            
            // Sort tasks by date
            const sorted = [...projectTasks].sort((a, b) => {
                const da = a.deadlineDate || '9999';
                const db = b.deadlineDate || '9999';
                return da.localeCompare(db);
            });
            
            // Day headers
            const months = getMonthNames();
            const dayNames = [t('daySun'), t('dayMon'), t('dayTue'), t('dayWed'), t('dayThu'), t('dayFri'), t('daySat')];
            
            let headerHTML = days.map((day, i) => {
                const isToday = getLocalDateStr(day) === todayStr;
                const isWeekend = day.getDay() === 0 || day.getDay() === 6;
                return `<div style="width:${dayWidth}px;min-width:${dayWidth}px;text-align:center;font-size:0.65rem;padding:4px 0;${isToday ? 'background:#f0fdf4;font-weight:700;color:#16a34a;' : isWeekend ? 'color:#d1d5db;' : 'color:#9ca3af;'}">
                    <div>${day.getDate() === 1 || i === 0 ? months[day.getMonth()] : ''}</div>
                    <div style="font-size:0.75rem;font-weight:${isToday ? '700' : '500'};">${day.getDate()}</div>
                    <div>${dayNames[day.getDay()]}</div>
                </div>`;
            }).join('');
            
            // Task rows
            let rowsHTML = sorted.map(task => {
                const color = statusColors[task.status] || statusColors.new;
                const assignee = task.assigneeName ? esc(task.assigneeName).split(' ')[0] : '';
                
                if (!task.deadlineDate) {
                    return `<div style="display:flex;align-items:center;height:36px;border-bottom:1px solid #f3f4f6;">
                        <div style="width:100%;padding:0 8px;font-size:0.75rem;color:#d1d5db;font-style:italic;">
                            ${esc(task.title)} — без дати
                        </div>
                    </div>`;
                }
                
                const taskDate = new Date(task.deadlineDate);
                const durationDays = Math.max(1, Math.ceil((parseInt(task.estimatedTime || task.duration || '60')) / 480)); // 8h workday
                const startDate = new Date(taskDate);
                startDate.setDate(startDate.getDate() - durationDays + 1);
                
                // Calculate position
                const startOffset = Math.max(0, Math.round((startDate - minDate) / 86400000));
                const barWidth = Math.max(1, durationDays);
                const leftPx = startOffset * dayWidth;
                const widthPx = barWidth * dayWidth - 4;
                
                const isOverdue = task.deadlineDate < todayStr && task.status !== 'done';
                
                return `<div style="display:flex;align-items:center;height:36px;border-bottom:1px solid #f3f4f6;position:relative;">
                    <div style="position:absolute;left:${leftPx + 2}px;width:${widthPx}px;height:24px;background:${color.bg};border:1.5px solid ${color.border};border-radius:4px;display:flex;align-items:center;padding:0 6px;cursor:pointer;overflow:hidden;${isOverdue ? 'border-color:#ef4444;background:#fef2f2;' : ''}" onclick="openTaskModal('${escId(task.id)}')" title="${esc(task.title)} — ${statusLabels[task.status] || task.status}${assignee ? ' (' + assignee + ')' : ''}">
                        <span style="font-size:0.65rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:${isOverdue ? '#ef4444' : '#374151'};">${esc(task.title)}</span>
                    </div>
                </div>`;
            }).join('');
            
            // Today marker
            const todayOffset = Math.round((today - minDate) / 86400000);
            const todayPx = todayOffset * dayWidth + Math.floor(dayWidth / 2);
            
            // Left labels
            let labelsHTML = sorted.map(task => {
                const color = statusColors[task.status] || statusColors.new;
                const assignee = task.assigneeName ? esc(task.assigneeName).split(' ')[0] : '';
                return `<div style="height:36px;display:flex;align-items:center;border-bottom:1px solid #f3f4f6;padding:0 8px;gap:6px;">
                    <div style="width:6px;height:6px;border-radius:50%;background:${color.border};flex-shrink:0;"></div>
                    <span style="font-size:0.7rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:140px;color:#374151;" title="${esc(task.title)}">${esc(task.title)}</span>
                    ${assignee ? `<span style="font-size:0.6rem;color:#9ca3af;">${assignee}</span>` : ''}
                </div>`;
            }).join('');
            
            return `
                <div style="background:white;border-radius:12px;border:1px solid #e5e7eb;overflow:hidden;">
                    <div style="display:flex;">
                        <!-- Labels column -->
                        <div style="width:200px;min-width:200px;border-right:1px solid #e5e7eb;flex-shrink:0;">
                            <div style="height:54px;display:flex;align-items:center;padding:0 8px;font-size:0.75rem;font-weight:600;color:#6b7280;border-bottom:1px solid #e5e7eb;">Завдання</div>
                            ${labelsHTML}
                        </div>
                        <!-- Chart area -->
                        <div style="flex:1;overflow-x:auto;">
                            <div style="min-width:${chartWidth}px;position:relative;">
                                <!-- Day headers -->
                                <div style="display:flex;border-bottom:1px solid #e5e7eb;">${headerHTML}</div>
                                <!-- Bars -->
                                <div style="position:relative;">
                                    <!-- Today line -->
                                    <div style="position:absolute;top:0;bottom:0;left:${todayPx}px;width:2px;background:#22c55e;z-index:2;opacity:0.6;"></div>
                                    ${rowsHTML}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>`;
        }
        
        async function updateProjectStatus(projectId, status) {
            // Попередження при ручному завершенні з незавершеними задачами
            if (status === 'completed') {
                const s = getProjectStats(projectId);
                const undone = s.total - s.done;
                if (undone > 0 && !confirm(t('confirmProjectComplete').replace('{n}', undone))) {
                    // Повернути select назад
                    renderProjectDetail(projectId);
                    return;
                }
            }
            try {
                await db.collection('companies').doc(currentCompany).collection('projects').doc(projectId).update({ status });
                const proj = projects.find(x => x.id === projectId);
                if (proj) proj.status = status;
                renderProjectDetail(projectId);
                renderProjects();
                updateProjectSelects();
            } catch (e) { console.error(e); }
        }
        
        function updateProjectSelects(forceIncludeId) {
            const sel = document.getElementById('taskProject');
            if (!sel) return;
            const current = forceIncludeId || sel.value;
            // Показуємо active + поточний проєкт задачі (навіть якщо completed/paused)
            const activeProjects = projects.filter(p => p.status === 'active');
            const currentProject = current ? projects.find(p => p.id === current) : null;
            const showProjects = [...activeProjects];
            if (currentProject && !showProjects.find(p => p.id === currentProject.id)) {
                showProjects.push(currentProject);
            }
            sel.innerHTML = '<option value="">Без проєкту</option>' + 
                showProjects.map(p => {
                    const suffix = p.status !== 'active' ? ` (${p.status === 'completed' ? 'завершено' : 'пауза'})` : '';
                    return `<option value="${esc(p.id)}">${esc(p.name)}${suffix}</option>`;
                }).join('');
            sel.value = current;
        }
        
        // Sanitize color for style attribute — only allow hex colors
        function safeColor(color, fallback = '#22c55e') {
            if (!color) return fallback;
            return /^#[0-9a-fA-F]{3,8}$/.test(color) ? color : fallback;
        }
        

        // === ШАБЛОНИ ===
        function openProcessTemplatesModal() {
            renderTemplatesList();
            document.getElementById('processTemplatesModal').style.display = 'block';
            refreshIcons();
        }
        
        function renderTemplatesList() {
            const container = document.getElementById('processTemplatesList');
            
            if (processTemplates.length === 0) {
                container.innerHTML = `
                    <div class="empty-state" style="padding:2rem;">
                        <i data-lucide="file-cog" class="icon icon-lg" style="color:var(--gray);"></i>
                        <p>${t('noTemplates')}</p>
                    </div>
                `;
                refreshIcons();
                return;
            }
            
            container.innerHTML = processTemplates.map(template => {
                const stepsPreview = template.steps?.map(s => esc(s.function)).join(' → ') || '';
                const activeCount = processes.filter(p => p.templateId === template.id).length;
                
                return `
                    <div style="display:flex;justify-content:space-between;align-items:center;padding:1rem;border-bottom:1px solid #e5e7eb;">
                        <div style="flex:1;">
                            <div style="font-weight:600;margin-bottom:0.25rem;">${esc(template.name)}</div>
                            <div style="font-size:0.8rem;color:var(--gray);">
                                ${stepsPreview}
                                ${activeCount > 0 ? `<span style="margin-left:0.5rem;background:#dbeafe;color:#1d4ed8;padding:0.15rem 0.5rem;border-radius:10px;font-size:0.75rem;">${activeCount} ${t('activeProcesses')}</span>` : ''}
                            </div>
                        </div>
                        <div style="display:flex;gap:0.5rem;">
                            <button class="btn btn-small" onclick="event.stopPropagation(); openEditTemplateModal('${escId(template.id)}')">
                                <i data-lucide="pencil" class="icon icon-sm"></i>
                            </button>
                            <button class="btn btn-small btn-danger" onclick="event.stopPropagation(); deleteProcessTemplate('${escId(template.id)}')">
                                <i data-lucide="trash-2" class="icon icon-sm"></i>
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
            
            refreshIcons();
        }
        
        function openEditTemplateModal(templateId = null) {
            const template = templateId ? processTemplates.find(t => t.id === templateId) : null;
            
            document.getElementById('processTemplateId').value = templateId || '';
            document.getElementById('processTemplateName').value = template?.name || '';
            document.getElementById('processTemplateDescription').value = template?.description || '';
            
            // Рендеримо етапи
            const stepsContainer = document.getElementById('templateStepsContainer');
            if (template?.steps?.length) {
                stepsContainer.innerHTML = template.steps.map((step, i) => renderTemplateStepEditor(step, i)).join('');
            } else {
                stepsContainer.innerHTML = '<p style="color:var(--gray);text-align:center;padding:1rem;">' + t('addStep') + '</p>';
            }
            
            document.getElementById('editTemplateTitle').innerHTML = `<i data-lucide="file-cog" class="icon"></i> ${template ? t('editTemplate') : t('newTemplate')}`;
            
            closeModal('processTemplatesModal');
            document.getElementById('editProcessTemplateModal').style.display = 'block';
            refreshIcons();
        }
        
        function renderTemplateStepEditor(step, index) {
            const activeFunctions = functions.filter(f => f.status !== 'archived');
            const funcOptions = activeFunctions.map(f => 
                `<option value="${esc(f.name)}" ${f.name === step.function ? 'selected' : ''}>${esc(f.name)}</option>`
            ).join('');
            
            return `
                <div class="process-template-step" data-index="${index}">
                    <span class="step-number">${index + 1}</span>
                    <div style="flex:1;display:flex;gap:0.5rem;flex-wrap:wrap;">
                        <select class="form-select step-function" style="flex:1;min-width:120px;" onchange="updateStepFunction(${index}, this.value)">
                            <option value="">${t('stepFunction')}</option>
                            ${funcOptions}
                        </select>
                        <input type="text" class="form-input step-title" placeholder="${t('stepTitle')}" value="${esc(step.title || '')}" 
                               style="flex:1;min-width:120px;" onchange="updateStepTitle(${index}, this.value)">
                    </div>
                    <button type="button" class="btn btn-small btn-danger" onclick="removeTemplateStep(${index})" style="padding:0.3rem 0.5rem;">
                        <i data-lucide="x" class="icon icon-sm"></i>
                    </button>
                </div>
            `;
        }
        
        function addTemplateStep() {
            const container = document.getElementById('templateStepsContainer');
            const steps = container.querySelectorAll('.process-template-step');
            const newIndex = steps.length;
            
            // Видаляємо placeholder якщо є
            if (steps.length === 0) {
                container.innerHTML = '';
            }
            
            container.insertAdjacentHTML('beforeend', renderTemplateStepEditor({ function: '', title: '' }, newIndex));
            refreshIcons();
        }
        
        function removeTemplateStep(index) {
            const container = document.getElementById('templateStepsContainer');
            const steps = Array.from(container.querySelectorAll('.process-template-step'));
            
            if (steps[index]) {
                steps[index].remove();
            }
            
            // Перенумеровуємо
            container.querySelectorAll('.process-template-step').forEach((step, i) => {
                step.dataset.index = i;
                step.querySelector('.step-number').textContent = i + 1;
            });
            
            if (container.querySelectorAll('.process-template-step').length === 0) {
                container.innerHTML = '<p style="color:var(--gray);text-align:center;padding:1rem;">' + t('addStep') + '</p>';
            }
        }
        
        function updateStepFunction(index, value) {
            // Зберігаємо в data атрибут
        }
        
        function updateStepTitle(index, value) {
            // Зберігаємо в data атрибут
        }
        
        function getTemplateStepsFromEditor() {
            const container = document.getElementById('templateStepsContainer');
            const steps = [];
            
            container.querySelectorAll('.process-template-step').forEach(stepEl => {
                const funcSelect = stepEl.querySelector('.step-function');
                const titleInput = stepEl.querySelector('.step-title');
                
                if (funcSelect?.value) {
                    steps.push({
                        function: funcSelect.value,
                        title: titleInput?.value || ''
                    });
                }
            });
            
            return steps;
        }
        
        async function saveProcessTemplate(e) {
            e.preventDefault();
            
            const templateId = document.getElementById('processTemplateId').value;
            const name = document.getElementById('processTemplateName').value.trim();
            const description = document.getElementById('processTemplateDescription').value.trim();
            const steps = getTemplateStepsFromEditor();
            
            if (!name) {
                alert(t('templateName'));
                return;
            }
            
            if (steps.length < 2) {
                alert(t('minTwoSteps'));
                return;
            }
            
            // Валідація: перевіряємо що всі функції існують
            const activeFunctions = functions.filter(f => f.status !== 'archived');
            const missingFunctions = steps.filter(s => !activeFunctions.find(f => f.name === s.function));
            if (missingFunctions.length > 0) {
                alert(t('functionsNotFound') + ': ' + missingFunctions.map(s => s.function).join(', '));
                return;
            }
            
            try {
                const data = {
                    name,
                    description,
                    steps,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                };
                
                if (templateId) {
                    await db.collection('companies').doc(currentCompany).collection('processTemplates').doc(templateId).update(data);
                } else {
                    data.createdAt = firebase.firestore.FieldValue.serverTimestamp();
                    data.createdBy = currentUser.uid;
                    await db.collection('companies').doc(currentCompany).collection('processTemplates').add(data);
                }
                
                closeModal('editProcessTemplateModal');
                await loadProcessData();
                renderProcessBoard();
                alert(t('templateSaved'));
                
            } catch (error) {
                console.error('saveProcessTemplate error:', error);
                alert(t('error') + ': ' + error.message);
            }
        }
        
        async function deleteProcessTemplate(templateId) {
            if (!confirm(t('deleteTemplateConfirm'))) {
                return;
            }
            
            try {
                await db.collection('companies').doc(currentCompany).collection('processTemplates').doc(templateId).delete();
                await loadProcessData();
                renderTemplatesList();
                renderProcessBoard();
            } catch (error) {
                console.error('deleteProcessTemplate error:', error);
                alert(t('error') + ': ' + error.message);
            }
        }
        
        // === ЗАПУСК ПРОЦЕСУ ===
        function openStartProcessModal() {
            const select = document.getElementById('startProcessTemplate');
            select.innerHTML = `<option value="">${t('select')}</option>` + 
                processTemplates.map(pt => `<option value="${esc(pt.id)}">${esc(pt.name)}</option>`).join('');
            
            document.getElementById('startProcessName').value = '';
            document.getElementById('startProcessDeadline').value = '';
            document.getElementById('startProcessPreview').style.display = 'none';
            
            document.getElementById('startProcessModal').style.display = 'block';
            refreshIcons();
        }
        
        function updateStartProcessPreview() {
            const templateId = document.getElementById('startProcessTemplate').value;
            const preview = document.getElementById('startProcessPreview');
            const stepsContainer = document.getElementById('startProcessSteps');
            
            if (!templateId) {
                preview.style.display = 'none';
                return;
            }
            
            const template = processTemplates.find(t => t.id === templateId);
            if (!template?.steps) {
                preview.style.display = 'none';
                return;
            }
            
            stepsContainer.innerHTML = template.steps.map((step, i) => `
                <span style="display:flex;align-items:center;gap:0.25rem;padding:0.4rem 0.75rem;background:white;border-radius:20px;font-size:0.85rem;box-shadow:0 1px 3px rgba(0,0,0,0.1);">
                    <span style="width:20px;height:20px;background:var(--primary);color:white;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:0.7rem;font-weight:600;">${i + 1}</span>
                    ${esc(step.function)}
                </span>
                ${i < template.steps.length - 1 ? '<i data-lucide="arrow-right" class="icon icon-sm" style="color:var(--gray);"></i>' : ''}
            `).join('');
            
            preview.style.display = 'block';
            refreshIcons();
        }
        
        async function startProcess(e) {
            e.preventDefault();
            
            const templateId = document.getElementById('startProcessTemplate').value;
            const name = document.getElementById('startProcessName').value.trim();
            const deadline = document.getElementById('startProcessDeadline').value;
            
            if (!templateId || !name) return;
            
            const template = processTemplates.find(t => t.id === templateId);
            if (!template?.steps?.length) return;
            
            // Перевіряємо що перша функція має виконавців
            const firstStep = template.steps[0];
            const firstFunc = functions.find(f => f.name === firstStep.function);
            
            if (!firstFunc) {
                alert(t('functionNotExists').replace('{name}', firstStep.function));
                return;
            }
            
            if (!firstFunc.assigneeIds?.length) {
                alert(t('functionNoExecutors').replace('{name}', firstStep.function));
                return;
            }
            
            try {
                // Створюємо процес
                const processData = {
                    templateId,
                    name,
                    deadline: deadline || null,
                    status: 'active',
                    currentStep: 0,
                    history: [],
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    createdBy: currentUser.uid
                };
                
                const processRef = await db.collection('companies').doc(currentCompany).collection('processes').add(processData);
                
                // Створюємо завдання для першого етапу
                const func = firstFunc;
                const headId = func.headId || func.assigneeIds[0];
                const head = users.find(u => u.id === headId);
                
                // Smart deadline
                let firstDeadlineDate = new Date().toISOString().split('T')[0];
                if (deadline) {
                    const pdl = new Date(deadline + 'T18:00:00');
                    const remAfter = template.steps.slice(1).reduce((s, st) => s + parseInt(st.estimatedTime || 60), 0);
                    const sdl = new Date(pdl.getTime() - remAfter * 60000);
                    const tmw = new Date(); tmw.setDate(tmw.getDate() + 1);
                    firstDeadlineDate = sdl > tmw ? sdl.toISOString().split('T')[0] : tmw.toISOString().split('T')[0];
                }
                
                const firstTaskRef = await db.collection('companies').doc(currentCompany).collection('tasks').add({
                    title: `[${name}] ${firstStep.title || firstStep.name || firstStep.function}`,
                    function: firstStep.function,
                    assigneeId: headId,
                    assigneeName: head?.name || head?.email || '',
                    instruction: firstStep.instruction || '',
                    estimatedTime: firstStep.estimatedTime || '60',
                    deadlineDate: firstDeadlineDate,
                    deadlineTime: '18:00',
                    status: 'new',
                    priority: 'high',
                    processId: processRef.id,
                    processStep: 0,
                    createdBy: currentUser.uid,
                    creatorId: currentUser.uid,
                    createdDate: getLocalDateStr(),
                    deadline: firstDeadlineDate + 'T18:00',
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    creatorName: t('systemUser')
                });
                
                closeModal('startProcessModal');
                await loadProcessData();
                renderProcessBoard();
                renderMyDay();
                refreshCurrentView();
                alert(t('processStarted'));
                
            } catch (error) {
                console.error('startProcess error:', error);
                alert(t('error') + ': ' + error.message);
            }
        }
        
        // === ПЕРЕГЛЯД ПРОЦЕСУ ===
        function openViewProcessModal(processId) {
            const process = processes.find(p => p.id === processId);
            if (!process) return;
            
            const template = processTemplates.find(t => t.id === process.templateId);
            
            // Якщо шаблон видалено - показуємо повідомлення
            if (!template) {
                document.getElementById('viewProcessTitle').innerHTML = `<i data-lucide="git-branch" class="icon"></i> ${esc(process.name)}`;
                document.getElementById('viewProcessContent').innerHTML = `
                    <div style="text-align:center;padding:2rem;color:var(--gray);">
                        <i data-lucide="alert-triangle" class="icon icon-lg" style="margin-bottom:1rem;"></i>
                        <p>${t('templateDeleted')}</p>
                    </div>
                `;
                document.getElementById('viewProcessModal').style.display = 'block';
                refreshIcons();
                return;
            }
            
            // Перевіряємо чи currentStep в межах steps
            const safeCurrentStep = Math.min(process.currentStep || 0, template.steps.length - 1);
            
            document.getElementById('viewProcessTitle').innerHTML = `<i data-lucide="git-branch" class="icon"></i> ${esc(process.name)}`;
            
            const content = document.getElementById('viewProcessContent');
            content.innerHTML = `
                <div style="margin-bottom:1.5rem;">
                    <div style="font-size:0.85rem;color:var(--gray);margin-bottom:0.5rem;">${t('processFlow')}</div>
                    <div style="display:flex;flex-direction:column;gap:0.5rem;">
                        ${(template?.steps || []).map((step, i) => {
                            let status = '';
                            let statusIcon = '';
                            let statusColor = '';
                            
                            if (i < safeCurrentStep) {
                                status = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" style="vertical-align:-2px;"><polyline points="20 6 9 17 4 12"/></svg>';
                                statusColor = 'var(--primary)';
                            } else if (i === safeCurrentStep) {
                                status = '<svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor" stroke="none"><circle cx="12" cy="12" r="8"/></svg>';
                                statusColor = 'var(--info)';
                            } else {
                                status = '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="8"/></svg>';
                                statusColor = 'var(--gray)';
                            }
                            
                            return `
                                <div style="display:flex;align-items:center;gap:0.75rem;padding:0.75rem;background:${i === safeCurrentStep ? '#eff6ff' : '#f9fafb'};border-radius:8px;border-left:3px solid ${statusColor};">
                                    <span style="color:${statusColor};font-weight:600;width:20px;">${status}</span>
                                    <div style="flex:1;">
                                        <div style="font-weight:500;">${esc(step.title || step.function)}</div>
                                        <div style="font-size:0.8rem;color:var(--gray);">${esc(step.function)}</div>
                                    </div>
                                    ${i === safeCurrentStep && process.status !== 'completed' ? `
                                        <button class="btn btn-small btn-success" onclick="completeProcessStep('${escId(processId)}')">
                                            <i data-lucide="check" class="icon icon-sm"></i> ${t('completeStep')}
                                        </button>
                                    ` : ''}
                                </div>
                            `;
                        }).join('') || ''}
                    </div>
                </div>
                
                ${process.history?.length ? `
                    <div>
                        <div style="font-size:0.85rem;color:var(--gray);margin-bottom:0.5rem;">${t('processHistory')}</div>
                        <div style="font-size:0.85rem;">
                            ${process.history.map(h => `
                                <div style="padding:0.5rem 0;border-bottom:1px solid #f3f4f6;">
                                    <span style="color:var(--primary);"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" style="vertical-align:-2px;"><polyline points="20 6 9 17 4 12"/></svg></span> ${esc(h.stepTitle || '')} 
                                    <span style="color:var(--gray);">— ${h.completedAt ? new Date(h.completedAt).toLocaleDateString() : ''}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                ` : ''}
                
                <div style="margin-top:1.5rem;padding-top:1rem;border-top:1px solid #e5e7eb;display:flex;justify-content:flex-end;">
                    <button class="btn btn-danger btn-small" onclick="deleteProcess('${escId(processId)}')" style="opacity:0.7;">
                        <i data-lucide="trash-2" class="icon icon-sm"></i> ${t('deleteProcess')}
                    </button>
                </div>
            `;
            
            document.getElementById('viewProcessModal').style.display = 'block';
            refreshIcons();
        }
        
        async function deleteProcess(processId) {
            if (!confirm(t('deleteProcessConfirm'))) return;
            
            try {
                await db.collection('companies').doc(currentCompany).collection('processes').doc(processId).delete();
                
                // Cleanup: знімаємо processId з пов'язаних задач
                const linkedTasks = tasks.filter(tk => tk.processId === processId);
                for (const tk of linkedTasks) {
                    tk.processId = '';
                    tk.processStep = null;
                    db.collection('companies').doc(currentCompany).collection('tasks').doc(tk.id)
                        .update({ processId: '', processStep: null }).catch(() => {});
                }
                
                closeModal('viewProcessModal');
                await loadProcessData();
                renderProcessBoard();
            } catch (error) {
                console.error('deleteProcess error:', error);
                alert(t('error') + ': ' + error.message);
            }
        }
        
        // =====================
        // AUTO-ADVANCE: Завершення завдання → автопросування процесу
        // =====================
        async function advanceProcessIfLinked(taskId) {
            const task = tasks.find(t => t.id === taskId);
            if (!task?.processId) return; // Не пов'язане з процесом
            
            const process = processes.find(p => p.id === task.processId);
            if (!process || process.status !== 'active') return;
            
            const template = processTemplates.find(t => t.id === process.templateId);
            if (!template?.steps?.length) return;
            
            // Перевіряємо що завершене завдання — саме поточний крок процесу
            const currentStepIndex = process.currentStep || 0;
            if (task.processStep !== currentStepIndex) {
                console.log('[Process] Task step', task.processStep, '!= current step', currentStepIndex, '— skip');
                return;
            }
            
            const currentStep = template.steps[currentStepIndex];
            const nextStepIndex = currentStepIndex + 1;
            const nextStep = template.steps[nextStepIndex];
            
            try {
                // History entry
                const historyEntry = {
                    step: currentStepIndex,
                    stepTitle: currentStep?.title || currentStep?.function || ('Крок ' + (currentStepIndex + 1)),
                    completedAt: new Date().toISOString(),
                    completedBy: currentUser.uid,
                    taskId: taskId,
                    auto: true
                };
                
                // Перевіряємо функцію ПЕРЕД update process
                if (nextStep) {
                    const checkFunc = functions.find(f => f.name === nextStep.function);
                    if (!checkFunc?.assigneeIds?.length) {
                        showToast(t('noAssigneesInFunc') + ': ' + nextStep.function, 'error');
                        return; // НЕ інкрементуємо process — не буде stuck
                    }
                }
                
                const updateData = {
                    currentStep: nextStepIndex,
                    history: firebase.firestore.FieldValue.arrayUnion(historyEntry)
                };
                
                // Останній крок → завершуємо процес
                if (!nextStep) {
                    updateData.status = 'completed';
                    updateData.completedAt = firebase.firestore.FieldValue.serverTimestamp();
                }
                
                // Transaction: prevent race when 2 users complete same step
                const processRef = db.collection('companies').doc(currentCompany).collection('processes').doc(task.processId);
                const raceDetected = await db.runTransaction(async (tx) => {
                    const processDoc = await tx.get(processRef);
                    if (!processDoc.exists) return true;
                    const serverStep = processDoc.data().currentStep || 0;
                    // Another user already advanced this step
                    if (serverStep !== currentStepIndex) {
                        console.log('[Process] Race detected: server step', serverStep, '!= local', currentStepIndex);
                        return true;
                    }
                    tx.update(processRef, updateData);
                    return false;
                });
                if (raceDetected) {
                    // Refresh process data
                    const freshDoc = await processRef.get();
                    if (freshDoc.exists) {
                        const pIdx = processes.findIndex(p => p.id === task.processId);
                        if (pIdx >= 0) processes[pIdx] = { id: freshDoc.id, ...freshDoc.data() };
                    }
                    return;
                }
                
                // Створюємо завдання для наступного кроку
                if (nextStep) {
                    const func = functions.find(f => f.name === nextStep.function);
                    if (func?.assigneeIds?.length) {
                        const headId = func.headId || func.assigneeIds[0];
                        const head = users.find(u => u.id === headId);
                        
                        // Розрахунок дедлайну: якщо є deadline процесу — відштовхуємось від нього
                        let deadlineDate = getLocalDateStr();
                        if (process.deadline) {
                            const processDeadline = new Date(process.deadline + 'T18:00:00');
                            // Дедлайн цього кроку = deadline процесу мінус час на наступні кроки
                            const remainingAfterThis = template.steps.slice(nextStepIndex + 1).reduce((sum, s) => sum + parseInt(s.estimatedTime || 60), 0);
                            const stepDeadline = new Date(processDeadline.getTime() - remainingAfterThis * 60000);
                            
                            // Але не раніше ніж завтра 
                            const tomorrow = new Date();
                            tomorrow.setDate(tomorrow.getDate() + 1);
                            deadlineDate = stepDeadline > tomorrow 
                                ? getLocalDateStr(stepDeadline)
                                : getLocalDateStr(tomorrow);
                        }
                        
                        const newTaskRef = await db.collection('companies').doc(currentCompany).collection('tasks').add({
                            title: `[${process.name}] ${nextStep.title || nextStep.name || nextStep.function}`,
                            function: nextStep.function,
                            assigneeId: headId,
                            assigneeName: head?.name || head?.email || '',
                            instruction: nextStep.instruction || '',
                            estimatedTime: nextStep.estimatedTime || '60',
                            deadlineDate: deadlineDate,
                            deadlineTime: '18:00',
                            status: 'new',
                            priority: 'high',
                            processId: task.processId,
                            processStep: nextStepIndex,
                            createdBy: currentUser.uid,
                            creatorId: currentUser.uid,
                            createdDate: getLocalDateStr(),
                            deadline: deadlineDate + 'T18:00',
                            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                            creatorName: t('systemUser')
                        });
                        
                        // Додаємо в локальний масив для негайного відображення
                        tasks.push({
                            id: newTaskRef.id,
                            title: `[${process.name}] ${nextStep.title || nextStep.name || nextStep.function}`,
                            function: nextStep.function,
                            assigneeId: headId,
                            assigneeName: head?.name || head?.email || '',
                            instruction: nextStep.instruction || '',
                            estimatedTime: nextStep.estimatedTime || '60',
                            deadlineDate: deadlineDate,
                            deadlineTime: '18:00',
                            deadline: deadlineDate + 'T18:00',
                            status: 'new',
                            priority: 'high',
                            processId: task.processId,
                            processStep: nextStepIndex,
                            createdBy: currentUser.uid,
                            creatorId: currentUser.uid,
                            createdDate: getLocalDateStr(),
                            creatorName: t('systemUser'),
                            createdAt: new Date()
                        });
                        
                        showToast(t('processAdvanced').replace('{name}', process.name).replace('{step}', nextStepIndex+1).replace('{total}', template.steps.length).replace('{stepName}', nextStep.title || nextStep.function), 'success');
                        addNotification('process', t('processAdvancedShort') || 'Процес просунувся', process.name + ' → крок ' + (nextStepIndex + 1) + '/' + template.steps.length, null);
                    } else {
                        showToast(t('processNoExecutors').replace('{func}', nextStep.function), 'error');
                    }
                } else {
                    // Процес завершено!
                    showToast(t('processCompleted').replace('{name}', process.name), 'success');
                    addNotification('completed', t('processCompletedShort') || 'Процес завершено', process.name, null);
                }
                
                // Оновлюємо локальний стан процесу
                const pIdx = processes.findIndex(p => p.id === task.processId);
                if (pIdx >= 0) {
                    processes[pIdx].currentStep = nextStepIndex;
                    if (!nextStep) processes[pIdx].status = 'completed';
                }
                
                // Перерендерити процеси якщо вкладка відкрита
                if (document.getElementById('processesTab')?.style.display !== 'none') {
                    renderProcessBoard();
                }
                
            } catch (e) {
                console.error('[advanceProcess]', e);
                showToast(t('error') + ': ' + e.message, 'error');
            }
        }
        
        async function completeProcessStep(processId) {
            const process = processes.find(p => p.id === processId);
            if (!process) return;
            
            const template = processTemplates.find(t => t.id === process.templateId);
            if (!template?.steps?.length) {
                alert(t('templateNotFound'));
                return;
            }
            
            // Re-read from Firestore to prevent stale state after auto-advance
            try {
                const freshDoc = await db.collection('companies').doc(currentCompany).collection('processes').doc(processId).get();
                if (freshDoc.exists) {
                    const freshData = freshDoc.data();
                    process.currentStep = freshData.currentStep || 0;
                    process.status = freshData.status || 'active';
                    process.history = freshData.history || [];
                }
            } catch(e) { /* use local state as fallback */ }
            
            if (process.status === 'completed') {
                showToast(t('processCompleted').replace('{name}', process.name), 'info');
                return;
            }
            
            const currentStepIndex = Math.min(process.currentStep || 0, template.steps.length - 1);
            const currentStep = template.steps[currentStepIndex];
            
            // Перевіряємо чи є незавершене автозавдання для цього кроку
            const pendingAutoTask = tasks.find(t => 
                t.processId === processId && 
                t.processStep === currentStepIndex && 
                t.status !== 'done' && t.status !== 'review'
            );
            if (pendingAutoTask) {
                const skip = confirm(t('skipStepConfirm').replace('{title}', pendingAutoTask.title));
                if (!skip) return;
            }
            
            // Перевіряємо права - чи користувач є членом функції поточного етапу
            const currentFunc = functions.find(f => f.name === currentStep.function);
            if (currentFunc && !currentFunc.assigneeIds?.includes(currentUser?.uid)) {
                // Дозволяємо також власникам/менеджерам
                const userRole = currentUserData?.role;
                if (userRole !== 'owner' && userRole !== 'manager') {
                    alert(t('onlyFunctionMembers'));
                    return;
                }
            }
            
            const nextStepIndex = currentStepIndex + 1;
            const nextStep = template.steps[nextStepIndex];
            
            try {
                // Оновлюємо процес
                const historyEntry = {
                    step: currentStepIndex,
                    stepTitle: currentStep.title || currentStep.function,
                    completedAt: new Date().toISOString(),
                    completedBy: currentUser.uid
                };
                
                const updateData = {
                    currentStep: nextStepIndex,
                    history: firebase.firestore.FieldValue.arrayUnion(historyEntry)
                };
                
                // Якщо це останній етап - завершуємо процес
                if (!nextStep) {
                    updateData.status = 'completed';
                    updateData.completedAt = firebase.firestore.FieldValue.serverTimestamp();
                }
                
                await db.collection('companies').doc(currentCompany).collection('processes').doc(processId).update(updateData);
                
                // Якщо є наступний етап - створюємо завдання
                if (nextStep) {
                    const func = functions.find(f => f.name === nextStep.function);
                    if (func?.assigneeIds?.length) {
                        const headId = func.headId || func.assigneeIds[0];
                        const head = users.find(u => u.id === headId);
                        
                        // Smart deadline calculation
                        let stepDeadlineDate = getLocalDateStr();
                        if (process.deadline) {
                            const processDeadline = new Date(process.deadline + 'T18:00:00');
                            const remainingAfterThis = template.steps.slice(nextStepIndex + 1).reduce((sum, s) => sum + parseInt(s.estimatedTime || 60), 0);
                            const stepDeadline = new Date(processDeadline.getTime() - remainingAfterThis * 60000);
                            const tomorrow = new Date(); tomorrow.setDate(tomorrow.getDate() + 1);
                            stepDeadlineDate = stepDeadline > tomorrow ? getLocalDateStr(stepDeadline) : getLocalDateStr(tomorrow);
                        }
                        
                        await db.collection('companies').doc(currentCompany).collection('tasks').add({
                            title: `[${process.name}] ${nextStep.title || nextStep.function}`,
                            function: nextStep.function,
                            assigneeId: headId,
                            assigneeName: head?.name || head?.email || '',
                            instruction: nextStep.instruction || '',
                            estimatedTime: nextStep.estimatedTime || '60',
                            deadlineDate: stepDeadlineDate,
                            deadlineTime: '18:00',
                            status: 'new',
                            priority: 'high',
                            processId: processId,
                            processStep: nextStepIndex,
                            createdBy: currentUser.uid,
                            creatorId: currentUser.uid,
                            createdDate: getLocalDateStr(),
                            deadline: stepDeadlineDate + 'T18:00',
                            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                            creatorName: t('systemUser')
                        });
                    } else {
                        // Попередження якщо функція не має виконавців
                        alert(t('functionNoExecutorsWarning').replace('{name}', nextStep.function));
                    }
                }
                
                closeModal('viewProcessModal');
                await loadProcessData();
                await loadAllData();
                renderProcessBoard();
                alert(nextStep ? t('stepCompleted') : t('processCompleted'));
                
            } catch (error) {
                console.error('completeProcessStep error:', error);
                alert(t('error') + ': ' + error.message);
            }
        }

        // =====================
        // REGULAR TASKS
        // =====================
        function toggleRegularTimeMode() {
            const mode = document.getElementById('regularTaskTimeMode').value;
            const endInput = document.getElementById('regularTaskTimeEnd');
            const durationSelect = document.getElementById('regularTaskDuration');
            
            if (mode === 'end') {
                endInput.style.display = 'block';
                durationSelect.style.display = 'none';
            } else {
                endInput.style.display = 'none';
                durationSelect.style.display = 'block';
            }
        }
        
        function toggleTaskTimeMode() {
            const mode = document.getElementById('taskTimeMode').value;
            const endInput = document.getElementById('taskTimeEnd');
            const durationSelect = document.getElementById('taskEstimatedTime');
            
            if (mode === 'end') {
                endInput.style.display = 'block';
                durationSelect.style.display = 'none';
            } else {
                endInput.style.display = 'none';
                durationSelect.style.display = 'block';
            }
        }
        
        function calculateEndTime(startTime, durationMinutes) {
            const [hours, minutes] = startTime.split(':').map(Number);
            const totalMinutes = hours * 60 + minutes + durationMinutes;
            const endHours = Math.floor(totalMinutes / 60) % 24;
            const endMinutes = totalMinutes % 60;
            return `${String(endHours).padStart(2, '0')}:${String(endMinutes).padStart(2, '0')}`;
        }
        
        function updatePeriodOptions() {
            const period = document.getElementById('regularTaskPeriod').value;
            const dayOfWeekGroup = document.getElementById('dayOfWeekGroup');
            const dayOfMonthGroup = document.getElementById('dayOfMonthGroup');
            
            if (period === 'weekly') {
                dayOfWeekGroup.style.display = 'block';
                dayOfMonthGroup.style.display = 'none';
            } else {
                // monthly, quarterly
                dayOfWeekGroup.style.display = 'none';
                dayOfMonthGroup.style.display = 'block';
            }
        }
        
        function selectAllDays() {
            document.querySelectorAll('input[name="dayOfWeek"]').forEach(cb => cb.checked = true);
            updateDayCheckboxStyles();
        }
        
        function selectWorkDays() {
            document.querySelectorAll('input[name="dayOfWeek"]').forEach(cb => {
                cb.checked = ['1','2','3','4','5'].includes(cb.value);
            });
            updateDayCheckboxStyles();
        }
        
        function clearDays() {
            document.querySelectorAll('input[name="dayOfWeek"]').forEach(cb => cb.checked = false);
            updateDayCheckboxStyles();
        }
        
        function updateDayCheckboxStyles() {
            document.querySelectorAll('input[name="dayOfWeek"]').forEach(cb => {
                const label = cb.parentElement;
                if (cb.checked) {
                    label.style.background = '#dcfce7';
                    label.style.borderColor = '#22c55e';
                } else {
                    label.style.background = '#f9fafb';
                    label.style.borderColor = '#e5e7eb';
                }
            });
        }
        
        function getSelectedDays() {
            return Array.from(document.querySelectorAll('input[name="dayOfWeek"]:checked')).map(cb => cb.value);
        }
        
        function setSelectedDays(days) {
            document.querySelectorAll('input[name="dayOfWeek"]').forEach(cb => {
                cb.checked = days.includes(cb.value);
            });
            updateDayCheckboxStyles();
        }
        
        // Додаємо слухачі для оновлення стилів
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('input[name="dayOfWeek"]').forEach(cb => {
                cb.addEventListener('change', updateDayCheckboxStyles);
            });
        });
        
        function openRegularTaskModal(id = null) {
            document.getElementById('regularTaskModal').style.display = 'block';
            updateRegularTaskFunctions();
            updatePeriodOptions();
            editingId = id;
            
            // Рендеримо чекбокси для сповіщень
            renderRegularNotifyUsersCheckboxes();
            
            if (id) {
                const rt = regularTasks.find(r => r.id === id);
                if (rt) {
                    document.getElementById('regularTaskTitle').value = rt.title;
                    document.getElementById('regularTaskFunction').value = rt.function;
                    
                    // Конвертуємо старий daily в weekly з усіма днями
                    if (rt.period === 'daily') {
                        document.getElementById('regularTaskPeriod').value = 'weekly';
                        updatePeriodOptions();
                        selectAllDays(); // Вибираємо всі дні
                    } else {
                        document.getElementById('regularTaskPeriod').value = rt.period || 'weekly';
                        updatePeriodOptions();
                        
                        // Встановлюємо вибрані дні
                        if (rt.daysOfWeek && Array.isArray(rt.daysOfWeek)) {
                            setSelectedDays(rt.daysOfWeek);
                        } else if (rt.dayOfWeek) {
                            // Сумісність зі старим форматом
                            setSelectedDays([rt.dayOfWeek]);
                        } else {
                            setSelectedDays(['1']); // За замовчуванням понеділок
                        }
                    }
                    
                    document.getElementById('regularTaskDayOfMonth').value = rt.dayOfMonth || '1';
                    
                    // Час - нова логіка з підтримкою старого формату
                    if (rt.timeStart) {
                        document.getElementById('regularTaskTimeStart').value = rt.timeStart;
                        document.getElementById('regularTaskTimeEnd').value = rt.timeEnd || '11:00';
                        if (rt.duration) {
                            document.getElementById('regularTaskTimeMode').value = 'duration';
                            document.getElementById('regularTaskDuration').value = rt.duration;
                        } else {
                            document.getElementById('regularTaskTimeMode').value = 'end';
                        }
                    } else if (rt.time) {
                        // Сумісність зі старим форматом (тільки один час)
                        document.getElementById('regularTaskTimeStart').value = rt.time;
                        document.getElementById('regularTaskTimeEnd').value = calculateEndTime(rt.time, 60);
                        document.getElementById('regularTaskTimeMode').value = 'duration';
                        document.getElementById('regularTaskDuration').value = '60';
                    } else {
                        document.getElementById('regularTaskTimeStart').value = '10:00';
                        document.getElementById('regularTaskTimeEnd').value = '11:00';
                    }
                    toggleRegularTimeMode();
                    
                    document.getElementById('regularTaskExpectedResult').value = rt.expectedResult || '';
                    document.getElementById('regularTaskReportFormat').value = rt.reportFormat || '';
                    document.getElementById('regularTaskInstruction').value = rt.instruction || '';
                    
                    // Нові поля
                    document.getElementById('regularTaskPriority').value = rt.priority || 'medium';
                    document.getElementById('regularTaskRequireReview').checked = rt.requireReview || false;
                    document.getElementById('regularTaskAssignee').value = rt.assigneeId || '';
                    renderRegularChecklist(rt.checklist || []);
                    
                    // Встановлюємо чекбокси сповіщень
                    setRegularNotifyUsersCheckboxes(rt.notifyOnComplete || []);
                }
            } else {
                document.getElementById('regularTaskForm').reset();
                document.getElementById('regularTaskTimeStart').value = '10:00';
                document.getElementById('regularTaskTimeEnd').value = '11:00';
                document.getElementById('regularTaskTimeMode').value = 'duration';
                document.getElementById('regularTaskDuration').value = '60';
                toggleRegularTimeMode();
                document.getElementById('regularTaskPeriod').value = 'weekly';
                document.getElementById('regularTaskPriority').value = 'medium';
                document.getElementById('regularTaskRequireReview').checked = false;
                document.getElementById('regularTaskAssignee').value = '';
                renderRegularChecklist([]);
                clearDays();
                setSelectedDays(['1']); // За замовчуванням понеділок
                updatePeriodOptions();
                
                // За замовчуванням сповіщуємо творця
                setRegularNotifyUsersCheckboxes([currentUser?.uid]);
            }
        }
        
        // Рендеримо чекбокси для регулярних завдань
        function renderRegularNotifyUsersCheckboxes() {
            const container = document.getElementById('regularTaskNotifyUsers');
            if (!container) return;
            
            const sortedUsers = [...users].sort((a, b) => {
                const roleOrder = { owner: 0, manager: 1, employee: 2 };
                return (roleOrder[a.role] || 2) - (roleOrder[b.role] || 2);
            });
            
            container.innerHTML = sortedUsers.map(user => {
                const roleLabel = user.role === 'owner' ? '<svg width="14" height="14" viewBox="0 0 24 24" fill="#eab308" stroke="#eab308" stroke-width="1" style="vertical-align:-2px;"><path d="m2 4 3 12h14l3-12-6 7-4-7-4 7-6-7zm3 16h14"/></svg>' : (user.role === 'manager' ? '<svg width="14" height="14" viewBox="0 0 24 24" fill="#eab308" stroke="#eab308" stroke-width="1" style="vertical-align:-2px;"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>' : '');
                return `
                    <label class="notify-user-checkbox" style="display:flex;align-items:center;gap:0.4rem;padding:0.4rem 0.75rem;background:white;border:1px solid #e5e7eb;border-radius:20px;cursor:pointer;font-size:0.85rem;transition:all 0.2s;">
                        <input type="checkbox" name="regularNotifyUser" value="${esc(user.id)}" style="margin:0;" onchange="updateNotifyCheckboxStyle(this)">
                        <span>${roleLabel} ${esc(user.name || user.email)}</span>
                    </label>
                `;
            }).join('');
        }
        
        function setRegularNotifyUsersCheckboxes(userIds) {
            const container = document.getElementById('regularTaskNotifyUsers');
            if (!container) return;
            
            container.querySelectorAll('input[name="regularNotifyUser"]').forEach(cb => {
                cb.checked = userIds.includes(cb.value);
                const label = cb.closest('.notify-user-checkbox');
                if (label) {
                    label.style.background = cb.checked ? '#f0fdf4' : 'white';
                    label.style.borderColor = cb.checked ? '#22c55e' : '#e5e7eb';
                }
            });
        }
        
        function getRegularNotifyUsersFromCheckboxes() {
            const container = document.getElementById('regularTaskNotifyUsers');
            if (!container) return [];
            return Array.from(container.querySelectorAll('input[name="regularNotifyUser"]:checked'))
                .map(cb => cb.value);
        }

        function updateRegularTaskFunctions() {
            const s = document.getElementById('regularTaskFunction');
            const activeFunctions = functions.filter(f => f.status !== 'archived');
            s.innerHTML = `<option value="">${t('select')}</option>` + activeFunctions.map(f => `<option value="${esc(f.name)}">${esc(f.name)} (${f.assigneeIds?.length || 0} ${t('people')})</option>`).join('');
            
            // Оновлюємо фільтри
            const ff = document.getElementById('regularFunctionFilter');
            const af = document.getElementById('regularAssigneeFilter');
            if (ff) ff.innerHTML = `<option value="">${t('allFunctions')}</option>` + activeFunctions.map(f => `<option value="${esc(f.name)}">${esc(f.name)}</option>`).join('');
            if (af) af.innerHTML = `<option value="">${t('allAssignees')}</option>` + users.map(u => `<option value="${esc(u.id)}">${esc(u.name || u.email)}</option>`).join('');
            // Оновлюємо select виконавця для регулярного завдання
            const rta = document.getElementById('regularTaskAssignee');
            if (rta) rta.innerHTML = `<option value="">${t('fromFunctionAuto')}</option>` + users.map(u => `<option value="${esc(u.id)}">${esc(u.name || u.email)}</option>`).join('');
        }
        let regularChecklistItems = [];
        
        function renderRegularChecklist(items) {
            regularChecklistItems = items || [];
            const container = document.getElementById('regularTaskChecklist');
            if (!container) return;
            container.innerHTML = regularChecklistItems.map((item, i) => `
                <div style="display:flex;align-items:center;gap:0.5rem;padding:0.4rem 0.6rem;background:#f9fafb;border-radius:8px;">
                    <span style="flex:1;font-size:0.85rem;">${escapeHtml(typeof item === 'string' ? item : item.text || item)}</span>
                    <button type="button" onclick="removeRegularChecklistItem(${i})" style="background:none;border:none;color:#ef4444;cursor:pointer;font-size:1rem;padding:0 4px;">✕</button>
                </div>
            `).join('');
        }
        
        function addRegularChecklistItem() {
            const input = document.getElementById('regularChecklistInput');
            const text = input.value.trim();
            if (!text) return;
            regularChecklistItems.push({ text: text, done: false });
            input.value = '';
            renderRegularChecklist(regularChecklistItems);
        }
        
        function removeRegularChecklistItem(index) {
            regularChecklistItems.splice(index, 1);
            renderRegularChecklist(regularChecklistItems);
        }
        
        function getRegularChecklist() {
            return regularChecklistItems.map(item => ({
                text: typeof item === 'string' ? item : item.text || '',
                done: false
            }));
        }
        
        async function saveRegularTask(e) {
            e.preventDefault();
            
            if (isSaving) return;
            
            // Rate limiting
            if (!rateLimiter.check('saveRegularTask')) {
                alert(t('tooManyRequests'));
                return;
            }
            
            const funcName = document.getElementById('regularTaskFunction').value;
            const func = functions.find(f => f.name === funcName);
            const directAssignee = document.getElementById('regularTaskAssignee').value;
            
            if (!directAssignee && (!func || !func.assigneeIds?.length)) {
                alert(t('selectAssigneeOrFunction'));
                return;
            }
            
            const period = document.getElementById('regularTaskPeriod').value;
            const selectedDays = getSelectedDays();
            
            // Перевірка що вибраний хоча б один день для weekly
            if (period === 'weekly' && selectedDays.length === 0) {
                alert(t('selectAtLeastOneDay'));
                return;
            }
            
            // Валідація
            const taskData = {
                title: document.getElementById('regularTaskTitle').value.trim(),
                function: funcName,
                timeStart: document.getElementById('regularTaskTimeStart').value
            };
            
            const errors = validateRegularTaskData(taskData);
            if (errors.length > 0) {
                alert(errors.join('\n'));
                return;
            }
            
            isSaving = true;
            const submitBtn = e.target.querySelector('button[type="submit"]');
            if (submitBtn) submitBtn.disabled = true;
            
            // Копіюємо editingId локально
            const currentEditingId = editingId;
            
            const data = {
                title: document.getElementById('regularTaskTitle').value.trim(),
                function: funcName,
                period: period,
                daysOfWeek: period === 'weekly' ? selectedDays : null,
                dayOfMonth: period !== 'weekly' ? document.getElementById('regularTaskDayOfMonth').value : null,
                timeStart: document.getElementById('regularTaskTimeStart').value,
                timeEnd: document.getElementById('regularTaskTimeMode').value === 'end' 
                    ? document.getElementById('regularTaskTimeEnd').value 
                    : calculateEndTime(document.getElementById('regularTaskTimeStart').value, parseInt(document.getElementById('regularTaskDuration').value)),
                duration: document.getElementById('regularTaskTimeMode').value === 'duration' 
                    ? parseInt(document.getElementById('regularTaskDuration').value) 
                    : null,
                expectedResult: document.getElementById('regularTaskExpectedResult').value.trim(),
                reportFormat: document.getElementById('regularTaskReportFormat').value.trim(),
                instruction: document.getElementById('regularTaskInstruction').value.trim(),
                notifyOnComplete: getRegularNotifyUsersFromCheckboxes(),
                priority: document.getElementById('regularTaskPriority').value || 'medium',
                requireReview: document.getElementById('regularTaskRequireReview').checked || false,
                assigneeId: document.getElementById('regularTaskAssignee').value || '',
                checklist: getRegularChecklist()
                // assigneeIds більше не зберігаємо - беруться з функції динамічно
            };
            
            try {
                if (currentEditingId) {
                    data.updatedAt = firebase.firestore.FieldValue.serverTimestamp();
                    await db.collection('companies').doc(currentCompany).collection('regularTasks').doc(currentEditingId).update(data);
                    // Локальне оновлення
                    const idx = regularTasks.findIndex(rt => rt.id === currentEditingId);
                    if (idx >= 0) regularTasks[idx] = { ...regularTasks[idx], ...data };
                } else {
                    data.createdAt = firebase.firestore.FieldValue.serverTimestamp();
                    const docRef = await db.collection('companies').doc(currentCompany).collection('regularTasks').add(data);
                    // Локальне додавання
                    regularTasks.unshift({ id: docRef.id, ...data, createdAt: new Date() });
                }
                closeModal('regularTaskModal');
                if (currentRegularView === 'list') renderRegularTasks();
                else renderRegularWeekView();
                
                // Автогенерація завдань для нового/оновленого регулярного
                await autoGenerateRegularTasks();
                
                renderMyDay();
            } catch (error) {
                console.error('saveRegularTask error:', error);
                alert(t('error') + ': ' + error.message);
            } finally {
                isSaving = false;
                if (submitBtn) submitBtn.disabled = false;
            }
        }

        async function generateFromRegular(id) {
            const rt = regularTasks.find(r => r.id === id);
            if (!rt) return;
            
            // Беремо виконавців з функції
            const func = functions.find(f => f.name === rt.function);
            if (!func || !func.assigneeIds?.length) {
                alert(t('noExecutorsInFunction'));
                return;
            }
            
            const assigneeIds = func.assigneeIds;
            
            const deadline = new Date();
            deadline.setDate(deadline.getDate() + 1);
            const deadlineDate = getLocalDateStr(deadline);
            
            // Визначаємо початок поточного періоду
            const now = new Date();
            let periodStart;
            if (rt.period === 'weekly') {
                // Понеділок поточного тижня
                const day = now.getDay();
                const diff = now.getDate() - day + (day === 0 ? -6 : 1);
                periodStart = getLocalDateStr(new Date(now.setDate(diff)));
            } else if (rt.period === 'monthly') {
                // 1-е число поточного місяця
                periodStart = getLocalDateStr(new Date(now.getFullYear(), now.getMonth(), 1));
            } else {
                // Квартал - 1-е число першого місяця кварталу
                const quarter = Math.floor(now.getMonth() / 3);
                periodStart = getLocalDateStr(new Date(now.getFullYear(), quarter * 3, 1));
            }
            
            const batch = db.batch();
            const generatedRefs = [];
            assigneeIds.forEach(assigneeId => {
                const ref = db.collection('companies').doc(currentCompany).collection('tasks').doc();
                generatedRefs.push({ ref, assigneeId });
                batch.set(ref, {
                    title: rt.title,
                    function: rt.function,
                    assigneeId: assigneeId,
                    assigneeName: users.find(u => u.id === assigneeId)?.name || '',
                    deadlineDate: deadlineDate,
                    deadlineTime: rt.timeStart || rt.time || '18:00',
                    deadline: deadlineDate + 'T' + (rt.timeStart || rt.time || '18:00'),
                    expectedResult: rt.expectedResult || '',
                    reportFormat: rt.reportFormat || '',
                    description: rt.instruction || '',
                    status: 'new',
                    priority: rt.priority || 'medium',
                    pinned: false,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    createdDate: getLocalDateStr(),
                    creatorId: currentUser.uid,
                    creatorName: t('systemUser'),
                    regularTaskId: id,
                    periodStart: periodStart
                });
            });
            
            await batch.commit();
            
            // Локальне оновлення з реальними ID
            generatedRefs.forEach(({ ref, assigneeId }) => {
                tasks.unshift({
                    id: ref.id,
                    title: rt.title,
                    function: rt.function,
                    assigneeId: assigneeId,
                    assigneeName: users.find(u => u.id === assigneeId)?.name || '',
                    deadlineDate: deadlineDate,
                    deadlineTime: rt.timeStart || rt.time || '18:00',
                    status: 'new',
                    priority: rt.priority || 'medium',
                    regularTaskId: id,
                    createdDate: getLocalDateStr(),
                    createdAt: new Date()
                });
            });
            
            alert(`${t('createdLabel')} ${assigneeIds.length} ${t('tasksWord')}`);
            renderMyDay();
            refreshCurrentView();
        }

        async function deleteRegularTask(id) {
            const rt = regularTasks.find(r => r.id === id);
            if (!rt) return;
            
            const taskName = rt.title || 'Регулярне завдання';
            
            // Оптимістичне видалення
            const rtCopy = { ...rt };
            regularTasks = regularTasks.filter(r => r.id !== id);
            if (currentRegularView === 'list') renderRegularTasks();
            else renderRegularWeekView();
            
            // Показуємо toast з можливістю undo
            showUndoToast(taskName, rtCopy, 'regularTask');
            
            try {
                await db.collection('companies').doc(currentCompany).collection('regularTasks').doc(id).delete();
                // Cleanup orphaned generated tasks
                const orphanTasks = tasks.filter(tk => tk.regularTaskId === id && tk.status !== 'done');
                for (const tk of orphanTasks) {
                    db.collection('companies').doc(currentCompany).collection('tasks').doc(tk.id).delete().catch(() => {});
                }
                tasks = tasks.filter(tk => !(tk.regularTaskId === id && tk.status !== 'done'));
                renderMyDay(); refreshCurrentView();
            } catch (error) {
                // Rollback
                if (!regularTasks.find(r => r.id === id)) {
                    regularTasks.unshift(rtCopy);
                }
                deletedItemsStack = deletedItemsStack.filter(d => d.item.id !== id);
                if (currentRegularView === 'list') renderRegularTasks();
                else renderRegularWeekView();
                hideUndoToast();
                console.error('deleteRegularTask error:', error);
                alert(t('error') + ': ' + error.message);
            }
        }
        
        // Швидке виконання регулярного завдання
        async function completeRegularTask(id) {
            const rt = regularTasks.find(r => r.id === id);
            if (!rt) return;
            
            const func = functions.find(f => f.name === rt.function);
            if (!func || !func.assigneeIds?.length) {
                alert(t('noExecutorsInFunction'));
                return;
            }
            
            // Визначаємо період
            const now = new Date();
            let periodStart;
            if (rt.period === 'weekly') {
                // Для щотижневих з множинними днями - період = сьогодні
                periodStart = getLocalDateStr(now);
            } else if (rt.period === 'monthly') {
                periodStart = getLocalDateStr(new Date(now.getFullYear(), now.getMonth(), 1));
            } else {
                const quarter = Math.floor(now.getMonth() / 3);
                periodStart = getLocalDateStr(new Date(now.getFullYear(), quarter * 3, 1));
            }
            
            // Перевіряємо чи є вже завдання за цей період
            const existingTasks = tasks.filter(t => 
                t.regularTaskId === id && 
                t.periodStart === periodStart &&
                t.assigneeId === currentUser.uid
            );
            
            if (existingTasks.length > 0) {
                // Оновлюємо статус існуючого завдання
                const taskToUpdate = existingTasks[0];
                await db.collection('companies').doc(currentCompany).collection('tasks').doc(taskToUpdate.id).update({
                    status: 'done',
                    completedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                logTaskChange(taskToUpdate.id, 'complete', { status: 'done' }, { status: taskToUpdate.status });
                // Локальне оновлення
                taskToUpdate.status = 'done';
                taskToUpdate.completedAt = new Date().toISOString();
            } else {
                // Створюємо нове і одразу виконане
                const today = getLocalDateStr();
                const newTaskData = {
                    title: rt.title,
                    function: rt.function,
                    assigneeId: currentUser.uid,
                    assigneeName: currentUserData?.name || currentUser.email,
                    deadlineDate: today,
                    deadlineTime: rt.timeStart || rt.time || '18:00',
                    deadline: today + 'T' + (rt.timeStart || rt.time || '18:00'),
                    expectedResult: rt.expectedResult || '',
                    reportFormat: rt.reportFormat || '',
                    description: rt.instruction || '',
                    status: 'done',
                    priority: 'medium',
                    pinned: false,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    createdDate: today,
                    creatorName: t('systemUser'),
                    regularTaskId: id,
                    periodStart: periodStart,
                    completedAt: firebase.firestore.FieldValue.serverTimestamp()
                };
                const docRef = await db.collection('companies').doc(currentCompany).collection('tasks').add(newTaskData);
                // Локальне додавання
                if (!tasks.some(t => t.id === docRef.id)) tasks.unshift({ id: docRef.id, ...newTaskData, createdAt: new Date(), completedAt: new Date().toISOString() });
            }
            
            renderMyDay();
            if (currentRegularView === 'list') renderRegularTasks();
            else renderRegularWeekView();
        }

        function filterRegularToday() {
            const today = new Date().getDay().toString();
            document.getElementById('regularDayFilter').value = today;
            document.getElementById('regularAssigneeFilter').value = currentUser.uid;
            applyRegularFilters();
        }
        
        function filterRegularMy() {
            const af = document.getElementById('regularAssigneeFilter');
            if (af.value === currentUser.uid) {
                af.value = ''; // toggle off
            } else {
                af.value = currentUser.uid;
            }
            applyRegularFilters();
        }
        
        function applyRegularFilters() {
            renderRegularTasks();
            renderRegularWeekView();
            renderMobileRegularDay();
            updateRegularFilterUI();
        }
        
        function updateRegularFilterUI() {
            const af = document.getElementById('regularAssigneeFilter')?.value;
            const ff = document.getElementById('regularFunctionFilter')?.value;
            const df = document.getElementById('regularDayFilter')?.value;
            
            // Підсвітка кнопки "Мої"
            const myBtn = document.getElementById('regularMyBtn');
            if (myBtn) {
                myBtn.classList.toggle('active', af === currentUser?.uid);
                if (af === currentUser?.uid) {
                    myBtn.style.background = 'var(--primary)';
                    myBtn.style.color = 'white';
                    myBtn.style.borderColor = 'var(--primary)';
                } else {
                    myBtn.style.background = '';
                    myBtn.style.color = '';
                    myBtn.style.borderColor = '';
                }
            }
            
            // Лічильник відфільтрованих
            const total = regularTasks.length;
            const filtered = getFilteredRegularTasks().length;
            const countEl = document.getElementById('regularFilterCount');
            if (countEl) {
                if (af || ff || df) {
                    countEl.textContent = `${filtered} / ${total}`;
                } else {
                    countEl.textContent = `${total}`;
                }
            }
        }
        
        function getFilteredRegularTasks() {
            const ff = document.getElementById('regularFunctionFilter')?.value;
            const af = document.getElementById('regularAssigneeFilter')?.value;
            const dayFilter = document.getElementById('regularDayFilter')?.value;
            
            const todayDate = new Date().getDate();
            const isLastDayOfMonth = new Date(new Date().getFullYear(), new Date().getMonth() + 1, 0).getDate() === todayDate;
            
            return regularTasks.filter(rt => {
                if (ff && rt.function !== ff) return false;
                
                // Фільтр по виконавцю
                if (af) {
                    const func = functions.find(f => f.name === rt.function);
                    if (!func?.assigneeIds?.includes(af)) return false;
                }
                
                // Фільтр по дню
                if (dayFilter) {
                    if (rt.period === 'weekly') {
                        if (rt.daysOfWeek && Array.isArray(rt.daysOfWeek)) {
                            if (!rt.daysOfWeek.includes(dayFilter)) return false;
                        } else if (rt.dayOfWeek) {
                            if (rt.dayOfWeek !== dayFilter) return false;
                        }
                    } else if (rt.period === 'daily') {
                        // daily проходить завжди
                    } else {
                        if (rt.dayOfMonth === 'last') {
                            if (!isLastDayOfMonth) return false;
                        } else {
                            if (parseInt(rt.dayOfMonth) !== todayDate) return false;
                        }
                    }
                }
                return true;
            });
        }
        
        function renderRegularTasks() {
            const c = document.getElementById('regularTasksContainer');
            
            // Оновлюємо селекти (одноразово)
            const assigneeSelect = document.getElementById('regularAssigneeFilter');
            const functionSelect = document.getElementById('regularFunctionFilter');
            const activeFunctions = functions.filter(f => f.status !== 'archived');
            if (assigneeSelect && assigneeSelect.options.length <= 1) {
                assigneeSelect.innerHTML = `<option value="">${t('allAssignees')}</option>` + users.map(u => `<option value="${esc(u.id)}">${esc(u.name || u.email)}</option>`).join('');
            }
            if (functionSelect && functionSelect.options.length <= 1) {
                functionSelect.innerHTML = `<option value="">${t('allFunctions')}</option>` + activeFunctions.map(f => `<option value="${esc(f.name)}">${esc(f.name)}</option>`).join('');
            }
            
            let filtered = getFilteredRegularTasks();
            
            const pt = { weekly: t('weekly'), monthly: t('monthly'), quarterly: t('quarterly') };
            const days = {
                '0': t('daySun'),
                '1': t('dayMon'),
                '2': t('dayTue'),
                '3': t('dayWed'),
                '4': t('dayThu'),
                '5': t('dayFri'),
                '6': t('daySat')
            };
            
            // Показуємо поточний день у кнопці
            const todayDayName = days[new Date().getDay().toString()];
            const todayBtn = document.getElementById('regularTodayBtn');
            if (todayBtn) {
                todayBtn.innerHTML = `<i data-lucide="calendar-check" class="icon"></i> ${t('todaysTasks')} (${todayDayName})`;
                refreshIcons();
            }
            
            if (filtered.length === 0) {
                const dayFilter = document.getElementById('regularDayFilter')?.value;
                const noTasksMsg = dayFilter ? t('noRegularForDay') : t('noRegular');
                c.innerHTML = `<div class="empty-table"><h3>${noTasksMsg}</h3><p>${t('createRegular')}</p></div>`;
                return;
            }
            
            let html = `
                <table class="tasks-table">
                    <thead>
                        <tr>
                            <th>${t('title')}</th>
                            <th>${t('function')}</th>
                            <th>${t('schedule')}</th>
                            <th>${t('statusPeriod')}</th>
                            <th>${t('assignees')}</th>
                            <th>${t('actions')}</th>
                        </tr>
                    </thead>
                    <tbody>`;
            
            filtered.forEach(rt => {
                let scheduleText;
                const displayTime = rt.timeStart || rt.time || '10:00';
                
                // Підтримка старого формату daily
                if (rt.period === 'daily') {
                    scheduleText = `${t('daily')}, ${displayTime}`;
                } else if (rt.period === 'weekly') {
                    // Формуємо текст з вибраних днів
                    const daysList = rt.daysOfWeek || (rt.dayOfWeek ? [rt.dayOfWeek] : ['1']);
                    if (daysList.length === 7) {
                        scheduleText = `${t('daily')}, ${displayTime}`;
                    } else if (daysList.length === 5 && ['1','2','3','4','5'].every(d => daysList.includes(d))) {
                        scheduleText = `${t('monFri')}, ${displayTime}`;
                    } else {
                        const dayNames = daysList.map(d => days[d] || '').filter(Boolean);
                        scheduleText = `${dayNames.join(', ')}, ${displayTime}`;
                    }
                } else {
                    scheduleText = `${rt.dayOfMonth || '1'}-го, ${displayTime}`;
                }
                
                // Беремо виконавців з функції динамічно
                const func = functions.find(f => f.name === rt.function);
                const assigneeNames = func?.assigneeIds?.map(id => {
                    const u = users.find(x => x.id === id);
                    return u?.name || u?.email || '';
                }).filter(Boolean) || [];
                
                // Статус за поточний період
                const statusInfo = getRegularTaskStatus(rt);
                
                html += `
                    <tr>
                        <td>
                            <div style="font-weight:500;">${esc(rt.title)}</div>
                            ${rt.expectedResult ? `<div style="font-size:0.75rem;color:#7f8c8d;margin-top:2px;"><i data-lucide="target" class="icon icon-sm"></i> ${esc(rt.expectedResult.substring(0, 50))}${rt.expectedResult.length > 50 ? '...' : ''}</div>` : ''}
                        </td>
                        <td>${esc(rt.function) || '-'}</td>
                        <td>
                            <span class="status-badge" style="background:#f3e5f5;color:#7b1fa2;">${pt[rt.period] || rt.period}</span>
                            <div style="font-size:0.8rem;margin-top:4px;">${scheduleText}</div>
                        </td>
                        <td>
                            <span class="status-badge" style="background:${statusInfo.color}20;color:${statusInfo.color};font-weight:500;">
                                <i data-lucide="${statusInfo.lucideIcon}" class="icon icon-sm" style="color:${statusInfo.color}"></i> ${statusInfo.text}
                            </span>
                        </td>
                        <td>
                            <div style="display:flex;flex-wrap:wrap;gap:2px;">
                                ${assigneeNames.slice(0, 2).map(n => `<span class="assignee-badge" style="font-size:0.7rem;">${n}</span>`).join('') || '-'}
                                ${assigneeNames.length > 2 ? `<span class="assignee-badge" style="font-size:0.7rem;">+${assigneeNames.length - 2}</span>` : ''}
                            </div>
                        </td>
                        <td>
                            <div class="action-btns">
                                ${statusInfo.status === 'notCreated' ? `
                                    <button class="action-btn" onclick="generateFromRegular('${escId(rt.id)}')" title="${t('create')}" style="background:#2196f3;color:white;"><i data-lucide="zap" class="icon icon-sm"></i></button>
                                    <button class="action-btn" onclick="completeRegularTask('${escId(rt.id)}')" title="${t('markDone')}" style="background:#4caf50;color:white;"><i data-lucide="check" class="icon icon-sm"></i></button>
                                ` : statusInfo.status === 'inProgress' ? `
                                    <button class="action-btn" onclick="completeRegularTask('${escId(rt.id)}')" title="${t('markDone')}" style="background:#4caf50;color:white;"><i data-lucide="check" class="icon icon-sm"></i></button>
                                ` : `
                                    <button class="action-btn" onclick="generateFromRegular('${escId(rt.id)}')" title="${t('createAgain')}" style="opacity:0.4;"><i data-lucide="zap" class="icon icon-sm"></i></button>
                                `}
                                ${rt.instruction ? `<button class="action-btn" onclick="showInstruction('${escId(rt.id)}')" title="${t('instruction')}"><i data-lucide="book-open" class="icon icon-sm"></i></button>` : ''}
                                <button class="action-btn" onclick="openRegularTaskModal('${escId(rt.id)}')" title="${t('edit')}"><i data-lucide="pencil" class="icon icon-sm"></i></button>
                                <button class="action-btn" onclick="deleteRegularTask('${escId(rt.id)}')" title="${t('delete')}"><i data-lucide="trash-2" class="icon icon-sm"></i></button>
                            </div>
                        </td>
                    </tr>`;
            });
            
            html += `</tbody></table>`;
            c.innerHTML = html;
            refreshIcons();
        }
        
        function showInstruction(id) {
            const rt = regularTasks.find(r => r.id === id);
            if (rt && rt.instruction) {
                alert(`${t('instructionLabel')}:\n\n${rt.instruction}`);
            }
        }
        
        // =====================
        // REGULAR CALENDAR VIEW
        // =====================
        
        let currentRegularView = 'week'; // week, list
        
        function setRegularView(view) {
            currentRegularView = view;
            
            // Update buttons
            document.querySelectorAll('#regularCalendarHeader .calendar-view-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.view === view);
            });
            
            // Show/hide containers
            const calendarContainer = document.getElementById('regularCalendarContainer');
            const listContainer = document.getElementById('regularListContainer');
            
            if (view === 'list') {
                calendarContainer.classList.remove('active');
                calendarContainer.style.display = 'none';
                listContainer.classList.add('active');
                listContainer.style.display = 'block';
                renderRegularTasks();
            } else {
                calendarContainer.classList.add('active');
                calendarContainer.style.display = 'block';
                listContainer.classList.remove('active');
                listContainer.style.display = 'none';
                renderRegularWeekView();
            }
            
            localStorage.setItem('regularView', view);
        }
        
        function renderRegularWeekView() {
            const headerEl = document.getElementById('regularWeekHeader');
            const bodyEl = document.getElementById('regularWeekBody');
            
            const todayJS = new Date().getDay(); // 0 = Sunday
            // Monday-first mapping: display column 0=Mon(1), 1=Tue(2), ..., 5=Sat(6), 6=Sun(0)
            const dayOrder = [1, 2, 3, 4, 5, 6, 0]; // JS getDay() values in Mon-first order
            const dayNamesFullUA = getDayNames(); // index = JS getDay()
            
            // Build header — Monday first
            let headerHTML = '';
            for (let col = 0; col < 7; col++) {
                const jsDay = dayOrder[col];
                const isToday = jsDay === todayJS;
                headerHTML += `
                    <div class="regular-week-day-header ${isToday ? 'today' : ''}">
                        <div class="day-name">${dayNamesFullUA[jsDay]}</div>
                    </div>
                `;
            }
            headerEl.innerHTML = headerHTML;
            
            // Build body with time grid
            let bodyHTML = '';
            const startHour = 6; // 06:00
            const endHour = 22; // 22:00
            const hourHeight = 60; // pixels per hour
            
            for (let col = 0; col < 7; col++) {
                const jsDay = dayOrder[col];
                const isToday = jsDay === todayJS;
                
                // Застосовуємо фільтри
                const ff = document.getElementById('regularFunctionFilter')?.value;
                const af = document.getElementById('regularAssigneeFilter')?.value;
                
                const dayTasks = regularTasks.filter(rt => {
                    // Фільтр по функції
                    if (ff && rt.function !== ff) return false;
                    // Фільтр по виконавцю
                    if (af) {
                        const func = functions.find(f => f.name === rt.function);
                        if (!func?.assigneeIds?.includes(af)) return false;
                    }
                    // Фільтр по дню
                    if (rt.period === 'daily') return true;
                    if (rt.period === 'weekly') {
                        if (rt.daysOfWeek && Array.isArray(rt.daysOfWeek)) {
                            return rt.daysOfWeek.includes(jsDay.toString());
                        } else if (rt.dayOfWeek) {
                            return rt.dayOfWeek === jsDay.toString();
                        }
                    }
                    return false;
                });
                
                // Calculate overlaps for parallel display
                const tasksWithPosition = calculateTaskPositions(dayTasks, startHour, hourHeight);
                
                bodyHTML += `<div class="regular-day-column ${isToday ? 'today' : ''}" data-day="${jsDay}">`;
                
                // Hour lines
                for (let h = startHour; h < endHour; h++) {
                    bodyHTML += `<div class="hour-line" style="top: ${(h - startHour) * hourHeight}px;"></div>`;
                }
                
                // Task blocks with calculated positions
                tasksWithPosition.forEach(taskPos => {
                    const rt = taskPos.task;
                    const timeStart = rt.timeStart || rt.time || '10:00';
                    const timeEnd = rt.timeEnd || calculateEndTime(timeStart, rt.duration || 60);
                    
                    // Get assignees from function
                    const func = functions.find(f => f.name === rt.function);
                    const assigneeNames = func?.assigneeIds?.map(id => {
                        const user = users.find(u => u.id === id);
                        return user?.name || user?.email?.split('@')[0] || '';
                    }).filter(Boolean) || [];
                    
                    // Status
                    const statusInfo = getRegularTaskStatus(rt);
                    const isCompleted = isToday && statusInfo.completedToday;
                    const isShort = taskPos.height < 50;
                    const isNarrow = taskPos.totalColumns > 1;
                    
                    // Width and left position for parallel tasks
                    const widthPercent = 100 / taskPos.totalColumns;
                    const leftPercent = taskPos.column * widthPercent;
                    
                    bodyHTML += `
                        <div class="regular-task-block ${isCompleted ? 'completed' : ''} ${isShort ? 'short' : ''} ${isNarrow ? 'narrow' : ''}"
                             style="top: ${taskPos.top}px; height: ${taskPos.height}px; left: calc(4px + ${leftPercent}%); width: calc(${widthPercent}% - 8px);"
                             onclick="openRegularTaskModal('${escId(rt.id)}')"
                             title="${esc(rt.title)}\n${timeStart} - ${timeEnd}\n${esc(rt.function) || ''}">
                            <div class="task-time">${timeStart} - ${timeEnd}</div>
                            <div class="task-title">${esc(rt.title)}</div>
                            ${!isShort && !isNarrow && assigneeNames.length > 0 ? `
                                <div class="task-assignee">${assigneeNames.map(n => esc(n)).slice(0, 2).join(', ')}${assigneeNames.length > 2 ? ` +${assigneeNames.length - 2}` : ''}</div>
                            ` : ''}
                            ${!isShort && !isNarrow && rt.function ? `<div class="task-function">${esc(rt.function)}</div>` : ''}
                        </div>
                    `;
                });
                
                bodyHTML += '</div>';
            }
            
            bodyEl.innerHTML = bodyHTML;
            refreshIcons();
            
            // Also update mobile view
            updateRegularDayTabs();
            renderMobileRegularDay();
        }
        
        // Calculate positions for overlapping tasks (like iOS calendar)
        function calculateTaskPositions(dayTasks, startHour, hourHeight) {
            if (!dayTasks.length) return [];
            
            // Convert tasks to time ranges
            const taskRanges = dayTasks.map(rt => {
                const timeStart = rt.timeStart || rt.time || '10:00';
                const [startH, startM] = timeStart.split(':').map(Number);
                const startMinutes = startH * 60 + startM;
                
                let durationMinutes = rt.duration || 60;
                if (rt.timeEnd && !rt.duration) {
                    const [endH, endM] = rt.timeEnd.split(':').map(Number);
                    durationMinutes = (endH * 60 + endM) - startMinutes;
                    if (durationMinutes <= 0) durationMinutes = 60;
                }
                
                const endMinutes = startMinutes + durationMinutes;
                const top = ((startH - startHour) * 60 + startM) * (hourHeight / 60);
                const height = Math.max(durationMinutes * (hourHeight / 60), 25);
                
                return {
                    task: rt,
                    startMinutes,
                    endMinutes,
                    top,
                    height,
                    column: 0,
                    totalColumns: 1
                };
            });
            
            // Sort by start time
            taskRanges.sort((a, b) => a.startMinutes - b.startMinutes);
            
            // Find overlapping groups and assign columns
            const groups = [];
            
            taskRanges.forEach(taskRange => {
                // Find or create a group that this task overlaps with
                let foundGroup = null;
                
                for (const group of groups) {
                    const overlapsWithGroup = group.some(t => 
                        taskRange.startMinutes < t.endMinutes && taskRange.endMinutes > t.startMinutes
                    );
                    
                    if (overlapsWithGroup) {
                        foundGroup = group;
                        break;
                    }
                }
                
                if (foundGroup) {
                    // Find available column
                    const usedColumns = new Set();
                    foundGroup.forEach(t => {
                        if (taskRange.startMinutes < t.endMinutes && taskRange.endMinutes > t.startMinutes) {
                            usedColumns.add(t.column);
                        }
                    });
                    
                    let col = 0;
                    while (usedColumns.has(col)) col++;
                    taskRange.column = col;
                    foundGroup.push(taskRange);
                } else {
                    // New group
                    taskRange.column = 0;
                    groups.push([taskRange]);
                }
            });
            
            // Calculate total columns for each group
            groups.forEach(group => {
                const maxCol = Math.max(...group.map(t => t.column)) + 1;
                group.forEach(t => t.totalColumns = maxCol);
            });
            
            return taskRanges;
        }
        
        function getRegularTaskStatus(rt) {
            const today = new Date();
            const todayDay = today.getDay();
            const todayDateStr = getLocalDateStr(today);
            
            // Check if task should run today
            let shouldRunToday = false;
            
            // Підтримка старого формату daily
            if (rt.period === 'daily') {
                shouldRunToday = true;
            } else if (rt.period === 'weekly') {
                // Підтримка нового формату (масив днів) і старого (один день)
                if (rt.daysOfWeek && Array.isArray(rt.daysOfWeek)) {
                    shouldRunToday = rt.daysOfWeek.includes(todayDay.toString());
                } else if (rt.dayOfWeek) {
                    shouldRunToday = rt.dayOfWeek === todayDay.toString();
                }
            } else if (rt.period === 'monthly') {
                const todayDate = today.getDate();
                if (rt.dayOfMonth === 'last') {
                    const lastDay = new Date(today.getFullYear(), today.getMonth() + 1, 0).getDate();
                    shouldRunToday = todayDate === lastDay;
                } else {
                    shouldRunToday = todayDate === parseInt(rt.dayOfMonth);
                }
            }
            
            // Check completion
            const lastCompleted = rt.lastCompleted?.toDate ? rt.lastCompleted.toDate() : null;
            const completedToday = lastCompleted && lastCompletegetLocalDateStr(d) === todayDateStr;
            
            // Check if task was generated today
            const generatedTasks = tasks.filter(t => 
                t.regularTaskId === rt.id && 
                t.createdAt?.toDate && 
                getLocalDateStr(t.createdAt.toDate()) === todayDateStr
            );
            
            if (completedToday) {
                return { status: 'completed', color: '#4caf50', text: t('completedStatus'), lucideIcon: 'check-circle', completedToday: true };
            } else if (generatedTasks.length > 0) {
                const allDone = generatedTasks.every(t => t.status === 'done');
                if (allDone) {
                    return { status: 'completed', color: '#4caf50', text: t('completedStatus'), lucideIcon: 'check-circle', completedToday: true };
                }
                return { status: 'inProgress', color: '#ff9800', text: t('inProgressStatus'), lucideIcon: 'clock', completedToday: false };
            } else if (shouldRunToday) {
                return { status: 'notCreated', color: '#2196f3', text: t('pendingStatus'), lucideIcon: 'circle', completedToday: false };
            } else {
                return { status: 'inactive', color: '#9e9e9e', text: 'Не сьогодні', lucideIcon: 'minus-circle', completedToday: false };
            }
        }
        
        // Mark regular task as completed
        async function markRegularTaskComplete(taskId) {
            // Haptic feedback
            if (navigator.vibrate) navigator.vibrate(10);
            
            const task = regularTasks.find(t => t.id === taskId);
            if (!task) return;
            
            const today = new Date();
            const todayStr = getLocalDateStr(today);
            
            // Check if already completed today
            const lastCompleted = task.lastCompleted?.toDate ? task.lastCompleted.toDate() : null;
            const completedToday = lastCompleted && lastCompletegetLocalDateStr(d) === todayStr;
            
            if (completedToday) {
                // Unmark as completed
                await db.collection('companies').doc(currentCompany).collection('regularTasks').doc(taskId).update({
                    lastCompleted: null
                });
                task.lastCompleted = null;
            } else {
                // Mark as completed
                const now = firebase.firestore.Timestamp.now();
                await db.collection('companies').doc(currentCompany).collection('regularTasks').doc(taskId).update({
                    lastCompleted: now
                });
                task.lastCompleted = now;
            }
            
            renderMyDay();
            if (currentRegularView === 'list') renderRegularTasks();
            else renderRegularWeekView();
            renderMobileRegularDay();
        }
        
        // Mobile Regular Tasks - selected day
        let selectedRegularDay = new Date().getDay();
        
        function selectRegularDay(day) {
            selectedRegularDay = day;
            updateRegularDayTabs();
            renderMobileRegularDay();
        }
        
        function updateRegularDayTabs() {
            const tabs = document.querySelectorAll('.regular-day-tab');
            const today = new Date().getDay();
            
            tabs.forEach(tab => {
                const tabDay = parseInt(tab.dataset.day);
                tab.classList.remove('active', 'today', 'has-tasks');
                
                if (tabDay === selectedRegularDay) {
                    tab.classList.add('active');
                }
                if (tabDay === today) {
                    tab.classList.add('today');
                }
                
                // Check if day has tasks
                const hasTasks = regularTasks.some(rt => {
                    if (rt.period === 'weekly') {
                        return parseInt(rt.dayOfWeek) === tabDay;
                    }
                    return false;
                });
                if (hasTasks) {
                    tab.classList.add('has-tasks');
                }
            });
        }
        
        function renderMobileRegularDay() {
            const container = document.getElementById('mobileRegularDayContent');
            if (!container) return;
            
            const today = new Date();
            const todayDay = today.getDay();
            const todayDate = today.getDate();
            const todayDateStr = getLocalDateStr(today);
            
            // Фільтри
            const ff = document.getElementById('regularFunctionFilter')?.value;
            const af = document.getElementById('regularAssigneeFilter')?.value;
            
            const applyUserFilters = (tasks) => {
                return tasks.filter(rt => {
                    if (ff && rt.function !== ff) return false;
                    if (af) {
                        const func = functions.find(f => f.name === rt.function);
                        if (!func?.assigneeIds?.includes(af)) return false;
                    }
                    return true;
                });
            };
            
            // Filter WEEKLY tasks for selected day
            const weeklyTasks = applyUserFilters(regularTasks.filter(rt => {
                if (rt.period === 'weekly') {
                    return parseInt(rt.dayOfWeek) === selectedRegularDay;
                }
                return false;
            })).sort((a, b) => (a.time || '').localeCompare(b.time || ''));
            
            // Get MONTHLY tasks (show in separate section)
            const monthlyTasks = applyUserFilters(regularTasks.filter(rt => rt.period === 'monthly'))
                .sort((a, b) => {
                    const dayA = a.dayOfMonth === 'last' ? 32 : parseInt(a.dayOfMonth);
                    const dayB = b.dayOfMonth === 'last' ? 32 : parseInt(b.dayOfMonth);
                    return dayA - dayB;
                });
            
            // Get QUARTERLY tasks
            const quarterlyTasks = applyUserFilters(regularTasks.filter(rt => rt.period === 'quarterly'))
                .sort((a, b) => (a.time || '').localeCompare(b.time || ''));
            
            let html = '';
            
            // Weekly tasks section
            if (weeklyTasks.length > 0) {
                weeklyTasks.forEach(rt => {
                    html += renderRegularTaskCard(rt);
                });
            } else if (monthlyTasks.length === 0 && quarterlyTasks.length === 0) {
                html += `
                    <div class="mobile-regular-empty">
                        <div class="mobile-regular-empty-icon"><svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#9ca3af" stroke-width="1.5"><path d="M9 5H7a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2h-2"/><rect x="9" y="3" width="6" height="4" rx="1"/><path d="M9 12h6m-6 4h6"/></svg></div>
                        <div class="mobile-regular-empty-text">Немає регулярних завдань</div>
                    </div>
                `;
            }
            
            // Monthly tasks section
            if (monthlyTasks.length > 0) {
                html += `<div class="mobile-regular-section-header">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2"/><path d="M16 2v4M8 2v4M3 10h18"/></svg>
                    ${t('monthlyTasks')}
                </div>`;
                monthlyTasks.forEach(rt => {
                    const dayLabel = rt.dayOfMonth === 'last' 
                        ? (t('lastDayLabel'))
                        : (`${rt.dayOfMonth}${t('dayOfMonthLabel')}`);
                    html += renderRegularTaskCard(rt, dayLabel);
                });
            }
            
            // Quarterly tasks section
            if (quarterlyTasks.length > 0) {
                html += `<div class="mobile-regular-section-header">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 3v18h18"/><path d="M18 17V9M13 17V5M8 17v-3"/></svg>
                    ${t('quarterlyTasks')}
                </div>`;
                quarterlyTasks.forEach(rt => {
                    html += renderRegularTaskCard(rt, t('oncePerQuarter'));
                });
            }
            
            container.innerHTML = html;
            refreshIcons();
        }
        
        function renderRegularTaskCard(rt, extraLabel = null) {
            const func = functions.find(f => f.name === rt.function);
            const assigneeNames = func?.assigneeIds?.map(id => {
                const user = users.find(u => u.id === id);
                return user?.name || user?.email?.split('@')[0] || '';
            }).filter(Boolean) || [];
            
            const statusInfo = getRegularTaskStatus(rt);
            
            return `
                <div class="regular-task-card ${statusInfo.completedToday ? 'completed' : ''}" 
                     onclick="openRegularTaskModal('${escId(rt.id)}')"
                     style="border-left-color: ${statusInfo.color};">
                    <div class="task-time">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg>
                        ${rt.timeStart || rt.time || '--:--'}
                        ${rt.estimatedTime ? ` • ${formatDuration(parseInt(rt.estimatedTime))}` : ''}
                        ${extraLabel ? ` • <span style="color:#8b5cf6;font-weight:500;">${extraLabel}</span>` : ''}
                    </div>
                    <div class="task-title">${esc(rt.title)}</div>
                    ${assigneeNames.length > 0 ? `
                        <div class="task-assignee">
                            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>
                            ${assigneeNames.map(n => esc(n)).slice(0, 2).join(', ')}${assigneeNames.length > 2 ? ` +${assigneeNames.length - 2}` : ''}
                        </div>
                    ` : ''}
                    ${rt.function ? `<div class="task-function">${esc(rt.function)}</div>` : ''}
                    <button class="regular-task-complete-btn ${statusInfo.completedToday ? 'completed' : ''}" 
                            onclick="event.stopPropagation();markRegularTaskComplete('${escId(rt.id)}')"
                            title="${statusInfo.completedToday ? 'Виконано сьогодні' : 'Позначити виконаним'}">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><polyline points="20 6 9 17 4 12"/></svg>
                    </button>
                </div>
            `;
        }
        
        function initRegularView() {
            const savedView = localStorage.getItem('regularView') || 'week';
            setRegularView(savedView);
            
            // Init mobile view
            selectedRegularDay = new Date().getDay();
            updateRegularDayTabs();
            renderMobileRegularDay();
        }

        // =====================
        // USERS & INVITES
        // =====================
        function openInviteModal() {
            document.getElementById('inviteModal').style.display = 'block';
            document.getElementById('inviteForm').reset();
            document.getElementById('inviteLink').style.display = 'none';
        }

        async function sendInvite(e) {
            e.preventDefault();
            if (currentUserData?.role === 'employee') { showToast(t('noPermissionTask'), 'error'); return; }
            const email = document.getElementById('inviteEmail').value.trim().toLowerCase();
            const role = document.getElementById('inviteRole').value;
            
            try {
                const inviteRef = await db.collection('invites').add({
                    email: email,
                    companyId: currentCompany,
                    role: role,
                    invitedBy: currentUser.uid,
                    accepted: false,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Унікальне посилання з ID інвайту
                const link = window.location.origin + window.location.pathname + '?invite=' + inviteRef.id;
                document.getElementById('inviteLinkText').value = link;
                document.getElementById('inviteLink').style.display = 'block';
                
                alert(t('inviteCreated'));
            } catch (e) {
                alert(t('error') + ': ' + e.message);
            }
        }

        function copyInviteLink() {
            const input = document.getElementById('inviteLinkText');
            input.select();
            document.execCommand('copy');
            alert(t('copied'));
        }

        async function deleteUser(id) {
            const u = users.find(x => x.id === id);
            if (u?.role === 'owner') { alert(t('cannotDeleteOwner')); return; }
            if (!confirm(t('deleteConfirm'))) return;
            
            const base = db.collection('companies').doc(currentCompany);
            await base.collection('users').doc(id).delete();
            
            // Cascade cleanup (batch for atomicity)
            try {
                const cascadeBatch = db.batch();
                let batchOps = 0;
                
                functions.forEach(f => {
                    if (f.assigneeIds?.includes(id) || f.headId === id) {
                        const upd = {};
                        if (f.assigneeIds?.includes(id)) { f.assigneeIds = f.assigneeIds.filter(uid => uid !== id); upd.assigneeIds = f.assigneeIds; }
                        if (f.headId === id) { f.headId = f.assigneeIds?.[0] || ''; upd.headId = f.headId; }
                        cascadeBatch.update(base.collection('functions').doc(f.id), upd);
                        batchOps++;
                    }
                });
                // FIX: Reassign tasks assigned to deleted user → fallback assignee
                const fallbackAssignee = users.find(u => u.role === 'owner' && u.id !== id) 
                    || users.find(u => u.role === 'manager' && u.id !== id);
                const fallbackId = fallbackAssignee?.id || '';
                const fallbackName = fallbackAssignee?.name || fallbackAssignee?.email || '';
                
                tasks.forEach(tk => {
                    const upd = {}; let need = false;
                    // Reassign primary assignee
                    if (tk.assigneeId === id) {
                        tk.assigneeId = fallbackId;
                        tk.assigneeName = fallbackName;
                        upd.assigneeId = fallbackId;
                        upd.assigneeName = fallbackName;
                        need = true;
                    }
                    // Clean up array fields
                    ['coExecutorIds','observerIds','notifyOnComplete'].forEach(fld => {
                        if (tk[fld]?.includes(id)) { tk[fld] = tk[fld].filter(uid => uid !== id); upd[fld] = tk[fld]; need = true; }
                    });
                    if (need) { cascadeBatch.update(base.collection('tasks').doc(tk.id), upd); batchOps++; }
                });
                
                // FIX: Firestore batch limit = 500 ops — use chunked writes
                if (batchOps > 0) {
                    if (batchOps <= 450) {
                        await cascadeBatch.commit();
                    } else {
                        // Rebuild in chunks of 450
                        let chunkBatch = db.batch(); let chunkCount = 0;
                        const allUpdates = [];
                        tasks.forEach(tk => {
                            const upd = {};
                            if (tk.assigneeId === fallbackId && tk._justReassigned) { upd.assigneeId = fallbackId; upd.assigneeName = fallbackName; }
                            ['coExecutorIds','observerIds','notifyOnComplete'].forEach(fld => {
                                if (tk[fld] && !tk[fld].includes(id) && tk['_cleaned_' + fld]) upd[fld] = tk[fld];
                            });
                            if (Object.keys(upd).length > 0) allUpdates.push({ id: tk.id, upd });
                        });
                        for (const item of allUpdates) {
                            chunkBatch.update(base.collection('tasks').doc(item.id), item.upd);
                            if (++chunkCount >= 450) { await chunkBatch.commit(); chunkBatch = db.batch(); chunkCount = 0; }
                        }
                        if (chunkCount > 0) await chunkBatch.commit();
                    }
                }
            } catch (e) { console.warn('[deleteUser] cascade:', e); }
            
            const idx = users.findIndex(x => x.id === id);
            if (idx >= 0) users.splice(idx, 1);
            renderUsers();
            updateSelects();
        }

        function renderUsers() {
            const c = document.getElementById('usersContainer');
            if (users.length === 0) {
                c.innerHTML = `<div class="empty-state" style="grid-column:1/-1;"><h3>${t('noUsers')}</h3></div>`;
                return;
            }
            
            const canEdit = currentUserData?.role === 'owner' || currentUserData?.role === 'manager';
            
            c.innerHTML = users.map(u => {
                const userFunctions = functions.filter(f => f.assigneeIds?.includes(u.id));
                const isOwner = u.role === 'owner';
                
                return `
                <div class="user-card">
                    <div class="user-header">
                        <div class="user-name">${esc(u.name || u.email)}</div>
                        <span class="role-badge ${u.role}">${getRoleText(u.role)}</span>
                    </div>
                    <div class="user-details">
                        <div><i data-lucide="mail" class="icon icon-sm"></i> ${esc(u.email)}</div>
                        ${u.position ? `<div><i data-lucide="briefcase" class="icon icon-sm"></i> ${esc(u.position)}</div>` : ''}
                    </div>
                    ${userFunctions.length > 0 ? `
                        <div style="margin:0.5rem 0;display:flex;flex-wrap:wrap;gap:0.25rem;">
                            ${userFunctions.map(f => `<span class="badge" style="font-size:0.7rem;background:#e8f5e9;color:#2e7d32;">${esc(f.name)}</span>`).join('')}
                        </div>
                    ` : ''}
                    <div class="user-stats">
                        <span><i data-lucide="file-text" class="icon icon-sm"></i> ${tasks.filter(task => task.assigneeId === u.id).length} ${t('tasks')}</span>
                        <div style="display:flex;gap:0.25rem;">
                            ${canEdit && !isOwner ? `<button class="btn btn-small" onclick="openUserModal('${u.id}')" title="${t('edit')}"><i data-lucide="pencil" class="icon icon-sm"></i></button>` : ''}
                            ${canEdit && !isOwner ? `<button class="btn btn-small btn-danger" onclick="deleteUser('${u.id}')" title="${t('delete')}"><i data-lucide="trash-2" class="icon icon-sm"></i></button>` : ''}
                        </div>
                    </div>
                </div>
            `}).join('');
            refreshIcons();
        }
        
        let editingUserId = null;
        
        function openUserModal(userId = null) {
            editingUserId = userId;
            const modal = document.getElementById('userModal');
            
            // Заповнюємо список функцій
            const userFunctionsDiv = document.getElementById('userFunctions');
            userFunctionsDiv.innerHTML = functions.map(f => `
                <label class="assignee-checkbox">
                    <input type="checkbox" value="${f.id}" data-fname="${esc(f.name)}">
                    ${esc(f.name)}
                </label>
            `).join('') || `<p style="color:#7f8c8d;">${t('noFunctions')}</p>`;
            
            if (userId) {
                const user = users.find(u => u.id === userId);
                if (user) {
                    document.getElementById('userName').value = user.name || '';
                    document.getElementById('userEmail').value = user.email || '';
                    document.getElementById('userRole').value = user.role || 'employee';
                    document.getElementById('userPosition').value = user.position || '';
                    document.getElementById('userModalTitle').textContent = t('editEmployee');
                    
                    // Відмічаємо функції користувача
                    const userFunctions = functions.filter(f => f.assigneeIds?.includes(userId));
                    userFunctions.forEach(f => {
                        const checkbox = userFunctionsDiv.querySelector(`input[value="${f.id}"]`);
                        if (checkbox) checkbox.checked = true;
                    });
                }
            } else {
                document.getElementById('userForm').reset();
                document.getElementById('userModalTitle').textContent = t('addEmployee');
            }
            
            modal.style.display = 'block';
        }
        
        async function saveUser(e) {
            e.preventDefault();
            
            if (!editingUserId) return;
            
            const name = document.getElementById('userName').value.trim();
            const role = document.getElementById('userRole').value;
            const position = document.getElementById('userPosition').value.trim();
            
            try {
                // Оновлюємо дані користувача
                await db.collection('companies').doc(currentCompany).collection('users').doc(editingUserId).update({
                    name: name,
                    role: role,
                    position: position
                });
                
                // Оновлюємо функції
                const selectedFunctions = Array.from(document.querySelectorAll('#userFunctions input:checked')).map(cb => cb.value);
                
                // Для кожної функції перевіряємо чи потрібно додати/видалити користувача
                for (const func of functions) {
                    const funcRef = db.collection('companies').doc(currentCompany).collection('functions').doc(func.id);
                    const isSelected = selectedFunctions.includes(func.id);
                    const isCurrentlyAssigned = func.assigneeIds?.includes(editingUserId);
                    
                    if (isSelected && !isCurrentlyAssigned) {
                        await funcRef.update({
                            assigneeIds: firebase.firestore.FieldValue.arrayUnion(editingUserId)
                        });
                    } else if (!isSelected && isCurrentlyAssigned) {
                        await funcRef.update({
                            assigneeIds: firebase.firestore.FieldValue.arrayRemove(editingUserId)
                        });
                    }
                }
                
                closeModal('userModal');
                
                // Локальне оновлення користувача
                const userIdx = users.findIndex(u => u.id === editingUserId);
                if (userIdx >= 0) {
                    users[userIdx] = { 
                        ...users[userIdx], 
                        name: document.getElementById('userName').value.trim(),
                        role: document.getElementById('userRole').value,
                        position: document.getElementById('userPosition').value.trim()
                    };
                }
                
                // Локальне оновлення функцій (використовуємо selectedFunctions з рядка вище)
                functions.forEach(func => {
                    const isSelected = selectedFunctions.includes(func.id);
                    const isCurrentlyAssigned = func.assigneeIds?.includes(editingUserId);
                    if (isSelected && !isCurrentlyAssigned) {
                        func.assigneeIds = [...(func.assigneeIds || []), editingUserId];
                    } else if (!isSelected && isCurrentlyAssigned) {
                        func.assigneeIds = (func.assigneeIds || []).filter(id => id !== editingUserId);
                    }
                });
                
                renderUsers();
                renderFunctions();
                updateSelects();
            } catch (e) {
                alert(t('error') + ': ' + e.message);
            }
        }

        // =====================
        // CONTROL DASHBOARD
        // =====================
        function renderControl() {
            const af = document.getElementById('controlAssigneeFilter')?.value;
            const ff = document.getElementById('controlFunctionFilter')?.value;
            const pf = document.getElementById('controlPeriodFilter')?.value;
            
            // Оновлюємо селекти
            const assigneeSelect = document.getElementById('controlAssigneeFilter');
            const functionSelect = document.getElementById('controlFunctionFilter');
            const activeFunctions = functions.filter(f => f.status !== 'archived');
            if (assigneeSelect && assigneeSelect.options.length <= 1) {
                assigneeSelect.innerHTML = `<option value="">${t('allAssignees')}</option>` + users.map(u => `<option value="${esc(u.id)}">${esc(u.name || u.email)}</option>`).join('');
            }
            if (functionSelect && functionSelect.options.length <= 1) {
                functionSelect.innerHTML = `<option value="">${t('allFunctions')}</option>` + activeFunctions.map(f => `<option value="${esc(f.name)}">${esc(f.name)}</option>`).join('');
            }
            
            const now = new Date();
            const today = getLocalDateStr(now);
            const tm = new Date(now); tm.setDate(tm.getDate() + 1);
            const tomorrow = getLocalDateStr(tm);
            
            // Фільтруємо завдання
            let filteredTasks = tasks.filter(task => {
                if (!isTaskVisibleToUser(task)) return false;
                if (af && task.assigneeId !== af) return false;
                if (ff && task.function !== ff) return false;
                if (pf === 'today') {
                    const taskDate = parseDeadline(task).date;
                    if (taskDate !== today) return false;
                }
                if (pf === 'week') {
                    const taskDate = parseDeadline(task).date;
                    const weekLater = new Date();
                    weekLater.setDate(weekLater.getDate() + 7);
                    if (taskDate > getLocalDateStr(weekLater) || taskDate < today) return false;
                }
                if (pf === 'month') {
                    const taskDate = parseDeadline(task).date;
                    const monthLater = new Date();
                    monthLater.setMonth(monthLater.getMonth() + 1);
                    if (taskDate > getLocalDateStr(monthLater) || taskDate < today) return false;
                }
                return true;
            });
            
            const urgent = filteredTasks.filter(task => {
                const taskDate = parseDeadline(task).date;
                return taskDate && taskDate < today && task.status !== 'done' && task.status !== 'review';
            }).length;
            
            const warning = filteredTasks.filter(task => {
                const taskDate = parseDeadline(task).date;
                return (taskDate === today || taskDate === tomorrow) && task.status !== 'done';
            }).length;
            
            const active = filteredTasks.filter(task => task.status === 'progress').length;
            const completed = filteredTasks.filter(task => task.status === 'done').length;
            
            document.getElementById('urgentCount').textContent = urgent;
            document.getElementById('warningCount').textContent = warning;
            document.getElementById('activeCount').textContent = active;
            document.getElementById('completedCount').textContent = completed;
            
            renderControlContent();
        }
        
        function renderControlContent() {
            const viewType = document.getElementById('controlViewType')?.value || 'workload';
            const af = document.getElementById('controlAssigneeFilter')?.value;
            const ff = document.getElementById('controlFunctionFilter')?.value;
            
            let filteredTasks = tasks.filter(task => {
                if (!isTaskVisibleToUser(task)) return false;
                if (af && task.assigneeId !== af) return false;
                if (ff && task.function !== ff) return false;
                return task.status !== 'done';
            });
            
            const content = document.getElementById('controlContent');
            
            if (viewType === 'workload') {
                // Group tasks by assignee
                const wl = {};
                filteredTasks.forEach(task => { 
                    const key = task.assigneeId || 'unassigned';
                    const name = task.assigneeName || t('notAssigned');
                    if (!wl[key]) wl[key] = { name, tasks: [] };
                    wl[key].tasks.push(task);
                });
                
                content.innerHTML = `
                    <h3 style="margin-bottom:1rem;">${t('employeeWorkload')}</h3>
                    ${Object.entries(wl).sort((a,b) => b[1].tasks.length - a[1].tasks.length).map(([id, data]) => {
                        const c = data.tasks.length;
                        const tasksList = data.tasks.map(t => {
                            const deadline = t.deadlineDate || '';
                            const isOverdue = deadline && deadline < getLocalDateStr();
                            return `
                                <div class="control-task-item ${isOverdue ? 'overdue' : ''}" onclick="openTaskModal('${escId(t.id)}')">
                                    <span class="task-title">${esc(t.title)} ${getEscalationBadgeHtml(t)}</span>
                                    <span class="task-meta">
                                        ${t.function ? `<span class="task-func">${esc(t.function)}</span>` : ''}
                                        ${deadline ? `<span class="task-date ${isOverdue ? 'overdue' : ''}">${deadline}</span>` : ''}
                                    </span>
                                </div>
                            `;
                        }).join('');
                        
                        return `
                            <div class="control-row" onclick="this.classList.toggle('expanded')">
                                <div class="control-row-header">
                                    <span><i data-lucide="user" class="icon icon-sm"></i> ${esc(data.name)}</span>
                                    <span class="control-row-count" style="color:${c > 5 ? '#e74c3c' : '#27ae60'};">${c} ${t('tasks')} <i data-lucide="chevron-down" class="icon icon-sm expand-icon"></i></span>
                                </div>
                                <div class="control-row-tasks">${tasksList}</div>
                            </div>
                        `;
                    }).join('') || `<p style="color:#7f8c8d;">${t('noActiveTasks')}</p>`}
                `;
            } else {
                // Group tasks by function
                const byFunc = {};
                filteredTasks.forEach(task => { 
                    const fn = task.function || t('noFunction');
                    if (!byFunc[fn]) byFunc[fn] = [];
                    byFunc[fn].push(task);
                });
                
                content.innerHTML = `
                    <h3 style="margin-bottom:1rem;">${t('byFunctions')}</h3>
                    ${Object.entries(byFunc).sort((a,b) => b[1].length - a[1].length).map(([fn, taskList]) => {
                        const c = taskList.length;
                        const tasksHTML = taskList.map(t => {
                            const deadline = t.deadlineDate || '';
                            const isOverdue = deadline && deadline < getLocalDateStr();
                            return `
                                <div class="control-task-item ${isOverdue ? 'overdue' : ''}" onclick="event.stopPropagation(); openTaskModal('${escId(t.id)}')">
                                    <span class="task-title">${esc(t.title)} ${getEscalationBadgeHtml(t)}</span>
                                    <span class="task-meta">
                                        ${t.assigneeName ? `<span class="task-assignee">${esc(t.assigneeName)}</span>` : ''}
                                        ${deadline ? `<span class="task-date ${isOverdue ? 'overdue' : ''}">${deadline}</span>` : ''}
                                    </span>
                                </div>
                            `;
                        }).join('');
                        
                        return `
                            <div class="control-row" onclick="this.classList.toggle('expanded')">
                                <div class="control-row-header">
                                    <span><i data-lucide="settings" class="icon icon-sm"></i> ${esc(fn)}</span>
                                    <span class="control-row-count" style="color:#3498db;">${c} ${t('tasks')} <i data-lucide="chevron-down" class="icon icon-sm expand-icon"></i></span>
                                </div>
                                <div class="control-row-tasks">${tasksHTML}</div>
                            </div>
                        `;
                    }).join('') || `<p style="color:#7f8c8d;">${t('noActiveTasks')}</p>`}
                `;
            }
            
            refreshIcons();
        }
        
        function clearControlFilters() {
            document.getElementById('controlAssigneeFilter').value = '';
            document.getElementById('controlFunctionFilter').value = '';
            document.getElementById('controlPeriodFilter').value = '';
            renderControl();
        }
        
        function clearRegularFilters() {
            document.getElementById('regularAssigneeFilter').value = '';
            document.getElementById('regularFunctionFilter').value = '';
            document.getElementById('regularDayFilter').value = '';
            applyRegularFilters();
        }

        // =====================
        // ADMIN FUNCTIONS
        // =====================
        async function renderAdminPanel() {
            // Автоматично завантажуємо список при відкритті вкладки
            loadAdminCompanies();
        }
        
        async function loadAdminCompanies() {
            if (!isSuperAdmin) return;
            
            const container = document.getElementById('adminCompaniesList');
            container.innerHTML = '<p style="color:var(--gray);text-align:center;padding:1rem;">Завантаження...</p>';
            
            try {
                const companiesSnap = await db.collection('companies').orderBy('createdAt', 'desc').get();
                
                if (companiesSnap.empty) {
                    container.innerHTML = '<p style="color:var(--gray);text-align:center;padding:2rem;">Компаній ще немає</p>';
                    return;
                }
                
                let html = `
                    <table style="width:100%;border-collapse:collapse;font-size:0.85rem;">
                        <thead>
                            <tr style="background:#f9fafb;text-align:left;">
                                <th style="padding:0.75rem;border-bottom:2px solid #e5e7eb;">Компанія</th>
                                <th style="padding:0.75rem;border-bottom:2px solid #e5e7eb;">Власник</th>
                                <th style="padding:0.75rem;border-bottom:2px solid #e5e7eb;">Email</th>
                                <th style="padding:0.75rem;border-bottom:2px solid #e5e7eb;">Створено</th>
                                <th style="padding:0.75rem;border-bottom:2px solid #e5e7eb;">Юзери</th>
                                <th style="padding:0.75rem;border-bottom:2px solid #e5e7eb;">Завдання</th>
                                <th style="padding:0.75rem;border-bottom:2px solid #e5e7eb;">Статус</th>
                                <th style="padding:0.75rem;border-bottom:2px solid #e5e7eb;width:80px;"></th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                for (const doc of companiesSnap.docs) {
                    const company = doc.data();
                    const companyId = doc.id;
                    
                    // Отримуємо кількість юзерів та завдань
                    const [usersSnap, tasksSnap] = await Promise.all([
                        db.collection('companies').doc(companyId).collection('users').get(),
                        db.collection('companies').doc(companyId).collection('tasks').get()
                    ]);
                    
                    const createdAt = company.createdAt?.toDate?.() 
                        ? company.createdAt.toDate().toLocaleDateString('uk-UA') 
                        : '-';
                    
                    html += `
                        <tr style="border-bottom:1px solid #e5e7eb;${company.disabled ? 'opacity:0.6;background:#fef2f2;' : ''}" id="company-row-${companyId}">
                            <td style="padding:0.75rem;font-weight:600;">${esc(company.name || 'Без назви')}</td>
                            <td style="padding:0.75rem;">${esc(company.ownerName || '-')}</td>
                            <td style="padding:0.75rem;"><code style="background:#f3f4f6;padding:0.15rem 0.4rem;border-radius:4px;font-size:0.8rem;">${esc(company.ownerEmail || '-')}</code></td>
                            <td style="padding:0.75rem;color:var(--gray);">${createdAt}</td>
                            <td style="padding:0.75rem;text-align:center;">
                                <span style="background:#dbeafe;color:#1d4ed8;padding:0.2rem 0.5rem;border-radius:10px;font-size:0.75rem;font-weight:600;">${usersSnap.size}</span>
                            </td>
                            <td style="padding:0.75rem;text-align:center;">
                                <span style="background:#dcfce7;color:#16a34a;padding:0.2rem 0.5rem;border-radius:10px;font-size:0.75rem;font-weight:600;">${tasksSnap.size}</span>
                            </td>
                            <td style="padding:0.75rem;text-align:center;">
                                <span style="padding:0.2rem 0.5rem;border-radius:10px;font-size:0.75rem;font-weight:600;${company.disabled ? 'background:#fee2e2;color:#dc2626;' : 'background:#dcfce7;color:#16a34a;'}">${company.disabled ? 'Заблоковано' : 'Активна'}</span>
                            </td>
                            <td style="padding:0.75rem;text-align:center;display:flex;gap:0.25rem;">
                                <button onclick="toggleCompanyDisabled('${companyId}', ${!!company.disabled})" 
                                    style="background:${company.disabled ? '#dcfce7' : '#fef3c7'};color:${company.disabled ? '#16a34a' : '#92400e'};border:none;padding:0.4rem 0.6rem;border-radius:6px;cursor:pointer;font-size:0.75rem;"
                                    title="${company.disabled ? 'Розблокувати' : 'Заблокувати'}">
                                    ${company.disabled ? '✓' : '⊘'}
                                </button>
                                <button onclick="deleteCompany('${escId(companyId)}', '${escId(company.name || '')}', ${usersSnap.size}, ${tasksSnap.size})" 
                                    style="background:#fee2e2;color:#dc2626;border:none;padding:0.4rem 0.6rem;border-radius:6px;cursor:pointer;font-size:0.75rem;"
                                    title="Видалити компанію">
                                    ✕
                                </button>
                            </td>
                        </tr>
                    `;
                }
                
                html += '</tbody></table>';
                container.innerHTML = html;
                
            } catch (error) {
                console.error('Error loading companies:', error);
                container.innerHTML = '<p style="color:var(--danger);text-align:center;padding:1rem;">Помилка завантаження: ' + error.message + '</p>';
            }
        }
        
        async function toggleCompanyDisabled(companyId, currentlyDisabled) {
            if (!isSuperAdmin) return;
            const newState = !currentlyDisabled;
            const action = newState ? 'Заблокувати' : 'Розблокувати';
            if (!confirm(t('confirmCompanyAction').replace('{action}', action))) return;
            
            try {
                await db.collection('companies').doc(companyId).update({ disabled: newState });
                showToast(newState ? t('companyBlocked') : t('companyUnblocked'), newState ? 'warning' : 'success');
                loadAdminCompanies();
            } catch (e) {
                console.error('Toggle disabled error:', e);
                alert(t('error') + ': ' + e.message);
            }
        }
        
        async function deleteCompany(companyId, companyName, usersCount, tasksCount) {
            if (!isSuperAdmin) return;
            
            // Підтвердження з інформацією про те що буде видалено
            const confirmMsg = t('deleteCompanyConfirm').replace('{name}', companyName).replace('{users}', usersCount).replace('{tasks}', tasksCount);
            
            if (!confirm(confirmMsg)) return;
            
            // Друге підтвердження для безпеки
            const confirmMsg2 = t('deleteCompanyConfirm2').replace('{name}', companyName);
            
            const userInput = prompt(confirmMsg2);
            if (userInput?.toLowerCase() !== 'так' && userInput?.toLowerCase() !== 'да') {
                return;
            }
            
            // Показуємо що йде видалення
            const row = document.getElementById(`company-row-${companyId}`);
            if (row) {
                row.style.opacity = '0.5';
                row.style.pointerEvents = 'none';
            }
            
            try {
                // Видаляємо всі підколекції (chunked — Firestore batch limit 500)
                const deleteOps = [];
                
                // Видаляємо users
                const usersSnap = await db.collection('companies').doc(companyId).collection('users').get();
                usersSnap.forEach(doc => deleteOps.push({ type: 'delete', ref: doc.ref }));
                
                // Видаляємо tasks та їх comments
                const tasksSnap = await db.collection('companies').doc(companyId).collection('tasks').get();
                for (const taskDoc of tasksSnap.docs) {
                    const commentsSnap = await taskDoc.ref.collection('comments').get();
                    commentsSnap.forEach(commentDoc => deleteOps.push({ type: 'delete', ref: commentDoc.ref }));
                    deleteOps.push({ type: 'delete', ref: taskDoc.ref });
                }
                
                // Видаляємо functions
                const functionsSnap = await db.collection('companies').doc(companyId).collection('functions').get();
                functionsSnap.forEach(doc => deleteOps.push({ type: 'delete', ref: doc.ref }));
                
                // Видаляємо regularTasks
                const regularSnap = await db.collection('companies').doc(companyId).collection('regularTasks').get();
                regularSnap.forEach(doc => deleteOps.push({ type: 'delete', ref: doc.ref }));
                
                // Видаляємо processes та templates
                const processesSnap = await db.collection('companies').doc(companyId).collection('processes').get();
                processesSnap.forEach(doc => deleteOps.push({ type: 'delete', ref: doc.ref }));
                const templatesSnap = await db.collection('companies').doc(companyId).collection('processTemplates').get();
                templatesSnap.forEach(doc => deleteOps.push({ type: 'delete', ref: doc.ref }));
                const projectsSnap = await db.collection('companies').doc(companyId).collection('projects').get();
                projectsSnap.forEach(doc => deleteOps.push({ type: 'delete', ref: doc.ref }));
                
                // Chunked commit (auto-splits at 450)
                await safeBatchCommit(deleteOps);
                console.log(`[deleteCompany] Deleted ${deleteOps.length} documents in chunks`);
                
                // Видаляємо саму компанію
                await db.collection('companies').doc(companyId).delete();
                
                // Видаляємо invite якщо є
                const invitesSnap = await db.collection('invites').where('companyId', '==', companyId).get();
                invitesSnap.forEach(async doc => await doc.ref.delete());
                
                // Видаляємо рядок з таблиці
                if (row) row.remove();
                
                showToast(t('companyDeleted'), 'success');
                
            } catch (error) {
                console.error('Error deleting company:', error);
                showToast(t('deleteError') + error.message, 'error');
                
                // Повертаємо вигляд рядка
                if (row) {
                    row.style.opacity = '1';
                    row.style.pointerEvents = 'auto';
                }
            }
        }

        async function adminCreateCompany(e) {
            e.preventDefault();
            if (!isSuperAdmin) return;
            
            const email = document.getElementById('adminOwnerEmail').value.trim().toLowerCase();
            const password = document.getElementById('adminOwnerPassword').value;
            const name = document.getElementById('adminOwnerName').value.trim();
            const companyName = document.getElementById('adminCompanyName').value.trim();
            
            const btn = document.getElementById('adminCreateBtn');
            btn.disabled = true;
            btn.textContent = t('creating');
            
            try {
                const companyRef = db.collection('companies').doc();
                const companyId = companyRef.id;
                
                await companyRef.set({
                    name: companyName,
                    ownerName: name,
                    ownerEmail: email,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    createdBy: currentUser.uid
                });
                
                await db.collection('invites').add({
                    email: email,
                    companyId: companyId,
                    role: 'owner',
                    ownerName: name,
                    tempPassword: password,
                    invitedBy: currentUser.uid,
                    accepted: false,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                alert(t('companyCreated').replace('{name}', companyName).replace('{email}', email).replace('{password}', password));
                
                document.getElementById('adminCreateForm').reset();
                
                // Оновлюємо список компаній
                loadAdminCompanies();
                
            } catch (e) {
                alert(t('error') + ': ' + e.message);
            }
            
            btn.disabled = false;
            btn.textContent = t('createCompanyBtn');
        }

        // =====================
        // HELPERS
        // =====================
        let _selectsUsersHash = '';
        let _selectsFuncsHash = '';
        
        function updateSelects(force) {
            const uHash = users.map(u => u.id).join(',');
            const fHash = functions.filter(f => f.status !== 'archived').map(f => f.name).join(',');
            if (!force && uHash === _selectsUsersHash && fHash === _selectsFuncsHash) return;
            _selectsUsersHash = uHash;
            _selectsFuncsHash = fHash;
            
            const tf = document.getElementById('taskFunction');
            const ta = document.getElementById('taskAssignee');
            const ff = document.getElementById('functionFilter');
            const af = document.getElementById('assigneeFilter');
            const raf = document.getElementById('regularAssigneeFilter');
            const rff = document.getElementById('regularFunctionFilter');
            const caf = document.getElementById('calendarAssigneeFilter');
            const cff = document.getElementById('calendarFunctionFilter');
            const paf = document.getElementById('processAssigneeFilter');
            
            // Фільтруємо архівовані функції
            const activeFunctions = functions.filter(f => f.status !== 'archived');
            
            if (tf) tf.innerHTML = `<option value="">${t('noFunction')}</option>` + activeFunctions.map(f => `<option value="${esc(f.name)}">${esc(f.name)}</option>`).join('');
            if (ta) ta.innerHTML = `<option value="">${t('select')}</option>` + users.map(u => `<option value="${esc(u.id)}">${esc(u.name || u.email)}</option>`).join('');
            if (ff) ff.innerHTML = `<option value="">${t('allFunctions')}</option>` + activeFunctions.map(f => `<option value="${esc(f.name)}">${esc(f.name)}</option>`).join('');
            if (af) af.innerHTML = `<option value="">${t('allAssignees')}</option>` + users.map(u => `<option value="${esc(u.id)}">${esc(u.name || u.email)}</option>`).join('');
            if (raf) raf.innerHTML = `<option value="">${t('allAssignees')}</option>` + users.map(u => `<option value="${esc(u.id)}">${esc(u.name || u.email)}</option>`).join('');
            if (rff) rff.innerHTML = `<option value="">${t('allFunctions')}</option>` + activeFunctions.map(f => `<option value="${esc(f.name)}">${esc(f.name)}</option>`).join('');
            if (caf) caf.innerHTML = `<option value="">${t('allAssignees')}</option>` + users.map(u => `<option value="${esc(u.id)}">${esc(u.name || u.email)}</option>`).join('');
            if (cff) cff.innerHTML = `<option value="">${t('allFunctions')}</option>` + activeFunctions.map(f => `<option value="${esc(f.name)}">${esc(f.name)}</option>`).join('');
            if (paf) paf.innerHTML = `<option value="">${t('allAssignees')}</option>` + users.map(u => `<option value="${esc(u.id)}">${esc(u.name || u.email)}</option>`).join('');
            const rta = document.getElementById('regularTaskAssignee');
            if (rta) rta.innerHTML = `<option value="">${t('fromFunctionAuto')}</option>` + users.map(u => `<option value="${esc(u.id)}">${esc(u.name || u.email)}</option>`).join('');
        }

        function formatDate(s) {
            const d = new Date(s);
            return d.toLocaleDateString(getLocale(), { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' });
        }

        function switchTab(tabName) {
            // Reset project detail when leaving projects tab
            if (tabName !== 'projects' && openProjectId) {
                openProjectId = null;
            }
            
            document.querySelectorAll('.tab-content').forEach(x => x.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(x => x.classList.remove('active'));
            document.getElementById(tabName + 'Tab').classList.add('active');
            document.querySelector(`[onclick="switchTab('${tabName}')"]`)?.classList.add('active');
            
            // Update bottom nav
            document.querySelectorAll('.bottom-nav-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.tab === tabName) btn.classList.add('active');
            });
            
            // Update FAB
            updateFab(tabName);
            
            // Scroll to top при переключенні вкладок
            window.scrollTo(0, 0);
            const mainEl = document.getElementById('mainInterface');
            if (mainEl) mainEl.scrollTop = 0;
            
            switch (tabName) {
                case 'myday': renderMyDay(); break;
                case 'tasks': setCalendarView(currentCalendarView); break;
                case 'control': renderControl(); break;
                case 'processes': updateProcessTemplateFilter(); renderProcessBoard(); break;
                case 'projects': renderProjects(); break;
                case 'regular': renderRegularTasks(); break;
                case 'functions': renderFunctions(); break;
                case 'users': renderUsers(); break;
                case 'analytics': renderAnalytics(); break;
                case 'admin': renderAdminPanel(); break;
            }
        }
        
        function updateFab(tabName) {
            const fab = document.getElementById('fabAdd');
            if (!fab) return;
            
            if (tabName === 'tasks') {
                fab.style.display = 'flex';
                fab.onclick = () => openTaskModal();
            } else if (tabName === 'regular') {
                fab.style.display = 'flex';
                fab.onclick = () => openRegularTaskModal();
            } else if (tabName === 'projects') {
                fab.style.display = 'flex';
                fab.onclick = () => openProjectModal();
            } else {
                fab.style.display = 'none';
            }
        }
        
        function renderAnalytics() {
            const visibleTasks = tasks.filter(t => isTaskVisibleToUser(t));
            const totalTasks = visibleTasks.length;
            const completedTasks = visibleTasks.filter(t => t.status === 'done').length;
            const completionRate = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;
            
            document.getElementById('analyticsTotalTasks').textContent = totalTasks;
            document.getElementById('analyticsCompletedTasks').textContent = completedTasks;
            document.getElementById('analyticsCompletionRate').textContent = completionRate + '%';
            
            // Середній час виконання
            let totalTime = 0;
            let countWithTime = 0;
            visibleTasks.forEach(task => {
                if (task.estimatedTime) {
                    totalTime += parseInt(task.estimatedTime);
                    countWithTime++;
                }
            });
            const avgTime = countWithTime > 0 ? Math.round(totalTime / countWithTime) : 0;
            const avgHours = Math.floor(avgTime / 60);
            const avgMins = avgTime % 60;
            document.getElementById('analyticsAvgTime').textContent = avgTime > 0 ? `${avgHours > 0 ? avgHours + 'г ' : ''}${avgMins}хв` : '-';
            
            // Статистика по статусах
            const byStatus = {
                new: visibleTasks.filter(task => task.status === 'new').length,
                progress: visibleTasks.filter(task => task.status === 'progress').length,
                review: visibleTasks.filter(task => task.status === 'review').length,
                done: visibleTasks.filter(task => task.status === 'done').length
            };
            
            // Прострочені
            const today = new Date();
            const todayStr = getLocalDateStr(today);
            const overdueTasks = visibleTasks.filter(task => {
                const taskDate = parseDeadline(task).date;
                return taskDate && taskDate < todayStr && task.status !== 'done' && task.status !== 'review';
            });
            
            document.getElementById('analyticsContent').innerHTML = `
                ${renderWeeklyChart(visibleTasks, today)}
                
                <div style="display:grid;grid-template-columns:repeat(auto-fit, minmax(280px, 1fr));gap:1rem;margin-top:1rem;">
                    ${renderStatusCard(byStatus, overdueTasks.length)}
                    ${renderTopPerformers(visibleTasks)}
                    ${renderOverdueDetails(overdueTasks)}
                    ${renderStuckProcesses()}
                    ${renderFunctionLoad(visibleTasks)}
                </div>
            `;
            refreshIcons();
        }
        
        function renderWeeklyChart(visibleTasks, today) {
            // 7 днів назад
            const days = [];
            for (let i = 6; i >= 0; i--) {
                const d = new Date(today);
                d.setDate(d.getDate() - i);
                days.push(getLocalDateStr(d));
            }
            const dayNames = ['Нд','Пн','Вт','Ср','Чт','Пт','Сб'];
            
            // Рахуємо завершені і створені по днях
            const doneByDay = {};
            const createdByDay = {};
            days.forEach(d => { doneByDay[d] = 0; createdByDay[d] = 0; });
            
            visibleTasks.forEach(t => {
                // Completed
                if (t.status === 'done' && t.completedAt) {
                    let cDate;
                    if (t.completedAt.toDate) cDate = getLocalDateStr(t.completedAt.toDate());
                    else if (typeof t.completedAt === 'string') cDate = t.completedAt.split('T')[0];
                    if (cDate && doneByDay[cDate] !== undefined) doneByDay[cDate]++;
                }
                // Created
                if (t.createdAt) {
                    let crDate;
                    if (t.createdAt.toDate) crDate = getLocalDateStr(t.createdAt.toDate());
                    else if (typeof t.createdAt === 'string') crDate = t.createdAt.split('T')[0];
                    if (crDate && createdByDay[crDate] !== undefined) createdByDay[crDate]++;
                }
            });
            
            const maxVal = Math.max(1, ...Object.values(doneByDay), ...Object.values(createdByDay));
            
            const bars = days.map(d => {
                const done = doneByDay[d] || 0;
                const created = createdByDay[d] || 0;
                const dayDate = new Date(d);
                const label = dayNames[dayDate.getDay()];
                const dateNum = dayDate.getDate();
                const isToday = d === getLocalDateStr(today);
                
                return `<div style="flex:1;display:flex;flex-direction:column;align-items:center;gap:4px;">
                    <div style="display:flex;gap:2px;align-items:flex-end;height:80px;">
                        <div style="width:14px;background:#dbeafe;border-radius:3px 3px 0 0;height:${Math.max(2, (created/maxVal)*70)}px;" title="Створено: ${created}"></div>
                        <div style="width:14px;background:#22c55e;border-radius:3px 3px 0 0;height:${Math.max(2, (done/maxVal)*70)}px;" title="Виконано: ${done}"></div>
                    </div>
                    <div style="font-size:0.65rem;color:${isToday ? '#22c55e' : '#9ca3af'};font-weight:${isToday ? '700' : '400'};">${label}</div>
                    <div style="font-size:0.7rem;color:${isToday ? '#22c55e' : '#6b7280'};font-weight:${isToday ? '700' : '500'};">${dateNum}</div>
                </div>`;
            }).join('');
            
            return `<div style="background:white;border-radius:12px;padding:1rem;border:1px solid #e5e7eb;">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.75rem;">
                    <h4 style="margin:0;font-size:0.9rem;">Активність за тиждень</h4>
                    <div style="display:flex;gap:1rem;font-size:0.7rem;">
                        <span style="display:flex;align-items:center;gap:4px;"><span style="width:10px;height:10px;background:#dbeafe;border-radius:2px;"></span> Створено</span>
                        <span style="display:flex;align-items:center;gap:4px;"><span style="width:10px;height:10px;background:#22c55e;border-radius:2px;"></span> Виконано</span>
                    </div>
                </div>
                <div style="display:flex;gap:4px;align-items:flex-end;">${bars}</div>
            </div>`;
        }
        
        function renderStatusCard(byStatus, overdueCount) {
            return `<div style="background:#f8f9fa;border-radius:12px;padding:1rem;">
                <h4 style="margin-bottom:0.75rem;">${t('byStatus')}</h4>
                <div style="display:flex;flex-direction:column;gap:0.4rem;">
                    <div style="display:flex;justify-content:space-between;"><span><i data-lucide="plus-square" class="icon icon-sm" style="color:#3498db"></i> ${t('statusNew')}</span><strong>${byStatus.new}</strong></div>
                    <div style="display:flex;justify-content:space-between;"><span><i data-lucide="loader" class="icon icon-sm" style="color:#f39c12"></i> ${t('statusProgress')}</span><strong>${byStatus.progress}</strong></div>
                    <div style="display:flex;justify-content:space-between;"><span><i data-lucide="eye" class="icon icon-sm" style="color:#9b59b6"></i> ${t('statusReview')}</span><strong>${byStatus.review}</strong></div>
                    <div style="display:flex;justify-content:space-between;"><span><i data-lucide="check-circle" class="icon icon-sm" style="color:#27ae60"></i> ${t('statusDone')}</span><strong style="color:#27ae60;">${byStatus.done}</strong></div>
                    <div style="display:flex;justify-content:space-between;border-top:1px solid #ddd;padding-top:0.4rem;margin-top:0.25rem;"><span><i data-lucide="alert-triangle" class="icon icon-sm" style="color:#e74c3c"></i> ${t('overdue')}</span><strong style="color:#e74c3c;">${overdueCount}</strong></div>
                </div>
            </div>`;
        }
        
        function renderTopPerformers(visibleTasks) {
            const byAssignee = {};
            visibleTasks.filter(task => task.status === 'done').forEach(task => {
                const name = task.assigneeName || 'Не призначено';
                byAssignee[name] = (byAssignee[name] || 0) + 1;
            });
            const topAssignees = Object.entries(byAssignee).sort((a, b) => b[1] - a[1]).slice(0, 5);
            const maxDone = topAssignees[0]?.[1] || 1;
            
            return `<div style="background:#f8f9fa;border-radius:12px;padding:1rem;">
                <h4 style="margin-bottom:0.75rem;"><i data-lucide="trophy" class="icon icon-sm" style="color:#f39c12"></i> ${t('topPerformers')}</h4>
                ${topAssignees.length > 0 ? topAssignees.map(([name, count], i) => `
                    <div style="margin-bottom:0.5rem;">
                        <div style="display:flex;justify-content:space-between;font-size:0.8rem;margin-bottom:2px;">
                            <span>${i === 0 ? '<i data-lucide="medal" class="icon icon-sm" style="color:#ffd700"></i> ' : ''}${name}</span>
                            <strong style="color:#27ae60;">${count}</strong>
                        </div>
                        <div style="height:4px;background:#e5e7eb;border-radius:99px;"><div style="height:100%;width:${(count/maxDone)*100}%;background:#22c55e;border-radius:99px;"></div></div>
                    </div>
                `).join('') : `<p style="color:#7f8c8d;">${t('noCompletedTasks')}</p>`}
            </div>`;
        }
        
        function renderOverdueDetails(overdueTasks) {
            if (overdueTasks.length === 0) return '';
            
            const byPerson = {};
            overdueTasks.forEach(t => {
                const name = t.assigneeName || 'Не призначено';
                if (!byPerson[name]) byPerson[name] = [];
                byPerson[name].push(t);
            });
            
            return `<div style="background:#fef2f2;border-radius:12px;padding:1rem;border:1px solid #fecaca;">
                <h4 style="margin-bottom:0.75rem;color:#dc2626;"><i data-lucide="alert-triangle" class="icon icon-sm"></i> Прострочено (${overdueTasks.length})</h4>
                ${Object.entries(byPerson).map(([name, tasks]) => `
                    <div style="margin-bottom:0.5rem;">
                        <div style="font-size:0.8rem;font-weight:600;color:#991b1b;">${esc(name)} (${tasks.length})</div>
                        ${tasks.slice(0, 3).map(t => `
                            <div style="font-size:0.75rem;color:#7f1d1d;padding:2px 0 2px 12px;cursor:pointer;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;" onclick="openTaskModal('${escId(t.id)}')" title="${esc(t.title)}">
                                ${esc(t.title)} <span style="color:#dc2626;font-size:0.65rem;">${t.deadlineDate || ''}</span>
                            </div>
                        `).join('')}
                        ${tasks.length > 3 ? `<div style="font-size:0.7rem;color:#dc2626;padding-left:12px;">+${tasks.length - 3} ще...</div>` : ''}
                    </div>
                `).join('')}
            </div>`;
        }
        
        function renderStuckProcesses() {
            if (!processes || processes.length === 0) return '';
            
            const todayStr = getLocalDateStr();
            const stuck = processes.filter(p => {
                if (p.status !== 'active') return false;
                if (p.deadline && p.deadline < todayStr) return true;
                // Більше 3 днів на одному кроці
                const lastHistory = p.history?.[p.history.length - 1];
                if (lastHistory?.timestamp) {
                    const ts = lastHistory.timestamp.toDate ? lastHistory.timestamp.toDate() : new Date(lastHistory.timestamp);
                    const daysSince = (new Date() - ts) / 86400000;
                    return daysSince > 3;
                }
                return false;
            });
            
            if (stuck.length === 0) return '';
            
            return `<div style="background:#fffbeb;border-radius:12px;padding:1rem;border:1px solid #fde68a;">
                <h4 style="margin-bottom:0.75rem;color:#92400e;"><i data-lucide="pause-circle" class="icon icon-sm"></i> Застряглі процеси (${stuck.length})</h4>
                ${stuck.slice(0, 5).map(p => {
                    const template = processTemplates.find(t => t.id === p.templateId);
                    const totalSteps = template?.steps?.length || '?';
                    const stepName = template?.steps?.[p.currentStep]?.title || template?.steps?.[p.currentStep]?.function || '';
                    return `<div style="font-size:0.8rem;padding:4px 0;border-bottom:1px solid #fef3c7;">
                        <div style="font-weight:600;color:#78350f;">${esc(p.name)}</div>
                        <div style="font-size:0.7rem;color:#92400e;">Крок ${(p.currentStep||0)+1}/${totalSteps}: ${esc(stepName)}${p.deadline ? ' — дедлайн: ' + p.deadline : ''}</div>
                    </div>`;
                }).join('')}
            </div>`;
        }
        
        function renderFunctionLoad(visibleTasks) {
            const byFunc = {};
            visibleTasks.filter(t => t.function && t.status !== 'done').forEach(t => {
                if (!byFunc[t.function]) byFunc[t.function] = { active: 0, overdue: 0 };
                byFunc[t.function].active++;
                const taskDate = parseDeadline(t).date;
                const todayStr = getLocalDateStr();
                if (taskDate && taskDate < todayStr) byFunc[t.function].overdue++;
            });
            
            const entries = Object.entries(byFunc).sort((a, b) => b[1].active - a[1].active).slice(0, 6);
            if (entries.length === 0) return '';
            const maxActive = entries[0]?.[1]?.active || 1;
            
            return `<div style="background:#f8f9fa;border-radius:12px;padding:1rem;">
                <h4 style="margin-bottom:0.75rem;"><i data-lucide="layers" class="icon icon-sm" style="color:#6366f1"></i> Навантаження по функціях</h4>
                ${entries.map(([name, data]) => `
                    <div style="margin-bottom:0.5rem;">
                        <div style="display:flex;justify-content:space-between;font-size:0.8rem;margin-bottom:2px;">
                            <span>${esc(name)}</span>
                            <span>${data.active}${data.overdue ? ` <span style="color:#ef4444;font-size:0.7rem;">(${data.overdue} простр.)</span>` : ''}</span>
                        </div>
                        <div style="height:4px;background:#e5e7eb;border-radius:99px;position:relative;">
                            <div style="height:100%;width:${(data.active/maxActive)*100}%;background:#6366f1;border-radius:99px;"></div>
                            ${data.overdue ? `<div style="position:absolute;top:0;right:0;height:100%;width:${(data.overdue/maxActive)*100}%;background:#ef4444;border-radius:99px;"></div>` : ''}
                        </div>
                    </div>
                `).join('')}
            </div>`;
        }

        function closeModal(id) {
            const el = document.getElementById(id);
            if (el) el.style.display = 'none';
            editingId = null;
            editingUserId = null;
            checkModalState();
        }
        
        function checkModalState() {
            const anyOpen = Array.from(document.querySelectorAll('.modal')).some(m => m.style.display === 'block');
            if (anyOpen) {
                document.body.style.overflow = 'hidden';
                if (window.innerWidth < 768) {
                    const bn = document.getElementById('bottomNav');
                    if (bn) bn.style.display = 'none';
                    const fab = document.getElementById('fabAdd');
                    if (fab) fab.style.display = 'none';
                }
            } else {
                document.body.style.overflow = '';
                if (window.innerWidth < 768) {
                    const bn = document.getElementById('bottomNav');
                    if (bn) bn.style.display = '';
                    const fab = document.getElementById('fabAdd');
                    if (fab) fab.style.display = '';
                }
            }
        }
        
        // Overdue badge
        function updateOverdueBadge() {
            const badge = document.getElementById('overdueNavBadge');
            if (!badge) return;
            const today = getLocalDateStr();
            const overdue = tasks.filter(t => {
                if (!isTaskVisibleToUser(t)) return false;
                if (t.status === 'done') return false;
                const d = parseDeadline(t).date;
                return d && d < today;
            }).length;
            if (overdue > 0) {
                badge.textContent = overdue > 99 ? '99+' : overdue;
                badge.style.display = 'flex';
            } else {
                badge.style.display = 'none';
            }
        }
        
        // Auto body-lock: спостерігаємо за зміною display на модалках
        const _modalObserver = new MutationObserver(() => checkModalState());
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('.modal').forEach(m => {
                _modalObserver.observe(m, { attributes: true, attributeFilter: ['style'] });
            });
        });

        window.onclick = function(e) {
            // Форми з даними НЕ закриваються по кліку на overlay — тільки хрестиком
            ['functionModal', 'inviteModal', 'userModal', 'profileModal', 'processTemplatesModal', 'viewProcessModal', 'mergeFunctionsModal'].forEach(id => {
                if (e.target === document.getElementById(id)) closeModal(id);
            });
        }

        // Init language on load
        // SVG Icon helper
        function icon(name, size = '') {
            const sizeClass = size ? ` icon-${size}` : '';
            return `<i data-lucide="${name}" class="icon${sizeClass}"></i>`;
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            setLanguage(currentLang);
            // Ініціалізуємо Lucide іконки
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        });
        
        // Переініціалізація іконок після динамічного контенту
        // Debounced refreshIcons — замість 40+ повних DOM-парсингів за секунду
        let _refreshIconsTimer = null;
        function refreshIcons() {
            if (_refreshIconsTimer) return;
            _refreshIconsTimer = requestAnimationFrame(() => {
                _refreshIconsTimer = null;
                if (typeof lucide !== 'undefined') {
                    lucide.createIcons();
                }
            });
        }
        
        // Примусовий refresh (для модалок які потребують іконок зразу)
        function refreshIconsNow() {
            if (_refreshIconsTimer) {
                clearTimeout(_refreshIconsTimer);
                _refreshIconsTimer = null;
            }
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }
        
        // =====================
        // SWIPE TO COMPLETE (Event Delegation)
        // =====================
        let swipeState = {
            startX: 0,
            currentX: 0,
            isDragging: false,
            activeCard: null
        };
        
        function initSwipeHandlers() {
            // Event delegation - one listener for all cards
            const container = document.getElementById('mobileTasksList');
            if (!container || container.dataset.swipeInit) return;
            
            container.dataset.swipeInit = 'true';
            
            container.addEventListener('touchstart', (e) => {
                const card = e.target.closest('.mobile-task-card');
                if (!card) return;
                
                swipeState.startX = e.touches[0].clientX;
                swipeState.isDragging = true;
                swipeState.activeCard = card;
                swipeState.currentX = 0;
                card.classList.add('swiping');
            }, { passive: true });
            
            container.addEventListener('touchmove', (e) => {
                if (!swipeState.isDragging || !swipeState.activeCard) return;
                
                const card = swipeState.activeCard;
                const content = card.querySelector('.mobile-task-content');
                const leftBg = card.querySelector('.swipe-action-bg.left');
                const rightBg = card.querySelector('.swipe-action-bg.right');
                const canComplete = card.dataset.canComplete === 'true';
                
                if (!content) return;
                
                swipeState.currentX = e.touches[0].clientX - swipeState.startX;
                
                // Limit swipe distance
                const maxSwipe = 120;
                swipeState.currentX = Math.max(-maxSwipe, Math.min(maxSwipe, swipeState.currentX));
                
                // Apply transform
                content.style.transform = `translateX(${swipeState.currentX}px)`;
                
                // Show appropriate background
                if (swipeState.currentX > 30 && canComplete) {
                    leftBg?.classList.add('visible');
                    rightBg?.classList.remove('visible');
                } else if (swipeState.currentX < -30) {
                    rightBg?.classList.add('visible');
                    leftBg?.classList.remove('visible');
                } else {
                    leftBg?.classList.remove('visible');
                    rightBg?.classList.remove('visible');
                }
            }, { passive: true });
            
            container.addEventListener('touchend', () => {
                if (!swipeState.isDragging || !swipeState.activeCard) return;
                
                const card = swipeState.activeCard;
                const content = card.querySelector('.mobile-task-content');
                const leftBg = card.querySelector('.swipe-action-bg.left');
                const rightBg = card.querySelector('.swipe-action-bg.right');
                const canComplete = card.dataset.canComplete === 'true';
                const taskId = card.dataset.taskId;
                
                const didSwipe = Math.abs(swipeState.currentX) > 10;
                
                swipeState.isDragging = false;
                card.classList.remove('swiping');
                
                const threshold = 80;
                
                // Complete task (swipe right)
                if (swipeState.currentX > threshold && canComplete) {
                    content.style.transform = `translateX(100%)`;
                    content.style.opacity = '0';
                    setTimeout(() => {
                        quickCompleteTask(taskId);
                    }, 200);
                    swipeState.activeCard = null;
                    return;
                }
                
                // Delete task (swipe left) — підвищений поріг для захисту
                if (swipeState.currentX < -(threshold + 30)) {
                    // Haptic warning before delete
                    if (navigator.vibrate) navigator.vibrate([30, 50, 30]);
                    content.style.transform = `translateX(-100%)`;
                    content.style.opacity = '0';
                    setTimeout(() => { deleteTask(taskId); }, 250);
                    swipeState.activeCard = null;
                    return;
                }
                
                // Reset position
                if (content) content.style.transform = '';
                leftBg?.classList.remove('visible');
                rightBg?.classList.remove('visible');
                
                // Блокуємо click якщо був swipe (щоб не відкрити модалку після свайпу)
                if (didSwipe && content) {
                    content.style.pointerEvents = 'none';
                    setTimeout(() => { content.style.pointerEvents = ''; }, 50);
                }
                swipeState.currentX = 0;
                swipeState.activeCard = null;
            });
        }
        
        // =====================
        // BROWSER NOTIFICATIONS
        // =====================
        let notificationsEnabled = localStorage.getItem('notificationsEnabled') === 'true';
        let notificationCheckInterval = null;
        let notifiedTasks = new Set(JSON.parse(localStorage.getItem('notifiedTasks') || '[]'));
        
        // Check if browser supports notifications
        function supportsNotifications() {
            return 'Notification' in window;
        }
        
        // Request permission
        async function requestNotificationPermission() {
            if (!supportsNotifications()) {
                alert(t('browserNoNotifications'));
                return false;
            }
            
            const permission = await Notification.requestPermission();
            
            if (permission === 'granted') {
                notificationsEnabled = true;
                localStorage.setItem('notificationsEnabled', 'true');
                startNotificationChecker();
                updateNotificationButton();
                
                // Show test notification
                new Notification('Сповіщення увімкнено', {
                    body: 'Ви отримуватимете нагадування про дедлайни',
                    icon: 'https://cdn-icons-png.flaticon.com/512/2098/2098402.png',
                    tag: 'test'
                });
                
                return true;
            } else {
                alert(t('notificationsDenied'));
                return false;
            }
        }
        
        // Disable notifications
        function disableNotifications() {
            notificationsEnabled = false;
            localStorage.setItem('notificationsEnabled', 'false');
            stopNotificationChecker();
            updateNotificationButton();
        }
        
        // Toggle notifications
        async function toggleNotifications() {
            if (notificationsEnabled) {
                disableNotifications();
            } else {
                await requestNotificationPermission();
            }
        }
        
        // Check deadlines and send notifications
        function checkDeadlinesAndNotify() {
            if (!notificationsEnabled || !tasks.length) return;
            
            const now = new Date();
            const today = getLocalDateStr(now);
            const currentHour = now.getHours();
            const currentMinute = now.getMinutes();
            
            tasks.filter(t => isTaskVisibleToUser(t)).forEach(task => {
                if (task.status === 'done' || task.status === 'review') return;
                
                const { date: taskDeadline, time: taskTime } = parseDeadline(task);
                
                if (!taskDeadline) return;
                
                const notifyKey = `${task.id}-${taskDeadline}`;
                
                // Already notified for this deadline
                if (notifiedTasks.has(notifyKey)) return;
                
                // Check if deadline is today
                if (taskDeadline === today) {
                    let shouldNotify = false;
                    let message = '';
                    
                    if (taskTime) {
                        // Has specific time - notify 1 hour before
                        const [deadlineHour, deadlineMinute] = taskTime.split(':').map(Number);
                        const deadlineInMinutes = deadlineHour * 60 + deadlineMinute;
                        const nowInMinutes = currentHour * 60 + currentMinute;
                        const diff = deadlineInMinutes - nowInMinutes;
                        
                        if (diff > 0 && diff <= 60) {
                            shouldNotify = true;
                            message = `Дедлайн через ${diff} хв: ${task.title}`;
                        } else if (diff <= 0 && diff > -5) {
                            shouldNotify = true;
                            message = `Дедлайн зараз: ${task.title}`;
                        }
                    } else {
                        // No specific time - notify once in the morning (9:00)
                        if (currentHour === 9 && currentMinute < 5) {
                            shouldNotify = true;
                            message = `Сьогодні дедлайн: ${task.title}`;
                        }
                    }
                    
                    if (shouldNotify) {
                        sendTaskNotification(task, message, notifyKey);
                    }
                }
                
                // Check if deadline is tomorrow (notify at 18:00)
                const tomorrow = new Date(now);
                tomorrow.setDate(tomorrow.getDate() + 1);
                const tomorrowStr = getLocalDateStr(tomorrow);
                
                if (taskDeadline === tomorrowStr && currentHour === 18 && currentMinute < 5) {
                    const notifyKeyTomorrow = `${task.id}-tomorrow`;
                    if (!notifiedTasks.has(notifyKeyTomorrow)) {
                        sendTaskNotification(task, `Завтра дедлайн: ${task.title}`, notifyKeyTomorrow);
                    }
                }
                
                // Check overdue (notify once)
                if (taskDeadline < today) {
                    const notifyKeyOverdue = `${task.id}-overdue`;
                    if (!notifiedTasks.has(notifyKeyOverdue)) {
                        sendTaskNotification(task, `Прострочено: ${task.title}`, notifyKeyOverdue);
                    }
                }
            });
        }
        
        // Send notification
        function sendTaskNotification(task, message, notifyKey) {
            try {
                const notification = new Notification(message, {
                    body: task.function ? `Функція: ${task.function}` : 'Натисніть щоб відкрити',
                    icon: 'https://cdn-icons-png.flaticon.com/512/2098/2098402.png',
                    tag: task.id,
                    requireInteraction: true
                });
                
                notification.onclick = () => {
                    window.focus();
                    openTaskModal(task.id);
                    notification.close();
                };
                
                // Mark as notified
                notifiedTasks.add(notifyKey);
                localStorage.setItem('notifiedTasks', JSON.stringify([...notifiedTasks]));
                
            } catch (e) {
                console.error('Notification error:', e);
            }
        }
        
        // Start checking deadlines
        function startNotificationChecker() {
            if (notificationCheckInterval) return;
            
            // Check immediately
            checkDeadlinesAndNotify();
            
            // Then check every 1 minute
            notificationCheckInterval = setInterval(checkDeadlinesAndNotify, 60000);
        }
        
        // Stop checking
        function stopNotificationChecker() {
            if (notificationCheckInterval) {
                clearInterval(notificationCheckInterval);
                notificationCheckInterval = null;
            }
        }
        
        // Update button state
        function updateNotificationButton() {
            const btn = document.getElementById('notificationToggleBtn');
            if (!btn) return;
            
            if (notificationsEnabled) {
                btn.innerHTML = '<i data-lucide="bell-off" class="icon"></i> Вимкнути сповіщення';
                btn.classList.add('btn-warning');
                btn.classList.remove('btn-success');
            } else {
                btn.innerHTML = '<i data-lucide="bell" class="icon"></i> Увімкнути сповіщення';
                btn.classList.remove('btn-warning');
                btn.classList.add('btn-success');
            }
            refreshIcons();
        }
        
        // Clear old notifications daily
        function clearOldNotifications() {
            const today = getLocalDateStr();
            const lastClear = localStorage.getItem('lastNotificationClear');
            
            if (lastClear !== today) {
                // Keep only overdue notifications
                const filtered = [...notifiedTasks].filter(key => key.includes('-overdue'));
                notifiedTasks = new Set(filtered);
                localStorage.setItem('notifiedTasks', JSON.stringify(filtered));
                localStorage.setItem('lastNotificationClear', today);
            }
        }
        
        // Init notifications on load
        document.addEventListener('DOMContentLoaded', () => {
            clearOldNotifications();
            
            if (notificationsEnabled && Notification.permission === 'granted') {
                startNotificationChecker();
            } else if (notificationsEnabled) {
                // Permission was revoked
                notificationsEnabled = false;
                localStorage.setItem('notificationsEnabled', 'false');
            }
            
            updateNotificationButton();
            
            // Init FAB for tasks tab
            updateFab('tasks');
        });

    // ====== MERGED FROM SCRIPT 2 ======
        // Mobile menu functions
        function openMobileMenu() {
            document.getElementById('mobileMenuModal').style.display = 'flex';
            refreshIcons();
        }
        
        function closeMobileMenu() {
            document.getElementById('mobileMenuModal').style.display = 'none';
        }
        
        // =====================
        // GOOGLE CALENDAR INTEGRATION
        // =====================
        
        function initGoogleCalendar() {
            // Initialize token client for Google Identity Services
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: GOOGLE_CLIENT_ID,
                scope: GOOGLE_SCOPES,
                callback: handleGoogleAuthResponse,
            });
            
            // Check if user already has calendar connected
            checkGoogleCalendarStatus();
        }
        
        function checkGoogleCalendarStatus() {
            if (!currentUser || !currentCompany) return;
            
            db.collection('companies').doc(currentCompany)
                .collection('users').doc(currentUser.uid)
                .get()
                .then(doc => {
                    if (doc.exists) {
                        const data = doc.data();
                        if (data.googleCalendarConnected && data.googleCalendarEmail) {
                            showCalendarConnected(data.googleCalendarEmail);
                            googleAccessToken = data.googleAccessToken || null;
                        } else {
                            showCalendarNotConnected();
                        }
                    }
                })
                .catch(err => console.error('Error checking calendar status:', err));
        }
        
        function showCalendarConnected(email) {
            const connected = document.getElementById('gcalConnected');
            const notConnected = document.getElementById('gcalNotConnected');
            const emailEl = document.getElementById('gcalEmail');
            
            if (connected) connected.style.display = 'block';
            if (notConnected) notConnected.style.display = 'none';
            if (emailEl) emailEl.textContent = 'Підключено: ' + email;
        }
        
        function showCalendarNotConnected() {
            const connected = document.getElementById('gcalConnected');
            const notConnected = document.getElementById('gcalNotConnected');
            
            if (connected) connected.style.display = 'none';
            if (notConnected) notConnected.style.display = 'block';
        }
        
        function connectGoogleCalendar() {
            if (!tokenClient) {
                alert(t('googleApiNotLoaded'));
                return;
            }
            
            // Request access token
            tokenClient.requestAccessToken({ prompt: 'consent' });
        }
        
        function handleGoogleAuthResponse(response) {
            if (response.error) {
                console.error('Google auth error:', response);
                alert(t('googleAuthError') + ': ' + response.error);
                return;
            }
            
            googleAccessToken = response.access_token;
            
            // Get user email from Google
            fetch('https://www.googleapis.com/oauth2/v2/userinfo', {
                headers: { 'Authorization': 'Bearer ' + googleAccessToken }
            })
            .then(res => {
                if (!res.ok) {
                    throw new Error('Failed to get user info: ' + res.status);
                }
                return res.json();
            })
            .then(userInfo => {
                const email = userInfo.email || currentUser.email || 'Підключено';
                
                // Save to Firestore using set with merge
                return db.collection('companies').doc(currentCompany)
                    .collection('users').doc(currentUser.uid)
                    .set({
                        googleCalendarConnected: true,
                        googleCalendarEmail: email,
                        googleAccessToken: googleAccessToken,
                        googleCalendarUpdatedAt: firebase.firestore.FieldValue.serverTimestamp()
                    }, { merge: true })
                    .then(() => {
                        showCalendarConnected(email);
                        alert(t('googleCalendarConnected'));
                    });
            })
            .catch(err => {
                console.error('Error saving calendar connection:', err);
                // Try to save without email
                db.collection('companies').doc(currentCompany)
                    .collection('users').doc(currentUser.uid)
                    .set({
                        googleCalendarConnected: true,
                        googleCalendarEmail: currentUser.email || 'Підключено',
                        googleAccessToken: googleAccessToken,
                        googleCalendarUpdatedAt: firebase.firestore.FieldValue.serverTimestamp()
                    }, { merge: true })
                    .then(() => {
                        showCalendarConnected(currentUser.email || 'Підключено');
                        alert(t('googleCalendarConnected'));
                    })
                    .catch(err2 => {
                        alert(t('saveError') + ': ' + err2.message);
                    });
            });
        }
        
        function disconnectGoogleCalendar() {
            if (!confirm(t('disconnectGoogleCalendar'))) {
                return;
            }
            
            // Revoke token if exists
            if (googleAccessToken) {
                google.accounts.oauth2.revoke(googleAccessToken, () => {
                    // Token revoked
                });
            }
            
            // Update Firestore
            db.collection('companies').doc(currentCompany)
                .collection('users').doc(currentUser.uid)
                .set({
                    googleCalendarConnected: false,
                    googleCalendarEmail: firebase.firestore.FieldValue.delete(),
                    googleAccessToken: firebase.firestore.FieldValue.delete()
                }, { merge: true })
                .then(() => {
                    googleAccessToken = null;
                    showCalendarNotConnected();
                    alert(t('googleCalendarDisconnected'));
                })
                .catch(err => {
                    console.error('Error disconnecting calendar:', err);
                    alert(t('error') + ': ' + err.message);
                });
        }
        
        // =====================
        // TELEGRAM INTEGRATION
        // =====================
        const TELEGRAM_BOT_USERNAME = 'talko_tasks_bot';
        
        function generateTelegramCode() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let code = '';
            for (let i = 0; i < 8; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }
        
        async function connectTelegram() {
            if (!currentCompany || !currentUser) {
                alert(t('notAuthorized'));
                return;
            }
            
            // Генеруємо унікальний код
            const telegramCode = generateTelegramCode();
            
            // Зберігаємо код в профілі користувача
            try {
                await db.collection('companies').doc(currentCompany)
                    .collection('users').doc(currentUser.uid)
                    .set({ telegramCode: telegramCode }, { merge: true });
                
                // Відкриваємо Telegram бота з кодом
                const botUrl = `https://t.me/${TELEGRAM_BOT_USERNAME}?start=${telegramCode}`;
                
                // Показуємо інструкцію
                const proceed = confirm(
                    'Підключення Telegram\n\n' +
                    '1. Зараз відкриється Telegram бот\n' +
                    '2. Натисніть "Start" або "Запустити"\n' +
                    '3. Бот автоматично підключить сповіщення\n\n' +
                    'Відкрити Telegram?'
                );
                
                if (proceed) {
                    window.open(botUrl, '_blank');
                    
                    // Через 3 секунди перевіряємо статус
                    setTimeout(() => {
                        checkTelegramStatus();
                    }, 5000);
                }
            } catch (error) {
                console.error('Error generating Telegram code:', error);
                alert(t('error') + ': ' + error.message);
            }
        }
        
        async function disconnectTelegram() {
            if (!confirm(t('disconnectTelegram'))) {
                return;
            }
            
            try {
                await db.collection('companies').doc(currentCompany)
                    .collection('users').doc(currentUser.uid)
                    .set({
                        telegramChatId: firebase.firestore.FieldValue.delete(),
                        telegramUserId: firebase.firestore.FieldValue.delete(),
                        telegramCode: firebase.firestore.FieldValue.delete()
                    }, { merge: true });
                
                showTelegramNotConnected();
                alert(t('telegramDisconnected'));
            } catch (error) {
                console.error('Error disconnecting Telegram:', error);
                alert(t('error') + ': ' + error.message);
            }
        }
        
        async function checkTelegramStatus() {
            if (!currentCompany || !currentUser) return;
            
            try {
                const userDoc = await db.collection('companies').doc(currentCompany)
                    .collection('users').doc(currentUser.uid).get();
                
                if (userDoc.exists && userDoc.data().telegramChatId) {
                    showTelegramConnected();
                } else {
                    showTelegramNotConnected();
                }
            } catch (error) {
                console.error('Error checking Telegram status:', error);
            }
        }
        
        function showTelegramConnected() {
            const notConnected = document.getElementById('telegramNotConnected');
            const connected = document.getElementById('telegramConnected');
            if (notConnected) notConnected.style.display = 'none';
            if (connected) connected.style.display = 'block';
        }
        
        function showTelegramNotConnected() {
            const notConnected = document.getElementById('telegramNotConnected');
            const connected = document.getElementById('telegramConnected');
            if (notConnected) notConnected.style.display = 'block';
            if (connected) connected.style.display = 'none';
        }
        
        // Create event in Google Calendar
        async function createCalendarEvent(task) {
            if (!googleAccessToken) {
                console.log('No Google Calendar token, skipping sync');
                return null;
            }
            
            const startDateTime = new Date(task.deadlineDate + 'T' + (task.deadlineTime || '09:00'));
            const durationMinutes = parseInt(task.estimatedTime) || 60;
            const endDateTime = new Date(startDateTime.getTime() + durationMinutes * 60000);
            
            const event = {
                summary: task.title,
                description: task.description || task.expectedResult || '',
                start: {
                    dateTime: startDateTime.toISOString(),
                    timeZone: 'Europe/Kyiv'
                },
                end: {
                    dateTime: endDateTime.toISOString(),
                    timeZone: 'Europe/Kyiv'
                },
                reminders: {
                    useDefault: false,
                    overrides: [
                        { method: 'popup', minutes: 60 },
                        { method: 'popup', minutes: 15 }
                    ]
                }
            };
            
            try {
                const response = await fetch('https://www.googleapis.com/calendar/v3/calendars/primary/events', {
                    method: 'POST',
                    headers: {
                        'Authorization': 'Bearer ' + googleAccessToken,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(event)
                });
                
                if (response.status === 401) {
                    // Token expired, need to reconnect
                    console.log('Google token expired');
                    googleAccessToken = null;
                    return null;
                }
                
                if (!response.ok) {
                    throw new Error('Failed to create event: ' + response.status);
                }
                
                const result = await response.json();
                console.log('Calendar event created:', result.id);
                return result.id;
            } catch (err) {
                console.error('Error creating calendar event:', err);
                return null;
            }
        }
        
        // Update event in Google Calendar
        async function updateCalendarEvent(eventId, task) {
            if (!googleAccessToken || !eventId) {
                return false;
            }
            
            const startDateTime = new Date(task.deadlineDate + 'T' + (task.deadlineTime || '09:00'));
            const durationMinutes = parseInt(task.estimatedTime) || 60;
            const endDateTime = new Date(startDateTime.getTime() + durationMinutes * 60000);
            
            const event = {
                summary: task.title,
                description: task.description || task.expectedResult || '',
                start: {
                    dateTime: startDateTime.toISOString(),
                    timeZone: 'Europe/Kyiv'
                },
                end: {
                    dateTime: endDateTime.toISOString(),
                    timeZone: 'Europe/Kyiv'
                }
            };
            
            try {
                const response = await fetch(`https://www.googleapis.com/calendar/v3/calendars/primary/events/${eventId}`, {
                    method: 'PATCH',
                    headers: {
                        'Authorization': 'Bearer ' + googleAccessToken,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(event)
                });
                
                if (!response.ok) {
                    throw new Error('Failed to update event');
                }
                
                console.log('Calendar event updated:', eventId);
                return true;
            } catch (err) {
                console.error('Error updating calendar event:', err);
                return false;
            }
        }
        
        // Delete event from Google Calendar
        async function deleteCalendarEvent(eventId) {
            if (!googleAccessToken || !eventId) {
                return false;
            }
            
            try {
                const response = await fetch(`https://www.googleapis.com/calendar/v3/calendars/primary/events/${eventId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': 'Bearer ' + googleAccessToken
                    }
                });
                
                // 204 = success, 404/410 = already deleted (ok)
                if (response.ok || response.status === 404 || response.status === 410) {
                    console.log('Calendar event deleted:', eventId);
                    return true;
                }
                
                console.warn('Calendar delete response:', response.status);
                return false;
            } catch (err) {
                console.error('Error deleting calendar event:', err);
                return false;
            }
        }
        
        // Profile Modal
        function openProfileModal() {
            const modal = document.getElementById('profileModal');
            if (!modal) return;
            
            // Fill profile data
            const nameEl = document.getElementById('profileName');
            const emailEl = document.getElementById('profileEmail');
            const roleEl = document.getElementById('profileRole');
            const avatarEl = document.getElementById('profileAvatar');
            
            if (currentUserData) {
                const name = currentUserData.name || currentUser?.displayName || 'Користувач';
                if (nameEl) nameEl.textContent = name;
                if (emailEl) emailEl.textContent = currentUser?.email || '';
                if (roleEl) roleEl.textContent = getRoleText(currentUserData.role);
                if (avatarEl) avatarEl.textContent = name.charAt(0).toUpperCase();
            }
            
            // Check calendar status
            checkGoogleCalendarStatus();
            
            // Check Telegram status
            checkTelegramStatus();
            
            modal.style.display = 'flex';
            refreshIcons();
        }
        
        // =====================
        // CALENDAR QUICK ACTIONS
        // =====================
        
        // Open task form with pre-filled date and time
        function openTaskAtTime(dateStr, hour) {
            editingId = null;
            document.getElementById('taskModalTitle').textContent = t('addTask');
            document.getElementById('taskForm').reset();
            
            // Pre-fill date and time
            document.getElementById('taskDeadlineDate').value = dateStr;
            document.getElementById('taskDeadlineTime').value = hour.toString().padStart(2, '0') + ':00';
            document.getElementById('taskStatus').value = 'new';
            
            // Reset assignee and function
            document.getElementById('taskAssignee').value = '';
            document.getElementById('taskFunction').value = '';
            
            document.getElementById('taskModal').style.display = 'flex';
            refreshIcons();
        }
        
        // Quick menu for task actions
        let activeQuickMenu = null;
        let activeOverlay = null;
        
        function showTaskQuickMenu(event, taskId) {
            event.stopPropagation();
            
            // Close existing menu
            closeTaskQuickMenu();
            
            const task = tasks.find(t => t.id === taskId);
            if (!task) return;
            
            const isMobile = window.innerWidth <= 767;
            
            // Get deadline info
            const deadline = task.deadline?.toDate ? task.deadline.toDate() : new Date(task.deadline);
            const deadlineStr = deadline.toLocaleDateString('uk-UA', { day: 'numeric', month: 'short', hour: '2-digit', minute: '2-digit' });
            const assignee = task.assigneeName || 'Не призначено';
            const funcName = task.function || '';
            
            // Status colors
            const statusColors = {
                'new': '#3b82f6',
                'progress': '#f59e0b', 
                'review': '#8b5cf6',
                'done': '#10b981'
            };
            const statusColor = statusColors[task.status] || '#6b7280';
            
            // Create overlay for mobile
            if (isMobile) {
                const overlay = document.createElement('div');
                overlay.className = 'task-bottom-sheet-overlay';
                overlay.onclick = closeTaskQuickMenu;
                document.body.appendChild(overlay);
                activeOverlay = overlay;
            }
            
            // Create menu
            const menu = document.createElement('div');
            menu.className = 'task-quick-menu';
            menu.id = 'taskQuickMenu';
            menu.innerHTML = `
                <div class="task-quick-menu-header">
                    <div style="display:flex;align-items:center;gap:8px;">
                        <div style="width:12px;height:12px;border-radius:50%;background:${statusColor};flex-shrink:0;"></div>
                        <span style="flex:1;overflow:hidden;text-overflow:ellipsis;">${esc(task.title)}</span>
                    </div>
                    ${isMobile ? `<div style="font-size:0.85rem;color:#888;margin-top:6px;font-weight:400;">
                        ${deadlineStr}${funcName ? ' • ' + esc(funcName) : ''}
                    </div>` : ''}
                </div>
                <div class="task-quick-menu-item" onclick="openTaskModal('${taskId}');closeTaskQuickMenu();">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
                    ${t('viewBtn')}
                </div>
                ${(currentUserData?.role !== 'employee' || task.assigneeId === currentUser?.uid || task.creatorId === currentUser?.uid) ? `
                <div class="task-quick-menu-item" onclick="openTaskModal('${taskId}');closeTaskQuickMenu();">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>
                    ${t('editBtn')}
                </div>
                ` : ''}
                ${task.status === 'review' && task.creatorId === currentUser?.uid && task.assigneeId !== currentUser?.uid ? `
                <div class="task-quick-menu-item complete" onclick="acceptReviewTask('${taskId}');closeTaskQuickMenu();">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg>
                    ${t('acceptTask')}
                </div>
                <div class="task-quick-menu-item" onclick="rejectReviewTask('${taskId}');closeTaskQuickMenu();" style="color:#f59e0b;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
                    ${t('rejectTask')}
                </div>
                ` : task.status !== 'done' && task.status !== 'review' ? `
                <div class="task-quick-menu-item complete" onclick="quickCompleteFromMenu('${taskId}')">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg>
                    ${t('completeTask')}
                </div>
                ` : task.status === 'done' ? `
                <div class="task-quick-menu-item" onclick="reopenTaskFromMenu('${taskId}')">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
                    ${t('reopen')}
                </div>
                ` : task.status === 'review' ? `
                <div class="task-quick-menu-item" style="color:#8b5cf6;cursor:default;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
                    ${t('reviewByCreator')}
                </div>
                ` : ''}
                <div class="task-quick-menu-item delete" onclick="deleteTaskFromMenu('${taskId}')">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
                    ${t('delete')}
                </div>
            `;
            
            // Position menu (only for desktop)
            if (!isMobile) {
                const rect = event.target.closest('.calendar-event, .calendar-allday-event').getBoundingClientRect();
                menu.style.position = 'fixed';
                menu.style.left = Math.min(rect.left, window.innerWidth - 220) + 'px';
                menu.style.visibility = 'hidden';
                document.body.appendChild(menu);
                
                const menuH = menu.offsetHeight;
                const spaceBelow = window.innerHeight - rect.bottom - 10;
                const spaceAbove = rect.top - 10;
                
                if (spaceBelow >= menuH) {
                    // Show below
                    menu.style.top = (rect.bottom + 5) + 'px';
                } else if (spaceAbove >= menuH) {
                    // Show above
                    menu.style.top = (rect.top - menuH - 5) + 'px';
                } else {
                    // Not enough space either way — center vertically
                    menu.style.top = Math.max(10, (window.innerHeight - menuH) / 2) + 'px';
                }
                menu.style.visibility = 'visible';
            } else {
                document.body.appendChild(menu);
            }
            activeQuickMenu = menu;
            
            // Close on click outside (desktop only)
            if (!isMobile) {
                setTimeout(() => {
                    document.addEventListener('click', closeTaskQuickMenu);
                }, 10);
            }
        }
        
        function closeTaskQuickMenu() {
            if (activeOverlay) {
                activeOverlay.remove();
                activeOverlay = null;
            }
            if (activeQuickMenu) {
                activeQuickMenu.remove();
                activeQuickMenu = null;
            }
            document.removeEventListener('click', closeTaskQuickMenu);
        }
        
        async function quickCompleteFromMenu(taskId) {
            closeTaskQuickMenu();
            quickCompleteTask(taskId);
        }
        
        async function reopenTaskFromMenu(taskId) {
            closeTaskQuickMenu();
            reopenTask(taskId);
        }
        
        async function deleteTaskFromMenu(taskId) {
            closeTaskQuickMenu();
            // Unified: use deleteTask which has optimistic UI + undo toast
            deleteTask(taskId);
        }
        
        // Drag and drop
        let draggedTaskId = null;
        
        function onTaskDragStart(event, taskId) {
            draggedTaskId = taskId;
            event.dataTransfer.effectAllowed = 'move';
            event.target.style.opacity = '0.5';
        }
        
        function onTaskDragEnd(event) {
            event.target.style.opacity = '1';
            draggedTaskId = null;
        }
        
        function onHourDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
            event.target.classList.add('drag-over');
        }
        
        function onHourDragLeave(event) {
            event.target.classList.remove('drag-over');
        }
        
        async function onHourDrop(event, dateStr, hour) {
            event.preventDefault();
            event.target.classList.remove('drag-over');
            
            if (!draggedTaskId) return;
            
            const task = tasks.find(t => t.id === draggedTaskId);
            if (!task) return;
            
            // Get minutes from original time if available
            const oldDeadline = task.deadline?.toDate ? task.deadline.toDate() : new Date(task.deadline);
            const minutes = oldDeadline ? oldDeadline.getMinutes() : 0;
            
            const newTime = hour.toString().padStart(2, '0') + ':' + minutes.toString().padStart(2, '0');
            const newDeadline = dateStr + 'T' + newTime;
            
            // Update task
            await db.collection('companies').doc(currentCompany).collection('tasks').doc(draggedTaskId).update({
                deadlineDate: dateStr,
                deadlineTime: newTime,
                deadline: newDeadline,
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            // AUDIT LOG — deadline change via drag
            const dragTask = tasks.find(t => t.id === draggedTaskId);
            logTaskChange(draggedTaskId, 'deadline', { deadlineDate: dateStr, deadlineTime: newTime }, { deadlineDate: dragTask?.deadlineDate, deadlineTime: dragTask?.deadlineTime });
            
            // Update Google Calendar
            if (task.calendarEventId && googleAccessToken) {
                updateCalendarEvent(task.calendarEventId, { ...task, deadlineDate: dateStr, deadlineTime: newTime }).catch(err => 
                    console.warn('[Calendar] Update sync failed:', err)
                );
            }
            
            // Локальне оновлення
            task.deadlineDate = dateStr;
            task.deadlineTime = newTime;
            task.deadline = dateStr + 'T' + newTime;
            
            draggedTaskId = null;
            renderMyDay();
            refreshCurrentView();
        }

        // =====================
        // DEMO DATA
        // =====================
        
        function openDemoDataModal() {
            if (!isSuperAdmin) {
                showToast(t('superAdminOnly'), 'error');
                return;
            }
            document.getElementById('demoDataModal').style.display = 'flex';
            refreshIcons();
        }
        
        function closeDemoDataModal() {
            document.getElementById('demoDataModal').style.display = 'none';
        }
        
        async function clearAllCompanyData() {
            if (!isSuperAdmin) return;
            if (!currentCompany) return;
            
            const confirmText = 'ВИДАЛИТИ ВСЕ';
            const input = prompt(`Введіть "${confirmText}" щоб підтвердити повне видалення всіх даних компанії (крім користувачів):`);
            if (input !== confirmText) {
                if (input !== null) showToast(t('textMismatch'), 'error');
                return;
            }
            
            closeDemoDataModal();
            showToast(t('deletingData'), 'info');
            
            try {
                const companyRef = db.collection('companies').doc(currentCompany);
                const collections = ['tasks', 'regularTasks', 'functions', 'processTemplates', 'processes', 'projects', 'completedTasks', 'tasksArchive'];
                
                let totalDeleted = 0;
                for (const col of collections) {
                    const snap = await companyRef.collection(col).get();
                    if (snap.empty) continue;
                    
                    // Firestore batch max 500
                    const chunks = [];
                    let chunk = [];
                    snap.docs.forEach(doc => {
                        chunk.push(doc.ref);
                        if (chunk.length === 499) { chunks.push(chunk); chunk = []; }
                    });
                    if (chunk.length) chunks.push(chunk);
                    
                    for (const refs of chunks) {
                        const batch = db.batch();
                        refs.forEach(ref => batch.delete(ref));
                        await batch.commit();
                        totalDeleted += refs.length;
                    }
                }
                
                // Очистити локальні масиви
                tasks = []; regularTasks = []; functions = []; processes = []; processTemplates = []; projects = [];
                openProjectId = null;
                
                await loadAllData();
                showToast(t('deletedNRecords').replace('{n}', totalDeleted), 'success');
            } catch (e) {
                console.error('[ClearData]', e);
                showToast(t('deleteError') + ': ' + e.message, 'error');
            }
        }
        
        async function loadDemoData(type) {
            if (!currentCompany) {
                alert(t('createCompanyFirst'));
                closeDemoDataModal();
                return;
            }
            
            if (!confirm(t('loadDemoConfirm'))) {
                return;
            }
            
            closeDemoDataModal();
            
            try {
                if (type === 'clinic') {
                    await loadClinicDemoData();
                } else if (type === 'manufacturing') {
                    await loadManufacturingDemoData();
                }
                
                await loadAllData();
                alert(t('demoDataLoaded'));
            } catch (e) {
                console.error('Error loading demo data:', e);
                alert(t('loadError') + e.message);
            }
        }
        
        async function loadClinicDemoData() {
            const batch = db.batch();
            const companyRef = db.collection('companies').doc(currentCompany);
            
            // Demo users (if not exist)
            const demoUsers = [
                { name: 'Марія Коваленко', email: 'maria@demo.clinic', role: 'employee' },
                { name: 'Олег Петренко', email: 'oleg@demo.clinic', role: 'employee' },
                { name: 'Анна Шевченко', email: 'anna@demo.clinic', role: 'employee' }
            ];
            
            const userIds = [];
            for (const user of demoUsers) {
                const userRef = companyRef.collection('users').doc();
                batch.set(userRef, { ...user, createdAt: firebase.firestore.FieldValue.serverTimestamp() });
                userIds.push(userRef.id);
            }
            
            // Functions for clinic
            const clinicFunctions = [
                { name: 'Адміністрування', description: 'Запис пацієнтів, документообіг, організація роботи', assigneeIds: [userIds[0]] },
                { name: 'Лікування', description: 'Прийом пацієнтів, консультації, процедури', assigneeIds: [userIds[1]] },
                { name: 'Маркетинг', description: 'Залучення пацієнтів, реклама, соцмережі', assigneeIds: [userIds[0], userIds[2]] },
                { name: 'Закупівлі', description: 'Замовлення матеріалів, обладнання, розхідники', assigneeIds: [userIds[2]] },
                { name: 'Фінанси', description: 'Рахунки, звіти, бухгалтерія', assigneeIds: [userIds[0]] }
            ];
            
            const funcRefs = [];
            for (const func of clinicFunctions) {
                const funcRef = companyRef.collection('functions').doc();
                batch.set(funcRef, { ...func, createdAt: firebase.firestore.FieldValue.serverTimestamp() });
                funcRefs.push({ id: funcRef.id, ...func });
            }
            
            // Regular tasks for clinic
            const clinicRegularTasks = [
                { title: 'Обдзвін пацієнтів на завтра', function: 'Адміністрування', period: 'weekly', dayOfWeek: '1', time: '09:00', estimatedTime: '30', instruction: 'Зателефонувати всім пацієнтам, записаним на завтра. Підтвердити візит. Нагадати про підготовку якщо потрібно.' },
                { title: 'Обдзвін пацієнтів на завтра', function: 'Адміністрування', period: 'weekly', dayOfWeek: '2', time: '09:00', estimatedTime: '30', instruction: 'Зателефонувати всім пацієнтам, записаним на завтра.' },
                { title: 'Обдзвін пацієнтів на завтра', function: 'Адміністрування', period: 'weekly', dayOfWeek: '3', time: '09:00', estimatedTime: '30', instruction: 'Зателефонувати всім пацієнтам, записаним на завтра.' },
                { title: 'Обдзвін пацієнтів на завтра', function: 'Адміністрування', period: 'weekly', dayOfWeek: '4', time: '09:00', estimatedTime: '30', instruction: 'Зателефонувати всім пацієнтам, записаним на завтра.' },
                { title: 'Замовлення розхідних матеріалів', function: 'Закупівлі', period: 'weekly', dayOfWeek: '5', time: '14:00', estimatedTime: '60', instruction: 'Перевірити залишки матеріалів. Сформувати замовлення. Відправити постачальнику.' },
                { title: 'Публікація в соцмережах', function: 'Маркетинг', period: 'weekly', dayOfWeek: '1', time: '11:00', estimatedTime: '45', instruction: 'Підготувати та опублікувати контент в Instagram та Facebook.' },
                { title: 'Публікація в соцмережах', function: 'Маркетинг', period: 'weekly', dayOfWeek: '4', time: '11:00', estimatedTime: '45', instruction: 'Підготувати та опублікувати контент в Instagram та Facebook.' },
                { title: 'Фінансовий звіт за тиждень', function: 'Фінанси', period: 'weekly', dayOfWeek: '5', time: '17:00', estimatedTime: '60', instruction: 'Підготувати звіт по виручці, витратах, прибутку за тиждень.' },
                { title: 'Місячний звіт керівнику', function: 'Фінанси', period: 'monthly', dayOfMonth: 'last', time: '16:00', estimatedTime: '120', instruction: 'Підготувати повний місячний звіт: фінанси, пацієнти, маркетинг, проблеми.' },
                { title: 'Ревізія обладнання', function: 'Закупівлі', period: 'monthly', dayOfMonth: '15', time: '10:00', estimatedTime: '90', instruction: 'Перевірити стан обладнання, скласти список необхідного ремонту/заміни.' }
            ];
            
            for (const rt of clinicRegularTasks) {
                const rtRef = companyRef.collection('regularTasks').doc();
                batch.set(rtRef, { ...rt, createdAt: firebase.firestore.FieldValue.serverTimestamp() });
            }
            
            // Sample tasks for today/tomorrow
            const today = new Date();
            const tomorrow = new Date(today);
            tomorrow.setDate(tomorrow.getDate() + 1);
            
            // Завдання прив'язані до ФУНКЦІЙ, виконавці беруться автоматично
            // Коли людина звільняється - видаляємо її з функції, нові завдання падають на нового співробітника
            const clinicTasks = [
                { title: 'Первинна консультація - Іванов І.І.', function: 'Лікування', status: 'new', priority: 'high', deadlineDate: getLocalDateStr(today), deadlineTime: '10:00', estimatedTime: '45', expectedResult: 'Діагноз, план лікування' },
                { title: 'Підготувати рекламну акцію на Новий рік', function: 'Маркетинг', status: 'progress', priority: 'medium', deadlineDate: getLocalDateStr(tomorrow), deadlineTime: '15:00', estimatedTime: '120', expectedResult: 'Готовий макет та текст акції' },
                { title: 'Замовити нові рукавички та маски', function: 'Закупівлі', status: 'new', priority: 'medium', deadlineDate: getLocalDateStr(today), deadlineTime: '14:00', estimatedTime: '30', expectedResult: 'Замовлення оформлене' },
                { title: 'Оплатити рахунок за оренду', function: 'Фінанси', status: 'new', priority: 'high', deadlineDate: getLocalDateStr(today), deadlineTime: '16:00', estimatedTime: '15', expectedResult: 'Рахунок оплачено' }
            ];
            
            for (const task of clinicTasks) {
                // Знаходимо функцію і беремо першого виконавця з неї
                const func = clinicFunctions.find(f => f.name === task.function);
                const assigneeId = func?.assigneeIds?.[0] || null;
                // Знаходимо ім'я виконавця по індексу в userIds
                const assigneeIndex = userIds.indexOf(assigneeId);
                const assigneeName = assigneeIndex >= 0 ? demoUsers[assigneeIndex].name : '';
                
                const taskRef = companyRef.collection('tasks').doc();
                batch.set(taskRef, { 
                    ...task,
                    assigneeId: assigneeId,
                    assigneeName: assigneeName,
                    createdBy: currentUser.uid,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    deadline: firebase.firestore.Timestamp.fromDate(new Date(task.deadlineDate + 'T' + task.deadlineTime))
                });
            }
            
            // Бізнес-процеси (шаблони) для клініки
            const clinicProcessTemplates = [
                {
                    name: 'Прийом нового пацієнта',
                    description: 'Повний цикл від запису до завершення лікування',
                    steps: [
                        { name: 'Запис пацієнта', function: 'Адміністрування', estimatedTime: '15', instruction: 'Зібрати контактні дані, причину звернення, записати на зручний час' },
                        { name: 'Нагадування про візит', function: 'Адміністрування', estimatedTime: '5', instruction: 'Зателефонувати за день до візиту, підтвердити запис' },
                        { name: 'Первинний огляд', function: 'Лікування', estimatedTime: '30', instruction: 'Провести огляд, зібрати анамнез, поставити попередній діагноз' },
                        { name: 'Складання плану лікування', function: 'Лікування', estimatedTime: '20', instruction: 'Розробити план лікування, погодити з пацієнтом' },
                        { name: 'Виставлення рахунку', function: 'Фінанси', estimatedTime: '10', instruction: 'Підготувати рахунок згідно плану лікування' },
                        { name: 'Проведення процедур', function: 'Лікування', estimatedTime: '60', instruction: 'Виконати заплановані процедури' },
                        { name: 'Контрольний огляд', function: 'Лікування', estimatedTime: '20', instruction: 'Перевірити результат лікування' }
                    ]
                },
                {
                    name: 'Закупівля обладнання',
                    description: 'Процес придбання нового медичного обладнання',
                    steps: [
                        { name: 'Формування потреби', function: 'Лікування', estimatedTime: '30', instruction: 'Описати яке обладнання потрібно, характеристики, бюджет' },
                        { name: 'Пошук постачальників', function: 'Закупівлі', estimatedTime: '120', instruction: 'Знайти 3-5 постачальників, запросити КП' },
                        { name: 'Порівняння пропозицій', function: 'Закупівлі', estimatedTime: '60', instruction: 'Порівняти ціни, умови, гарантії' },
                        { name: 'Погодження з керівництвом', function: 'Фінанси', estimatedTime: '30', instruction: 'Представити варіанти, отримати схвалення' },
                        { name: 'Оформлення замовлення', function: 'Закупівлі', estimatedTime: '30', instruction: 'Підписати договір, внести передоплату' },
                        { name: 'Прийом та перевірка', function: 'Закупівлі', estimatedTime: '60', instruction: 'Прийняти обладнання, перевірити комплектність' },
                        { name: 'Введення в експлуатацію', function: 'Лікування', estimatedTime: '60', instruction: 'Встановити, налаштувати, навчити персонал' }
                    ]
                },
                {
                    name: 'Маркетингова кампанія',
                    description: 'Запуск рекламної кампанії для залучення пацієнтів',
                    steps: [
                        { name: 'Визначення цілей', function: 'Маркетинг', estimatedTime: '60', instruction: 'Визначити цільову аудиторію, KPI, бюджет' },
                        { name: 'Розробка креативів', function: 'Маркетинг', estimatedTime: '180', instruction: 'Створити банери, тексти, відео' },
                        { name: 'Погодження матеріалів', function: 'Адміністрування', estimatedTime: '30', instruction: 'Перевірити відповідність мед. законодавству' },
                        { name: 'Налаштування реклами', function: 'Маркетинг', estimatedTime: '120', instruction: 'Запустити кампанії в Google Ads, Facebook' },
                        { name: 'Моніторинг результатів', function: 'Маркетинг', estimatedTime: '30', instruction: 'Щоденно перевіряти показники, коригувати' },
                        { name: 'Звіт про результати', function: 'Маркетинг', estimatedTime: '60', instruction: 'Підготувати фінальний звіт по кампанії' }
                    ]
                }
            ];
            
            for (const template of clinicProcessTemplates) {
                const templateRef = companyRef.collection('processTemplates').doc();
                batch.set(templateRef, {
                    ...template,
                    createdBy: currentUser.uid,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Запускаємо 1 процес з кожного шаблону
                if (template.name === 'Прийом нового пацієнта') {
                    const procRef = companyRef.collection('processes').doc();
                    batch.set(procRef, {
                        name: 'Пацієнт Іванов І.І. — імплантація',
                        templateId: templateRef.id,
                        currentStep: 3,
                        status: 'active',
                        assigneeId: userIds[1],
                        deadline: getLocalDateStr(new Date(Date.now() + 5 * 86400000)),
                        createdBy: currentUser.uid,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                }
                if (template.name === 'Маркетингова кампанія') {
                    const procRef = companyRef.collection('processes').doc();
                    batch.set(procRef, {
                        name: 'Акція "Безкоштовна консультація"',
                        templateId: templateRef.id,
                        currentStep: 1,
                        status: 'active',
                        assigneeId: userIds[2],
                        deadline: getLocalDateStr(new Date(Date.now() + 14 * 86400000)),
                        createdBy: currentUser.uid,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                }
            }
            
            // Demo projects for clinic
            const clinicProjects = [
                {
                    name: 'Відкриття другої філії',
                    description: 'Планування та запуск нової локації клініки в Луцьку',
                    color: '#3b82f6',
                    status: 'active',
                    startDate: getLocalDateStr(new Date(Date.now() - 30 * 86400000)),
                    deadline: getLocalDateStr(new Date(Date.now() + 90 * 86400000))
                },
                {
                    name: 'Впровадження CRM системи',
                    description: 'Автоматизація запису пацієнтів та нагадувань',
                    color: '#8b5cf6',
                    status: 'active',
                    startDate: getLocalDateStr(new Date(Date.now() - 14 * 86400000)),
                    deadline: getLocalDateStr(new Date(Date.now() + 45 * 86400000))
                },
                {
                    name: 'Сертифікація ISO 9001',
                    description: 'Підготовка документації та проходження аудиту',
                    color: '#f59e0b',
                    status: 'paused',
                    startDate: getLocalDateStr(new Date(Date.now() - 60 * 86400000)),
                    deadline: getLocalDateStr(new Date(Date.now() + 120 * 86400000))
                }
            ];
            
            const projectRefs = [];
            for (const proj of clinicProjects) {
                const projRef = companyRef.collection('projects').doc();
                batch.set(projRef, {
                    ...proj,
                    creatorId: currentUser.uid,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                projectRefs.push(projRef.id);
            }
            
            // Додаємо задачі з прив'язкою до проєктів
            const projectTasks = [
                // Проект 0: Відкриття другої філії (7 завдань)
                { title: 'Знайти приміщення для другої філії', function: 'Адміністрування', status: 'progress', priority: 'high', deadlineDate: getLocalDateStr(new Date(Date.now() + 7 * 86400000)), projectId: projectRefs[0] },
                { title: 'Отримати ліцензію МОЗ', function: 'Адміністрування', status: 'new', priority: 'high', deadlineDate: getLocalDateStr(new Date(Date.now() + 30 * 86400000)), projectId: projectRefs[0] },
                { title: 'Ремонт та облаштування кабінетів', function: 'Адміністрування', status: 'new', priority: 'high', deadlineDate: getLocalDateStr(new Date(Date.now() + 45 * 86400000)), projectId: projectRefs[0] },
                { title: 'Закупівля обладнання для філії', function: 'Адміністрування', status: 'new', priority: 'high', deadlineDate: getLocalDateStr(new Date(Date.now() + 40 * 86400000)), projectId: projectRefs[0] },
                { title: 'Набір персоналу для філії', function: 'Адміністрування', status: 'new', priority: 'medium', deadlineDate: getLocalDateStr(new Date(Date.now() + 50 * 86400000)), projectId: projectRefs[0] },
                { title: 'Підключити філію до IT-інфраструктури', function: 'Адміністрування', status: 'new', priority: 'medium', deadlineDate: getLocalDateStr(new Date(Date.now() + 55 * 86400000)), projectId: projectRefs[0] },
                { title: 'Маркетинг відкриття нової локації', function: 'Маркетинг', status: 'new', priority: 'medium', deadlineDate: getLocalDateStr(new Date(Date.now() + 60 * 86400000)), projectId: projectRefs[0] },
                // Проект 1: Впровадження CRM (6 завдань)
                { title: 'Порівняти CRM: Bitrix vs HubSpot vs TALKO', function: 'Маркетинг', status: 'done', priority: 'medium', deadlineDate: getLocalDateStr(new Date(Date.now() - 3 * 86400000)), projectId: projectRefs[1] },
                { title: 'Налаштувати автоматичні нагадування', function: 'Маркетинг', status: 'progress', priority: 'medium', deadlineDate: getLocalDateStr(new Date(Date.now() + 10 * 86400000)), projectId: projectRefs[1] },
                { title: 'Навчити персонал роботі з CRM', function: 'Адміністрування', status: 'new', priority: 'low', deadlineDate: getLocalDateStr(new Date(Date.now() + 20 * 86400000)), projectId: projectRefs[1] },
                { title: 'Імпорт бази пацієнтів в CRM', function: 'Маркетинг', status: 'done', priority: 'high', deadlineDate: getLocalDateStr(new Date(Date.now() - 5 * 86400000)), projectId: projectRefs[1] },
                { title: 'Налаштувати воронку продажів', function: 'Маркетинг', status: 'progress', priority: 'high', deadlineDate: getLocalDateStr(new Date(Date.now() + 8 * 86400000)), projectId: projectRefs[1] },
                { title: 'Інтеграція CRM з телефонією', function: 'Адміністрування', status: 'new', priority: 'medium', deadlineDate: getLocalDateStr(new Date(Date.now() + 15 * 86400000)), projectId: projectRefs[1] }
            ];
            
            for (const task of projectTasks) {
                const func = clinicFunctions.find(f => f.name === task.function);
                const assigneeId = func?.assigneeIds?.[0] || null;
                const assigneeIndex = userIds.indexOf(assigneeId);
                const assigneeName = assigneeIndex >= 0 ? demoUsers[assigneeIndex].name : '';
                const taskRef = companyRef.collection('tasks').doc();
                batch.set(taskRef, {
                    ...task,
                    assigneeId, assigneeName,
                    createdBy: currentUser.uid,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
            }
            
            await batch.commit();
        }
        
        async function loadManufacturingDemoData() {
            const batch = db.batch();
            const companyRef = db.collection('companies').doc(currentCompany);
            
            // Demo users
            const demoUsers = [
                { name: 'Сергій Мельник', email: 'sergiy@demo.factory', role: 'employee' },
                { name: 'Віктор Бондаренко', email: 'viktor@demo.factory', role: 'employee' },
                { name: 'Ірина Ткаченко', email: 'iryna@demo.factory', role: 'employee' }
            ];
            
            const userIds = [];
            for (const user of demoUsers) {
                const userRef = companyRef.collection('users').doc();
                batch.set(userRef, { ...user, createdAt: firebase.firestore.FieldValue.serverTimestamp() });
                userIds.push(userRef.id);
            }
            
            // Functions for manufacturing
            const mfgFunctions = [
                { name: 'Виробництво', description: 'Управління виробничим процесом, контроль лінії', assigneeIds: [userIds[0]] },
                { name: 'Контроль якості', description: 'Перевірка продукції, стандарти, брак', assigneeIds: [userIds[1]] },
                { name: 'Логістика', description: 'Відвантаження, доставка, склад', assigneeIds: [userIds[2]] },
                { name: 'Постачання', description: 'Закупівля сировини, комплектуючих', assigneeIds: [userIds[2]] },
                { name: 'Обслуговування', description: 'Ремонт обладнання, профілактика', assigneeIds: [userIds[0], userIds[1]] }
            ];
            
            const funcRefs = [];
            for (const func of mfgFunctions) {
                const funcRef = companyRef.collection('functions').doc();
                batch.set(funcRef, { ...func, createdAt: firebase.firestore.FieldValue.serverTimestamp() });
                funcRefs.push({ id: funcRef.id, ...func });
            }
            
            // Regular tasks for manufacturing
            const mfgRegularTasks = [
                { title: 'Ранкова перевірка обладнання', function: 'Виробництво', period: 'weekly', dayOfWeek: '1', time: '07:30', estimatedTime: '30', instruction: 'Перевірити стан всіх верстатів, рівень мастила, тиск, температуру.' },
                { title: 'Ранкова перевірка обладнання', function: 'Виробництво', period: 'weekly', dayOfWeek: '2', time: '07:30', estimatedTime: '30', instruction: 'Перевірити стан всіх верстатів.' },
                { title: 'Ранкова перевірка обладнання', function: 'Виробництво', period: 'weekly', dayOfWeek: '3', time: '07:30', estimatedTime: '30', instruction: 'Перевірити стан всіх верстатів.' },
                { title: 'Ранкова перевірка обладнання', function: 'Виробництво', period: 'weekly', dayOfWeek: '4', time: '07:30', estimatedTime: '30', instruction: 'Перевірити стан всіх верстатів.' },
                { title: 'Ранкова перевірка обладнання', function: 'Виробництво', period: 'weekly', dayOfWeek: '5', time: '07:30', estimatedTime: '30', instruction: 'Перевірити стан всіх верстатів.' },
                { title: 'Контроль якості партії', function: 'Контроль якості', period: 'weekly', dayOfWeek: '2', time: '14:00', estimatedTime: '60', instruction: 'Вибіркова перевірка продукції, заповнення журналу якості.' },
                { title: 'Контроль якості партії', function: 'Контроль якості', period: 'weekly', dayOfWeek: '4', time: '14:00', estimatedTime: '60', instruction: 'Вибіркова перевірка продукції.' },
                { title: 'Інвентаризація складу', function: 'Логістика', period: 'weekly', dayOfWeek: '5', time: '16:00', estimatedTime: '90', instruction: 'Перевірити залишки готової продукції та сировини. Оновити систему.' },
                { title: 'Замовлення сировини', function: 'Постачання', period: 'weekly', dayOfWeek: '1', time: '10:00', estimatedTime: '45', instruction: 'Проаналізувати потреби на тиждень, сформувати замовлення постачальникам.' },
                { title: 'Технічне обслуговування обладнання', function: 'Обслуговування', period: 'monthly', dayOfMonth: '1', time: '08:00', estimatedTime: '240', instruction: 'Повне ТО всіх верстатів: мастило, фільтри, калібрування.' },
                { title: 'Звіт по виробництву за місяць', function: 'Виробництво', period: 'monthly', dayOfMonth: 'last', time: '15:00', estimatedTime: '120', instruction: 'Підготувати звіт: обсяг виробництва, простої, брак, ефективність.' }
            ];
            
            for (const rt of mfgRegularTasks) {
                const rtRef = companyRef.collection('regularTasks').doc();
                batch.set(rtRef, { ...rt, createdAt: firebase.firestore.FieldValue.serverTimestamp() });
            }
            
            // Sample tasks - виконавці беруться з функцій автоматично
            const today = new Date();
            const tomorrow = new Date(today);
            tomorrow.setDate(tomorrow.getDate() + 1);
            
            const mfgTasks = [
                { title: 'Виготовити партію 500 од. - Замовлення #1247', function: 'Виробництво', status: 'progress', priority: 'high', deadlineDate: getLocalDateStr(today), deadlineTime: '17:00', estimatedTime: '360', expectedResult: '500 одиниць готової продукції' },
                { title: 'Перевірити якість партії #1245', function: 'Контроль якості', status: 'new', priority: 'high', deadlineDate: getLocalDateStr(today), deadlineTime: '12:00', estimatedTime: '60', expectedResult: 'Звіт про якість, % браку' },
                { title: 'Відвантаження клієнту ТОВ "Альфа"', function: 'Логістика', status: 'new', priority: 'medium', deadlineDate: getLocalDateStr(tomorrow), deadlineTime: '09:00', estimatedTime: '90', expectedResult: 'Товар відвантажено, ТТН підписана' },
                { title: 'Замовити комплектуючі до верстата #3', function: 'Постачання', status: 'new', priority: 'medium', deadlineDate: getLocalDateStr(today), deadlineTime: '14:00', estimatedTime: '30', expectedResult: 'Замовлення оформлене' },
                { title: 'Ремонт конвеєра - лінія 2', function: 'Обслуговування', status: 'progress', priority: 'high', deadlineDate: getLocalDateStr(today), deadlineTime: '11:00', estimatedTime: '120', expectedResult: 'Конвеєр працює' }
            ];
            
            for (const task of mfgTasks) {
                // Знаходимо функцію і беремо першого виконавця з неї
                const func = mfgFunctions.find(f => f.name === task.function);
                const assigneeId = func?.assigneeIds?.[0] || null;
                // Знаходимо ім'я виконавця по індексу в userIds
                const assigneeIndex = userIds.indexOf(assigneeId);
                const assigneeName = assigneeIndex >= 0 ? demoUsers[assigneeIndex].name : '';
                
                const taskRef = companyRef.collection('tasks').doc();
                batch.set(taskRef, { 
                    ...task,
                    assigneeId: assigneeId,
                    assigneeName: assigneeName,
                    createdBy: currentUser.uid,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    deadline: firebase.firestore.Timestamp.fromDate(new Date(task.deadlineDate + 'T' + task.deadlineTime))
                });
            }
            
            // Бізнес-процеси (шаблони) для виробництва
            const mfgProcessTemplates = [
                {
                    name: 'Виконання замовлення клієнта',
                    description: 'Повний цикл від отримання замовлення до відвантаження',
                    steps: [
                        { name: 'Отримання та підтвердження замовлення', function: 'Логістика', estimatedTime: '30', instruction: 'Отримати замовлення, перевірити наявність матеріалів, підтвердити терміни клієнту' },
                        { name: 'Перевірка сировини на складі', function: 'Постачання', estimatedTime: '30', instruction: 'Перевірити наявність всієї сировини, при потребі терміново замовити' },
                        { name: 'Планування виробництва', function: 'Виробництво', estimatedTime: '45', instruction: 'Скласти графік виробництва, розподілити по лініях' },
                        { name: 'Виготовлення продукції', function: 'Виробництво', estimatedTime: '480', instruction: 'Виготовити продукцію згідно специфікації' },
                        { name: 'Контроль якості партії', function: 'Контроль якості', estimatedTime: '60', instruction: 'Перевірити продукцію на відповідність стандартам' },
                        { name: 'Пакування та маркування', function: 'Логістика', estimatedTime: '60', instruction: 'Запакувати продукцію, нанести маркування' },
                        { name: 'Оформлення документів', function: 'Логістика', estimatedTime: '30', instruction: 'Підготувати ТТН, рахунок-фактуру, сертифікати' },
                        { name: 'Відвантаження клієнту', function: 'Логістика', estimatedTime: '60', instruction: 'Завантажити продукцію, передати документи водію' }
                    ]
                },
                {
                    name: 'Закупівля сировини',
                    description: 'Процес поповнення запасів сировини',
                    steps: [
                        { name: 'Аналіз потреб', function: 'Постачання', estimatedTime: '45', instruction: 'Проаналізувати залишки, визначити потребу на місяць' },
                        { name: 'Запит комерційних пропозицій', function: 'Постачання', estimatedTime: '60', instruction: 'Відправити запити 3-5 постачальникам' },
                        { name: 'Порівняння та вибір постачальника', function: 'Постачання', estimatedTime: '30', instruction: 'Порівняти ціни, терміни, якість' },
                        { name: 'Оформлення замовлення', function: 'Постачання', estimatedTime: '30', instruction: 'Підписати договір/специфікацію, оплатити' },
                        { name: 'Приймання на склад', function: 'Логістика', estimatedTime: '60', instruction: 'Прийняти сировину, перевірити кількість і якість' },
                        { name: 'Вхідний контроль якості', function: 'Контроль якості', estimatedTime: '45', instruction: 'Перевірити сировину на відповідність специфікації' },
                        { name: 'Оприбуткування в системі', function: 'Логістика', estimatedTime: '20', instruction: 'Внести дані в облікову систему' }
                    ]
                },
                {
                    name: 'Ремонт обладнання',
                    description: 'Процес усунення несправності обладнання',
                    steps: [
                        { name: 'Фіксація несправності', function: 'Виробництво', estimatedTime: '15', instruction: 'Зафіксувати що зламалось, симптоми, коли виникло' },
                        { name: 'Діагностика', function: 'Обслуговування', estimatedTime: '60', instruction: 'Визначити причину поломки, необхідні запчастини' },
                        { name: 'Замовлення запчастин', function: 'Постачання', estimatedTime: '30', instruction: 'Замовити необхідні запчастини (якщо немає на складі)' },
                        { name: 'Проведення ремонту', function: 'Обслуговування', estimatedTime: '180', instruction: 'Виконати ремонтні роботи' },
                        { name: 'Тестування', function: 'Обслуговування', estimatedTime: '30', instruction: 'Перевірити роботу обладнання після ремонту' },
                        { name: 'Введення в експлуатацію', function: 'Виробництво', estimatedTime: '15', instruction: 'Повернути обладнання в роботу, зробити запис в журналі' }
                    ]
                }
            ];
            
            for (const template of mfgProcessTemplates) {
                const templateRef = companyRef.collection('processTemplates').doc();
                batch.set(templateRef, {
                    ...template,
                    createdBy: currentUser.uid,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Запускаємо процеси
                if (template.name === 'Виконання замовлення клієнта') {
                    const procRef = companyRef.collection('processes').doc();
                    batch.set(procRef, {
                        name: 'Замовлення #1247 — ТОВ "Альфа"',
                        templateId: templateRef.id,
                        currentStep: 4,
                        status: 'active',
                        assigneeId: userIds[0],
                        deadline: getLocalDateStr(new Date(Date.now() + 3 * 86400000)),
                        createdBy: currentUser.uid,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    const procRef2 = companyRef.collection('processes').doc();
                    batch.set(procRef2, {
                        name: 'Замовлення #1250 — ФОП Петренко',
                        templateId: templateRef.id,
                        currentStep: 1,
                        status: 'active',
                        assigneeId: userIds[2],
                        deadline: getLocalDateStr(new Date(Date.now() + 10 * 86400000)),
                        createdBy: currentUser.uid,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                }
                if (template.name === 'Ремонт обладнання') {
                    const procRef = companyRef.collection('processes').doc();
                    batch.set(procRef, {
                        name: 'Ремонт конвеєра — лінія 2',
                        templateId: templateRef.id,
                        currentStep: 3,
                        status: 'active',
                        assigneeId: userIds[0],
                        deadline: getLocalDateStr(new Date(Date.now() - 1 * 86400000)),
                        createdBy: currentUser.uid,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                }
            }
            
            // Demo projects for manufacturing
            const mfgProjects = [
                {
                    name: 'Запуск нової виробничої лінії',
                    description: 'Монтаж та налагодження лінії #4 для нового продукту',
                    color: '#ef4444',
                    status: 'active',
                    startDate: getLocalDateStr(new Date(Date.now() - 20 * 86400000)),
                    deadline: getLocalDateStr(new Date(Date.now() + 60 * 86400000))
                },
                {
                    name: 'Автоматизація складу',
                    description: 'Впровадження WMS системи та штрихкодування',
                    color: '#3b82f6',
                    status: 'active',
                    startDate: getLocalDateStr(new Date(Date.now() - 7 * 86400000)),
                    deadline: getLocalDateStr(new Date(Date.now() + 45 * 86400000))
                },
                {
                    name: 'Зменшення браку на 50%',
                    description: 'Аналіз причин браку, навчання персоналу, нові стандарти',
                    color: '#22c55e',
                    status: 'active',
                    startDate: getLocalDateStr(new Date(Date.now() - 45 * 86400000)),
                    deadline: getLocalDateStr(new Date(Date.now() + 30 * 86400000))
                }
            ];
            
            const mfgProjectRefs = [];
            for (const proj of mfgProjects) {
                const projRef = companyRef.collection('projects').doc();
                batch.set(projRef, {
                    ...proj,
                    creatorId: currentUser.uid,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                mfgProjectRefs.push(projRef.id);
            }
            
            // Задачі з прив'язкою до проєктів
            const mfgProjectTasks = [
                // Проект 0: Запуск нової виробничої лінії (8 завдань)
                { title: 'Фундамент під лінію #4', function: 'Виробництво', status: 'done', priority: 'high', deadlineDate: getLocalDateStr(new Date(Date.now() - 5 * 86400000)), projectId: mfgProjectRefs[0] },
                { title: 'Монтаж обладнання лінії #4', function: 'Обслуговування', status: 'progress', priority: 'high', deadlineDate: getLocalDateStr(new Date(Date.now() + 14 * 86400000)), projectId: mfgProjectRefs[0] },
                { title: 'Тестовий запуск лінії #4', function: 'Виробництво', status: 'new', priority: 'high', deadlineDate: getLocalDateStr(new Date(Date.now() + 30 * 86400000)), projectId: mfgProjectRefs[0] },
                { title: 'Підключення електрики 380V', function: 'Обслуговування', status: 'done', priority: 'high', deadlineDate: getLocalDateStr(new Date(Date.now() - 3 * 86400000)), projectId: mfgProjectRefs[0] },
                { title: 'Калібрування датчиків лінії #4', function: 'Контроль якості', status: 'new', priority: 'medium', deadlineDate: getLocalDateStr(new Date(Date.now() + 25 * 86400000)), projectId: mfgProjectRefs[0] },
                { title: 'Навчання операторів лінії #4', function: 'Виробництво', status: 'new', priority: 'medium', deadlineDate: getLocalDateStr(new Date(Date.now() + 35 * 86400000)), projectId: mfgProjectRefs[0] },
                { title: 'Закупівля сировини для тестового запуску', function: 'Постачання', status: 'progress', priority: 'medium', deadlineDate: getLocalDateStr(new Date(Date.now() + 10 * 86400000)), projectId: mfgProjectRefs[0] },
                { title: 'Узгодження графіку змін для лінії #4', function: 'Виробництво', status: 'new', priority: 'low', deadlineDate: getLocalDateStr(new Date(Date.now() + 28 * 86400000)), projectId: mfgProjectRefs[0] },
                // Проект 1: Автоматизація складу (7 завдань)
                { title: 'Обрати WMS систему', function: 'Логістика', status: 'done', priority: 'medium', deadlineDate: getLocalDateStr(new Date(Date.now() - 2 * 86400000)), projectId: mfgProjectRefs[1] },
                { title: 'Закупити сканери штрихкодів', function: 'Постачання', status: 'progress', priority: 'medium', deadlineDate: getLocalDateStr(new Date(Date.now() + 7 * 86400000)), projectId: mfgProjectRefs[1] },
                { title: 'Розмітка зон зберігання', function: 'Логістика', status: 'done', priority: 'high', deadlineDate: getLocalDateStr(new Date(Date.now() - 8 * 86400000)), projectId: mfgProjectRefs[1] },
                { title: 'Налаштування WMS під наш склад', function: 'Логістика', status: 'progress', priority: 'high', deadlineDate: getLocalDateStr(new Date(Date.now() + 12 * 86400000)), projectId: mfgProjectRefs[1] },
                { title: 'Інтеграція WMS з 1С', function: 'Логістика', status: 'new', priority: 'high', deadlineDate: getLocalDateStr(new Date(Date.now() + 20 * 86400000)), projectId: mfgProjectRefs[1] },
                { title: 'Навчання комірників роботі зі сканерами', function: 'Логістика', status: 'new', priority: 'medium', deadlineDate: getLocalDateStr(new Date(Date.now() + 25 * 86400000)), projectId: mfgProjectRefs[1] },
                { title: 'Тестова інвентаризація з WMS', function: 'Логістика', status: 'new', priority: 'low', deadlineDate: getLocalDateStr(new Date(Date.now() + 30 * 86400000)), projectId: mfgProjectRefs[1] },
                // Проект 2: Зменшення браку на 50% (7 завдань)
                { title: 'Аналіз причин браку за 6 місяців', function: 'Контроль якості', status: 'done', priority: 'high', deadlineDate: getLocalDateStr(new Date(Date.now() - 10 * 86400000)), projectId: mfgProjectRefs[2] },
                { title: 'Навчання операторів новим стандартам', function: 'Виробництво', status: 'progress', priority: 'medium', deadlineDate: getLocalDateStr(new Date(Date.now() + 14 * 86400000)), projectId: mfgProjectRefs[2] },
                { title: 'Встановити датчики контролю на лінії #1-3', function: 'Обслуговування', status: 'done', priority: 'high', deadlineDate: getLocalDateStr(new Date(Date.now() - 4 * 86400000)), projectId: mfgProjectRefs[2] },
                { title: 'Розробити чек-листи контролю якості', function: 'Контроль якості', status: 'done', priority: 'medium', deadlineDate: getLocalDateStr(new Date(Date.now() - 7 * 86400000)), projectId: mfgProjectRefs[2] },
                { title: 'Впровадити систему звітів по браку', function: 'Контроль якості', status: 'progress', priority: 'medium', deadlineDate: getLocalDateStr(new Date(Date.now() + 5 * 86400000)), projectId: mfgProjectRefs[2] },
                { title: 'Заміна зношеного інструменту', function: 'Постачання', status: 'progress', priority: 'high', deadlineDate: getLocalDateStr(new Date(Date.now() + 3 * 86400000)), projectId: mfgProjectRefs[2] },
                { title: 'Контрольний замір браку через 30 днів', function: 'Контроль якості', status: 'new', priority: 'high', deadlineDate: getLocalDateStr(new Date(Date.now() + 30 * 86400000)), projectId: mfgProjectRefs[2] }
            ];
            
            for (const task of mfgProjectTasks) {
                const func = mfgFunctions.find(f => f.name === task.function);
                const assigneeId = func?.assigneeIds?.[0] || null;
                const assigneeIndex = userIds.indexOf(assigneeId);
                const assigneeName = assigneeIndex >= 0 ? demoUsers[assigneeIndex].name : '';
                const taskRef = companyRef.collection('tasks').doc();
                batch.set(taskRef, {
                    ...task,
                    assigneeId, assigneeName,
                    createdBy: currentUser.uid,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
            }
            
            await batch.commit();
        }

        // =====================
        // MOBILE FILTERS
        // =====================
        let mobileFilters = {
            type: '',
            date: '',
            status: [],
            function: '',
            assignee: ''
        };
        
        function openFilterModal() {
            const modal = document.getElementById('filterModal');
            modal.style.display = 'flex';
            
            // Sync desktop status multi-select to mobile
            mobileFilters.status = getSelectedStatuses();
            
            // Populate function chips
            const funcContainer = document.getElementById('filterFunctionChips');
            const activeFuncs = functions.filter(f => f.status !== 'archived');
            funcContainer.innerHTML = '<div class="filter-chip selected" data-value="" onclick="selectFilterChip(this, \'function\')">Всі</div>';
            activeFuncs.forEach(f => {
                const selected = mobileFilters.function === f.name ? 'selected' : '';
                funcContainer.innerHTML += `<div class="filter-chip ${selected}" data-value="${esc(f.name)}" onclick="selectFilterChip(this, 'function')">${esc(f.name)}</div>`;
            });
            
            // Populate assignee chips
            const assigneeContainer = document.getElementById('filterAssigneeChips');
            assigneeContainer.innerHTML = '<div class="filter-chip selected" data-value="" onclick="selectFilterChip(this, \'assignee\')">Всі</div>';
            users.forEach(u => {
                const name = u.name || u.email.split('@')[0];
                const selected = mobileFilters.assignee === u.id ? 'selected' : '';
                assigneeContainer.innerHTML += `<div class="filter-chip ${selected}" data-value="${esc(u.id)}" onclick="selectFilterChip(this, 'assignee')">${esc(name)}</div>`;
            });
            
            // Sync current filters
            syncFilterChips();
            refreshIcons();
        }
        
        function closeFilterModal() {
            closeModal('filterModal');
        }
        
        function selectFilterChip(chip, category) {
            if (category === 'status') {
                // Multi-select logic for status
                const val = chip.dataset.value;
                if (val === '') {
                    // "Всі" clicked - deselect all specific statuses
                    mobileFilters.status = [];
                    chip.parentElement.querySelectorAll('.filter-chip').forEach(c => c.classList.remove('selected'));
                    chip.classList.add('selected');
                } else {
                    // Toggle specific status
                    const allChip = chip.parentElement.querySelector('.filter-chip[data-value=""]');
                    if (chip.classList.contains('selected')) {
                        chip.classList.remove('selected');
                        mobileFilters.status = mobileFilters.status.filter(s => s !== val);
                    } else {
                        chip.classList.add('selected');
                        mobileFilters.status.push(val);
                    }
                    // Remove "Всі" selection if specific selected
                    if (mobileFilters.status.length > 0) {
                        allChip?.classList.remove('selected');
                    }
                    // If none selected, highlight "Всі"
                    if (mobileFilters.status.length === 0) {
                        allChip?.classList.add('selected');
                    }
                    // If all 4 selected, treat as "Всі"
                    if (mobileFilters.status.length === 4) {
                        mobileFilters.status = [];
                        chip.parentElement.querySelectorAll('.filter-chip').forEach(c => c.classList.remove('selected'));
                        allChip?.classList.add('selected');
                    }
                }
            } else {
                // Single-select for other categories
                chip.parentElement.querySelectorAll('.filter-chip').forEach(c => c.classList.remove('selected'));
                chip.classList.add('selected');
                mobileFilters[category] = chip.dataset.value;
            }
        }
        
        function syncFilterChips() {
            // Sync type
            document.querySelectorAll('#filterTypeChips .filter-chip').forEach(c => {
                c.classList.toggle('selected', c.dataset.value === mobileFilters.type);
            });
            // Sync date
            document.querySelectorAll('#filterDateChips .filter-chip').forEach(c => {
                c.classList.toggle('selected', c.dataset.value === mobileFilters.date);
            });
            // Sync status (multi-select)
            document.querySelectorAll('#filterStatusChips .filter-chip').forEach(c => {
                const val = c.dataset.value;
                if (val === '') {
                    c.classList.toggle('selected', mobileFilters.status.length === 0);
                } else {
                    c.classList.toggle('selected', mobileFilters.status.includes(val));
                }
            });
        }
        
        function applyFiltersAndClose() {
            // Apply filters to desktop selects
            document.getElementById('taskTypeFilter').value = mobileFilters.type;
            syncTaskTypeTabs();
            document.getElementById('dateFilter').value = mobileFilters.date;
            setStatusFilterFromArray(mobileFilters.status);
            document.getElementById('functionFilter').value = mobileFilters.function;
            document.getElementById('assigneeFilter').value = mobileFilters.assignee;
            
            // Update filter count badge
            updateFilterCount();
            
            // Update quick filter buttons
            updateQuickFilterButtons();
            
            renderTasks();
            closeFilterModal();
        }
        
        function clearAllFilters() {
            mobileFilters = { type: '', date: '', status: [], function: '', assignee: '' };
            document.querySelectorAll('.filter-chip').forEach(c => {
                c.classList.toggle('selected', c.dataset.value === '');
            });
            applyFiltersAndClose();
        }
        
        function updateFilterCount() {
            let count = 0;
            Object.entries(mobileFilters).forEach(([key, v]) => {
                if (key === 'status') {
                    if (Array.isArray(v) && v.length > 0) count++;
                } else {
                    if (v !== '') count++;
                }
            });
            const badge = document.getElementById('activeFilterCount');
            if (count > 0) {
                badge.textContent = count;
                badge.style.display = 'inline';
            } else {
                badge.style.display = 'none';
            }
        }
        
        function setMobileQuickFilter(filter) {
            // Toggle behavior
            if (filter === 'my') {
                mobileFilters.type = mobileFilters.type === 'my' ? '' : 'my';
                mobileFilters.date = '';
            } else if (filter === 'today') {
                mobileFilters.date = mobileFilters.date === 'today' ? '' : 'today';
                mobileFilters.type = '';
            }
            
            // Apply to desktop filters
            document.getElementById('taskTypeFilter').value = mobileFilters.type;
            document.getElementById('dateFilter').value = mobileFilters.date;
            
            updateQuickFilterButtons();
            updateFilterCount();
            renderTasks();
        }
        
        function updateQuickFilterButtons() {
            document.querySelectorAll('.mobile-filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            if (mobileFilters.type === 'my') {
                document.querySelector('.mobile-filter-btn[onclick*="my"]')?.classList.add('active');
            }
            if (mobileFilters.date === 'today') {
                document.querySelector('.mobile-filter-btn[onclick*="today"]')?.classList.add('active');
            }
        }
        
        // Update bottom nav active state
        const originalSwitchTab = window.switchTab;
        window.switchTab = function(tab) {
            originalSwitchTab(tab);
            
            // Update bottom nav
            document.querySelectorAll('.bottom-nav-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.tab === tab) {
                    btn.classList.add('active');
                }
            });
        };
        
        // =====================
        // SWIPE BETWEEN TABS
        // =====================
        const mobileTabs = ['tasks', 'projects', 'control', 'regular', 'users'];
        let tabSwipeStartX = 0;
        let tabSwipeStartY = 0;
        let isTabSwiping = false;
        
        function initTabSwipeGestures() {
            const mainInterface = document.getElementById('mainInterface');
            if (!mainInterface || mainInterface.dataset.tabSwipeInit) return;
            
            mainInterface.dataset.tabSwipeInit = 'true';
            
            mainInterface.addEventListener('touchstart', (e) => {
                // Ignore if swiping on a task card or modal
                if (e.target.closest('.mobile-task-card') || 
                    e.target.closest('.modal') ||
                    e.target.closest('.filter-chips') ||
                    e.target.closest('input') ||
                    e.target.closest('select') ||
                    e.target.closest('button')) {
                    return;
                }
                
                tabSwipeStartX = e.touches[0].clientX;
                tabSwipeStartY = e.touches[0].clientY;
                isTabSwiping = true;
            }, { passive: true });
            
            mainInterface.addEventListener('touchmove', (e) => {
                if (!isTabSwiping) return;
                
                const diffX = e.touches[0].clientX - tabSwipeStartX;
                const diffY = e.touches[0].clientY - tabSwipeStartY;
                
                // If scrolling vertically, cancel swipe
                if (Math.abs(diffY) > Math.abs(diffX)) {
                    isTabSwiping = false;
                }
            }, { passive: true });
            
            mainInterface.addEventListener('touchend', (e) => {
                if (!isTabSwiping) return;
                isTabSwiping = false;
                
                const diffX = e.changedTouches[0].clientX - tabSwipeStartX;
                const threshold = 100;
                
                // Get current tab
                const activeTab = document.querySelector('.tab-content.active');
                if (!activeTab) return;
                
                const currentTabId = activeTab.id.replace('Tab', '');
                const currentIndex = mobileTabs.indexOf(currentTabId);
                
                if (currentIndex === -1) return;
                
                // Swipe right = previous tab
                if (diffX > threshold && currentIndex > 0) {
                    const prevTab = mobileTabs[currentIndex - 1];
                    switchTab(prevTab);
                    showTabSwipeIndicator('←');
                }
                
                // Swipe left = next tab
                if (diffX < -threshold && currentIndex < mobileTabs.length - 1) {
                    const nextTab = mobileTabs[currentIndex + 1];
                    switchTab(nextTab);
                    showTabSwipeIndicator('→');
                }
            });
        }
        
        function showTabSwipeIndicator(direction) {
            // Brief visual feedback
            const indicator = document.createElement('div');
            indicator.className = 'tab-swipe-indicator';
            indicator.textContent = direction;
            document.body.appendChild(indicator);
            
            setTimeout(() => indicator.remove(), 300);
        }
        
        // Init on load
        document.addEventListener('DOMContentLoaded', initTabSwipeGestures);
        
        // =====================
        // PULL-TO-REFRESH (mobile)
        // =====================
        
        // Skeleton loading helpers
        let skeletonShown = false;
        
        function showSkeletonLoading() {
            // Показуємо skeleton тільки якщо контент порожній (перше завантаження)
            const mydayContent = document.getElementById('mydayContent');
            if (!mydayContent || mydayContent.children.length > 0) return;
            if (skeletonShown) return;
            skeletonShown = true;
            
            const skeletonHTML = Array.from({ length: 5 }, () => `
                <div class="skeleton-card">
                    <div class="skeleton-line long"></div>
                    <div class="skeleton-row" style="margin-top:0.3rem;">
                        <div class="skeleton-circle"></div>
                        <div class="skeleton-line short" style="margin:0;flex:1;"></div>
                    </div>
                </div>
            `).join('');
            
            mydayContent.innerHTML = `<div id="skeletonContainer">${skeletonHTML}</div>`;
        }
        
        function hideSkeletonLoading() {
            const skeleton = document.getElementById('skeletonContainer');
            if (skeleton) skeleton.remove();
            skeletonShown = false;
        }
        function initPullToRefresh() {
            const mainEl = document.getElementById('mainInterface');
            if (!mainEl || mainEl.dataset.ptrInit) return;
            mainEl.dataset.ptrInit = 'true';
            
            const indicator = document.getElementById('ptrIndicator');
            let startY = 0;
            let currentDeltaY = 0;
            let pulling = false;
            let refreshing = false;
            const threshold = 60;
            
            mainEl.addEventListener('touchstart', (e) => {
                if (refreshing) return;
                if (window.scrollY > 5) return;
                startY = e.touches[0].clientY;
                currentDeltaY = 0;
                pulling = true;
            }, { passive: true });
            
            mainEl.addEventListener('touchmove', (e) => {
                if (!pulling || refreshing) return;
                currentDeltaY = e.touches[0].clientY - startY;
                if (currentDeltaY > 20 && currentDeltaY < threshold * 2.5) {
                    indicator.classList.add('pulling');
                    indicator.classList.remove('refreshing');
                } else if (currentDeltaY <= 20) {
                    indicator.classList.remove('pulling');
                }
            }, { passive: true });
            
            mainEl.addEventListener('touchend', async () => {
                if (!pulling || refreshing) return;
                pulling = false;
                
                // Перевіряємо що реально потягнули достатньо (не випадковий тик)
                if (currentDeltaY >= threshold && indicator.classList.contains('pulling')) {
                    indicator.classList.remove('pulling');
                    indicator.classList.add('refreshing');
                    refreshing = true;
                    
                    try {
                        await loadAllData();
                    } catch (e) {
                        console.error('PTR refresh error:', e);
                    }
                    
                    indicator.classList.remove('refreshing');
                    refreshing = false;
                } else {
                    indicator.classList.remove('pulling');
                }
                currentDeltaY = 0;
            }, { passive: true });
        }
        
        document.addEventListener('DOMContentLoaded', initPullToRefresh);
        
        // =====================
        // OFFLINE SUPPORT
        // =====================
        let offlineData = {
            tasks: [],
            functions: [],
            users: [],
            regularTasks: []
        };
        
        // Save data to localStorage for offline access
        function saveOfflineData() {
            try {
                // Зберігаємо тільки потрібні поля — без description, timeLog, checklist
                // щоб не перевищити localStorage 5MB limit
                const trimmedTasks = tasks.map(t => ({
                    id: t.id,
                    title: t.title,
                    status: t.status,
                    assigneeId: t.assigneeId,
                    assigneeName: t.assigneeName,
                    creatorId: t.creatorId,
                    creatorName: t.creatorName,
                    deadlineDate: t.deadlineDate,
                    deadlineTime: t.deadlineTime,
                    deadline: t.deadline,
                    function: t.function,
                    priority: t.priority,
                    pinned: t.pinned,
                    estimatedTime: t.estimatedTime,
                    requireReview: t.requireReview,
                    processId: t.processId,
                    regularTaskId: t.regularTaskId,
                    autoGenerated: t.autoGenerated,
                    createdAt: t.createdAt
                }));
                
                offlineData = {
                    tasks: trimmedTasks,
                    functions: functions,
                    users: users,
                    regularTasks: regularTasks.map(rt => ({
                        id: rt.id,
                        title: rt.title,
                        function: rt.function,
                        period: rt.period,
                        daysOfWeek: rt.daysOfWeek,
                        dayOfWeek: rt.dayOfWeek,
                        dayOfMonth: rt.dayOfMonth,
                        timeStart: rt.timeStart,
                        estimatedTime: rt.estimatedTime
                    })),
                    lastSync: new Date().toISOString()
                };
                
                const json = JSON.stringify(offlineData);
                
                // Перевірка розміру перед записом (~5MB limit)
                if (json.length > 4 * 1024 * 1024) {
                    // Якщо все ще > 4MB — зберігаємо тільки останні 200 задач
                    offlineData.tasks = trimmedTasks.slice(0, 200);
                    localStorage.setItem('offlineData', JSON.stringify(offlineData));
                } else {
                    localStorage.setItem('offlineData', json);
                }
            } catch (e) {
                // QuotaExceededError — не блокуємо роботу, просто логуємо
                console.warn('saveOfflineData: localStorage full, skipping', e.name);
                try {
                    // Fallback: видаляємо offline дані щоб звільнити місце
                    localStorage.removeItem('offlineData');
                } catch (e2) { /* ignore */ }
            }
        }
        
        // Load offline data
        function loadOfflineData() {
            const saved = localStorage.getItem('offlineData');
            if (saved) {
                offlineData = JSON.parse(saved);
                return true;
            }
            return false;
        }
        
        // Check online status
        function isOnline() {
            return navigator.onLine;
        }
        
        // Show offline indicator
        function updateOnlineStatus() {
            let indicator = document.getElementById('offlineIndicator');
            
            if (!isOnline()) {
                if (!indicator) {
                    indicator = document.createElement('div');
                    indicator.id = 'offlineIndicator';
                    indicator.className = 'offline-indicator';
                    indicator.innerHTML = '<i data-lucide="wifi-off" class="icon icon-sm"></i> Офлайн режим';
                    document.body.appendChild(indicator);
                    refreshIcons();
                }
                indicator.classList.add('visible');
                
                // Load offline data
                if (loadOfflineData() && offlineData.tasks.length) {
                    tasks = offlineData.tasks;
                    functions = offlineData.functions;
                    users = offlineData.users;
                    regularTasks = offlineData.regularTasks;
                    renderTasks();
                }
            } else {
                if (indicator) {
                    indicator.classList.remove('visible');
                }
            }
        }
        
        // Auto-save data when loaded
        const originalLoadAllData = window.loadAllData;
        if (originalLoadAllData) {
            window.loadAllData = async function() {
                const result = await originalLoadAllData();
                if (isOnline()) {
                    saveOfflineData();
                }
                return result;
            };
        }
        
        // Listen for online/offline events
        window.addEventListener('online', () => {
            updateOnlineStatus();
            // Reload fresh data
            if (typeof loadAllData === 'function') {
                loadAllData();
            }
        });
        
        window.addEventListener('offline', updateOnlineStatus);
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Escape - закрити модалку
            if (e.key === 'Escape') {
                const modals = document.querySelectorAll('.modal');
                let closed = false;
                modals.forEach(modal => {
                    if (modal.style.display === 'block') {
                        closeModal(modal.id);
                        closed = true;
                    }
                });
                // Закрити quick menu
                closeTaskQuickMenu();
                // Закрити user-multiselect dropdown
                document.querySelectorAll('.user-ms-dropdown').forEach(d => { d.style.display = 'none'; resetDropdownPosition(d); });
                document.querySelectorAll('.user-ms-toggle').forEach(t => t.style.borderColor = '#d1d5db');
                return;
            }
            
            // Не обробляємо якщо фокус в input/textarea
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
                // Enter в формі - submit
                if (e.key === 'Enter' && !e.shiftKey && e.target.tagName !== 'TEXTAREA') {
                    const form = e.target.closest('form');
                    if (form) {
                        e.preventDefault();
                        form.dispatchEvent(new Event('submit', { cancelable: true }));
                    }
                }
                return;
            }
            
            // Ctrl/Cmd + shortcuts
            if (e.ctrlKey || e.metaKey) {
                switch(e.key.toLowerCase()) {
                    case 'n': // Нове завдання
                        e.preventDefault();
                        openTaskModal();
                        break;
                    case 'k': // Пошук
                        e.preventDefault();
                        const searchInp = document.getElementById('taskSearchInput');
                        if (searchInp) { switchTab('tasks'); setTimeout(() => searchInp.focus(), 100); }
                        break;
                    case 's': // Зберегти (prevent default browser save)
                        e.preventDefault();
                        break;
                }
                return;
            }
            
            // Shortcuts без модифікаторів (тільки коли немає відкритих модалок)
            const anyModalOpen = Array.from(document.querySelectorAll('.modal')).some(m => m.style.display === 'block');
            if (anyModalOpen) return;
            
            switch(e.key) {
                case '1':
                    switchTab('myday');
                    break;
                case '2':
                    switchTab('tasks');
                    break;
                case '3':
                    switchTab('control');
                    break;
                case '4':
                    switchTab('regular');
                    break;
                case '5':
                    switchTab('functions');
                    break;
                case '/':
                    e.preventDefault();
                    const si = document.getElementById('taskSearchInput');
                    if (si) { switchTab('tasks'); setTimeout(() => si.focus(), 100); }
                    break;
                case '?':
                    // Показати shortcuts help
                    alert(`Гарячі клавіші:
                    
Escape - закрити модалку
Ctrl+N - нове завдання
Ctrl+K або / - пошук завдань
1-5 - переключити вкладки
? - показати цю довідку`);
                    break;
            }
        });
        
        // Check on load
        document.addEventListener('DOMContentLoaded', updateOnlineStatus);
        
        // Periodic save (every 30 seconds)
        setInterval(() => {
            if (isOnline() && tasks.length > 0) {
                saveOfflineData();
            }
        }, 30000);
        
        // =====================
        // COMMENTS SYSTEM
        // =====================
        
        let currentTaskIdForComments = null;
        let commentsUnsubscribe = null;
        
        // Initialize comments when opening task modal for editing
        function initTaskComments(taskId) {
            currentTaskIdForComments = taskId;
            const section = document.getElementById('taskCommentsSection');
            
            if (!taskId) {
                // New task - hide comments
                section.classList.add('hidden');
                document.getElementById('taskHistorySection')?.classList.add('hidden');
                return;
            }
            
            // Show comments section for existing tasks
            section.classList.remove('hidden');
            loadComments(taskId);
            loadTaskFiles(taskId);
            
            // Load audit history
            loadTaskHistory(taskId);
            
            // Re-initialize lucide icons for comment section
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }
        
        // Load comments with real-time listener
        function loadComments(taskId) {
            const listEl = document.getElementById('commentsList');
            const countEl = document.getElementById('commentCount');
            
            // Unsubscribe from previous listener
            if (commentsUnsubscribe) {
                commentsUnsubscribe();
            }
            
            listEl.innerHTML = '<div class="comments-loading">Завантаження...</div>';
            
            // Real-time listener for comments
            commentsUnsubscribe = db.collection('companies').doc(currentCompany)
                .collection('tasks').doc(taskId)
                .collection('comments')
                .orderBy('createdAt', 'asc')
                .onSnapshot(snapshot => {
                    const comments = [];
                    snapshot.forEach(doc => {
                        comments.push({ id: doc.id, ...doc.data() });
                    });
                    
                    renderComments(comments);
                    countEl.textContent = comments.length;
                    
                    // Синхронізуємо denormalized count якщо розходиться
                    const localTask = tasks.find(t => t.id === taskId);
                    if (localTask && (localTask.commentCount || 0) !== comments.length) {
                        localTask.commentCount = comments.length;
                        db.collection('companies').doc(currentCompany)
                            .collection('tasks').doc(taskId)
                            .update({ commentCount: comments.length })
                            .catch(() => {});
                    }
                }, error => {
                    console.error('Error loading comments:', error);
                    listEl.innerHTML = '<div class="comments-empty">Помилка завантаження</div>';
                });
        }
        
        // Linkify — convert URLs to clickable links (after escaping HTML)
        function linkifyText(escapedText) {
            if (!escapedText) return '';
            // Match URLs in already-escaped text
            const urlRegex = /(https?:\/\/[^\s<>"']+)/gi;
            return escapedText.replace(urlRegex, function(url) {
                // Trim trailing punctuation that's likely not part of URL
                let cleanUrl = url.replace(/[.,;:!?)]+$/, '');
                let trailing = url.slice(cleanUrl.length);
                return `<a href="${cleanUrl}" target="_blank" rel="noopener noreferrer">${cleanUrl}</a>${trailing}`;
            });
        }
        
        // Render comments list
        function renderComments(comments) {
            const listEl = document.getElementById('commentsList');
            const currentUserId = currentUser?.uid;
            
            if (comments.length === 0) {
                listEl.innerHTML = `
                    <div class="comments-empty">
                        <div class="comments-empty-icon"><i data-lucide="message-circle" class="icon icon-xl"></i></div>
                        <span data-i18n="noComments">Ще немає коментарів</span>
                    </div>
                `;
                return;
            }
            
            listEl.innerHTML = comments.map(comment => {
                const isOwn = comment.authorId === currentUserId;
                const time = formatCommentTime(comment.createdAt);
                
                // Escape HTML first, then linkify URLs
                const safeText = linkifyText(escapeHtml(comment.text));
                
                return `
                    <div class="comment-item ${isOwn ? 'own-comment' : ''}">
                        <div class="comment-header">
                            <span class="comment-author">${escapeHtml(comment.authorName || 'Невідомий')}</span>
                            <span class="comment-time">${time}</span>
                        </div>
                        <div class="comment-text">${safeText}</div>
                    </div>
                `;
            }).join('');
            
            // Scroll to bottom
            listEl.scrollTop = listEl.scrollHeight;
        }
        
        // Format comment timestamp
        function formatCommentTime(timestamp) {
            if (!timestamp) return '';
            
            const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
            const now = new Date();
            const diff = now - date;
            
            // Less than 1 minute
            if (diff < 60000) return 'щойно';
            
            // Less than 1 hour
            if (diff < 3600000) {
                const mins = Math.floor(diff / 60000);
                return `${mins} хв тому`;
            }
            
            // Today
            if (date.toDateString() === now.toDateString()) {
                return date.toLocaleTimeString('uk-UA', { hour: '2-digit', minute: '2-digit' });
            }
            
            // Yesterday
            const yesterday = new Date(now);
            yesterday.setDate(yesterday.getDate() - 1);
            if (date.toDateString() === yesterday.toDateString()) {
                return 'вчора ' + date.toLocaleTimeString('uk-UA', { hour: '2-digit', minute: '2-digit' });
            }
            
            // Older
            return date.toLocaleDateString('uk-UA', { day: 'numeric', month: 'short' }) + 
                   ' ' + date.toLocaleTimeString('uk-UA', { hour: '2-digit', minute: '2-digit' });
        }
        
        // Send new comment
        async function sendComment() {
            const input = document.getElementById('commentInput');
            const btn = document.getElementById('sendCommentBtn');
            const text = input.value.trim();
            
            if (!text || !currentTaskIdForComments || !currentUser) return;
            
            btn.disabled = true;
            
            try {
                await db.collection('companies').doc(currentCompany)
                    .collection('tasks').doc(currentTaskIdForComments)
                    .collection('comments')
                    .add({
                        text: text,
                        authorId: currentUser.uid,
                        authorName: currentUserData?.name || currentUser.email,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                
                // Denormalized count — для відображення на картці без subcollection query
                db.collection('companies').doc(currentCompany)
                    .collection('tasks').doc(currentTaskIdForComments)
                    .update({ commentCount: firebase.firestore.FieldValue.increment(1) })
                    .catch(() => {}); // non-blocking
                
                // Оновлюємо локально
                const localTask = tasks.find(t => t.id === currentTaskIdForComments);
                if (localTask) localTask.commentCount = (localTask.commentCount || 0) + 1;
                
                input.value = '';
                input.style.height = 'auto';
            } catch (error) {
                console.error('Error sending comment:', error);
                showToast(t('commentSendError'), 'error');
            } finally {
                btn.disabled = false;
            }
        }
        
        // Handle Enter key in comment input
        function handleCommentKeydown(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendComment();
            }
        }
        
        // =============================================
        // AUDIT LOG — Логування змін задач
        // =============================================
        
        const AUDIT_FIELD_LABELS = {
            title: 'Назву', status: 'Статус', assigneeId: 'Виконавця',
            deadlineDate: 'Дедлайн', deadlineTime: 'Час', priority: 'Пріоритет',
            description: 'Опис', expectedResult: 'Очікуваний результат',
            projectId: 'Проєкт', 'function': 'Функцію', requireReview: 'Ревью',
            checklist: 'Чекліст', coExecutorIds: 'Співвиконавців', observerIds: 'Спостерігачів'
        };
        
        const AUDIT_ICONS = {
            created: { icon: '➕', bg: '#dcfce7' },
            status: { icon: '🔄', bg: '#dbeafe' },
            reassign: { icon: '👤', bg: '#e0e7ff' },
            deadline: { icon: '📅', bg: '#fef3c7' },
            edit: { icon: '✏️', bg: '#f3f4f6' },
            delete: { icon: '🗑️', bg: '#fee2e2' },
            complete: { icon: '✅', bg: '#dcfce7' },
            reopen: { icon: '🔓', bg: '#fef3c7' },
            review: { icon: '👁️', bg: '#e0e7ff' },
            escalation: { icon: '🚨', bg: '#fee2e2' }
        };
        
        const _logDebounce = new Map();
        
        async function logTaskChange(taskId, action, changes, oldTask) {
            if (!currentCompany || !taskId) return;
            
            // Debounce: same task + action within 2s = skip
            const dKey = taskId + '_' + action;
            const now = Date.now();
            if (_logDebounce.has(dKey) && now - _logDebounce.get(dKey) < 2000) return;
            _logDebounce.set(dKey, now);
            if (_logDebounce.size > 100) {
                for (const [k, v] of _logDebounce) { if (now - v > 10000) _logDebounce.delete(k); }
            }
            
            try {
                const entry = {
                    action: action,
                    userId: currentUserData?.id || '',
                    userName: currentUserData?.name || currentUserData?.email || 'Unknown',
                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    changes: changes || {}
                };
                
                // Зберігаємо старі та нові значення
                if (oldTask && changes) {
                    const details = {};
                    for (const field of Object.keys(changes)) {
                        details[field] = {
                            from: oldTask[field] ?? '',
                            to: changes[field] ?? ''
                        };
                    }
                    entry.details = details;
                }
                
                await db.collection('companies').doc(currentCompany)
                    .collection('tasks').doc(taskId)
                    .collection('history').add(entry);
            } catch (e) {
                console.warn('[AuditLog] Error:', e.message);
            }
        }
        
        async function loadTaskHistory(taskId) {
            const container = document.getElementById('historyList');
            const countEl = document.getElementById('historyCount');
            const section = document.getElementById('taskHistorySection');
            
            if (!container || !currentCompany || !taskId) return;
            
            section?.classList.remove('hidden');
            container.innerHTML = '<p style="color:var(--gray);text-align:center;font-size:0.85rem;padding:0.5rem;">Завантаження...</p>';
            
            try {
                const snap = await db.collection('companies').doc(currentCompany)
                    .collection('tasks').doc(taskId)
                    .collection('history')
                    .orderBy('timestamp', 'desc')
                    .limit(50)
                    .get();
                
                if (countEl) countEl.textContent = snap.size;
                
                if (snap.empty) {
                    container.innerHTML = '<p style="color:var(--gray);text-align:center;font-size:0.85rem;padding:1rem;">Ще немає записів</p>';
                    return;
                }
                
                let html = '';
                snap.forEach(doc => {
                    const entry = doc.data();
                    html += renderAuditEntry(entry);
                });
                container.innerHTML = html;
                
            } catch (e) {
                console.warn('[AuditLog] Load error:', e.message);
                container.innerHTML = '<p style="color:var(--gray);text-align:center;font-size:0.85rem;padding:1rem;">Помилка завантаження</p>';
            }
        }
        
        function renderAuditEntry(entry) {
            const iconData = AUDIT_ICONS[entry.action] || AUDIT_ICONS.edit;
            const time = entry.timestamp?.toDate?.() 
                ? entry.timestamp.toDate().toLocaleString('uk-UA', { day:'2-digit', month:'2-digit', hour:'2-digit', minute:'2-digit' })
                : '';
            
            let actionText = '';
            switch (entry.action) {
                case 'created': actionText = 'створив задачу'; break;
                case 'complete': actionText = 'завершив задачу'; break;
                case 'reopen': actionText = 'повернув задачу в роботу'; break;
                case 'review': actionText = 'прийняв задачу з ревью'; break;
                case 'delete': actionText = 'видалив задачу'; break;
                case 'escalation': actionText = 'ескалація прострочення'; break;
                default: actionText = formatChangeDetails(entry); break;
            }
            
            return `<div class="audit-entry">
                <div class="audit-icon" style="background:${iconData.bg}">${iconData.icon}</div>
                <div class="audit-body">
                    <div><span class="audit-user">${esc(entry.userName)}</span> <span class="audit-action">${actionText}</span></div>
                    <div class="audit-time">${time}</div>
                </div>
            </div>`;
        }
        
        function formatChangeDetails(entry) {
            if (!entry.details) return 'змінив задачу';
            const parts = [];
            for (const [field, vals] of Object.entries(entry.details)) {
                const label = AUDIT_FIELD_LABELS[field] || field;
                if (field === 'status') {
                    parts.push(`змінив статус: <span class="audit-value">${getStatusLabel(vals.from)}</span> → <span class="audit-value">${getStatusLabel(vals.to)}</span>`);
                } else if (field === 'assigneeId') {
                    const fromUser = users.find(u => u.id === vals.from);
                    const toUser = users.find(u => u.id === vals.to);
                    parts.push(`перепризначив: <span class="audit-value">${esc(fromUser?.name || vals.from || '—')}</span> → <span class="audit-value">${esc(toUser?.name || vals.to)}</span>`);
                } else if (field === 'deadlineDate' || field === 'deadlineTime') {
                    parts.push(`змінив ${label.toLowerCase()}: <span class="audit-value">${esc(vals.from || '—')}</span> → <span class="audit-value">${esc(String(vals.to))}</span>`);
                } else if (field === 'priority') {
                    parts.push(`змінив пріоритет: <span class="audit-value">${vals.from}</span> → <span class="audit-value">${vals.to}</span>`);
                } else {
                    parts.push(`змінив ${label.toLowerCase()}`);
                }
            }
            return parts.join(', ') || 'змінив задачу';
        }
        
        function getStatusLabel(status) {
            const map = { todo: 'Очікує', in_progress: 'В роботі', review: 'На перевірці', done: 'Виконано' };
            return map[status] || status || '—';
        }
        
        function toggleHistorySection() {
            const list = document.getElementById('historyList');
            const chevron = document.getElementById('historyChevron');
            if (!list) return;
            const isHidden = list.style.display === 'none';
            list.style.display = isHidden ? 'block' : 'none';
            if (chevron) chevron.style.transform = isHidden ? 'rotate(180deg)' : '';
        }
        
        // =============================================
        // CASCADING ESCALATION — Каскадна ескалація
        // =============================================
        
        const ESCALATION_LEVELS = [
            { days: 1, level: 1, label: 'Прострочено 1+ день', target: 'assignee', color: '#92400e' },
            { days: 3, level: 2, label: 'Прострочено 3+ дні', target: 'manager', color: '#9a3412' },
            { days: 7, level: 3, label: 'Прострочено 7+ днів', target: 'owner', color: '#dc2626' }
        ];
        
        function getEscalationLevel(task) {
            if (!task.deadlineDate || task.status === 'done') return null;
            
            const now = new Date();
            const deadline = new Date(task.deadlineDate + 'T' + (task.deadlineTime || '23:59'));
            const diffMs = now - deadline;
            if (diffMs <= 0) return null;
            
            const diffDays = diffMs / (1000 * 60 * 60 * 24);
            
            let level = null;
            for (const esc of ESCALATION_LEVELS) {
                if (diffDays >= esc.days) level = esc;
            }
            return level;
        }
        
        function getEscalationBadgeHtml(task) {
            const level = getEscalationLevel(task);
            if (!level) return '';
            return `<span class="escalation-badge escalation-${level.level}" title="${level.label}">🚨 ${level.label}</span>`;
        }
        
        async function checkEscalations() {
            if (!currentCompany) return;
            
            const overdueTasks = tasks.filter(t => {
                if (t.status === 'done') return false;
                const level = getEscalationLevel(t);
                return level && level.level >= 2;
            });
            
            if (overdueTasks.length === 0) return;
            
            // Групуємо по рівнях
            const level2 = overdueTasks.filter(t => getEscalationLevel(t)?.level === 2);
            const level3 = overdueTasks.filter(t => getEscalationLevel(t)?.level === 3);
            
            // Показуємо сповіщення для менеджерів та овнерів
            if (currentUserData?.role === 'owner' || currentUserData?.role === 'manager') {
                if (level3.length > 0) {
                    showToast(t('escalationCritical').replace('{n}', level3.length), 'error', 8000);
                } else if (level2.length > 0) {
                    showToast(t('escalationWarning').replace('{n}', level2.length), 'warning', 5000);
                }
            }
            
            // Логуємо ескалації які ще не логувались сьогодні
            const today = getLocalDateStr();
            for (const task of overdueTasks) {
                const level = getEscalationLevel(task);
                if (!level) continue;
                
                const lastEscKey = `esc_${task.id}_${level.level}_${today}`;
                if (sessionStorage.getItem(lastEscKey)) continue;
                
                await logTaskChange(task.id, 'escalation', {
                    level: level.level,
                    label: level.label,
                    overdueDays: Math.floor((new Date() - new Date(task.deadlineDate + 'T' + (task.deadlineTime || '23:59'))) / (1000 * 60 * 60 * 24))
                }, null);
                
                sessionStorage.setItem(lastEscKey, '1');
            }
        }
        
        // Auto-resize textarea
        document.addEventListener('DOMContentLoaded', () => {
            const textarea = document.getElementById('commentInput');
            if (textarea) {
                textarea.addEventListener('input', function() {
                    this.style.height = 'auto';
                    this.style.height = Math.min(this.scrollHeight, 120) + 'px';
                });
            }
        });
        
        // =====================
        // KANBAN BOARD (Status + Deadlines)
        // =====================
        
        function refreshCurrentView() {
            if (currentCalendarView === 'list') renderTasks();
            else if (currentCalendarView === 'kanban' || currentCalendarView === 'deadlines') renderKanbanBoard(currentCalendarView);
            else renderCalendar();
        }
        
        function renderKanbanBoard(mode) {
            const container = document.getElementById('kanbanContainer');
            if (!container) return;
            
            // Filter tasks same as list
            let filtered = tasks.filter(t => t.status !== 'done' || mode === 'kanban');
            
            // Apply current filters (same as list view)
            const funcF = document.getElementById('functionFilter')?.value;
            const assigneeF = document.getElementById('assigneeFilter')?.value;
            if (funcF) filtered = filtered.filter(t => t.functionId === funcF);
            if (assigneeF) filtered = filtered.filter(t => t.assigneeId === assigneeF);
            
            let columns;
            
            if (mode === 'kanban') {
                // STATUS KANBAN
                columns = [
                    { id: 'new', title: t('statusNew'), color: '#3b82f6', bg: '#eff6ff', tasks: [] },
                    { id: 'progress', title: t('statusProgress'), color: '#f59e0b', bg: '#fffbeb', tasks: [] },
                    { id: 'review', title: t('statusReview'), color: '#8b5cf6', bg: '#f5f3ff', tasks: [] },
                    { id: 'done', title: t('statusDone'), color: '#22c55e', bg: '#f0fdf4', tasks: [] }
                ];
                filtered.forEach(t => {
                    const col = columns.find(c => c.id === (t.status || 'new'));
                    if (col) col.tasks.push(t);
                    else columns[0].tasks.push(t);
                });
            } else {
                // DEADLINE KANBAN
                const today = getLocalDateStr();
                const todayD = new Date(today + 'T12:00:00');
                // End of this week = next Sunday (Ukrainian week: Mon-Sun)
                const dayOfWeek = todayD.getDay(); // 0=Sun
                const daysToSunday = dayOfWeek === 0 ? 0 : (7 - dayOfWeek);
                const endOfWeek = new Date(todayD);
                endOfWeek.setDate(endOfWeek.getDate() + daysToSunday);
                const endOfNextWeek = new Date(endOfWeek);
                endOfNextWeek.setDate(endOfNextWeek.getDate() + 7);
                const endWeekStr = endOfWeek.toISOString().split('T')[0];
                const endNextWeekStr = endOfNextWeek.toISOString().split('T')[0];
                
                columns = [
                    { id: 'overdue', title: 'Протерміновані', color: '#ef4444', bg: '#fef2f2', tasks: [] },
                    { id: 'today', title: 'На сьогодні', color: '#f59e0b', bg: '#fffbeb', tasks: [] },
                    { id: 'this_week', title: 'Цей тиждень', color: '#3b82f6', bg: '#eff6ff', tasks: [] },
                    { id: 'next_week', title: 'Наступний тиждень', color: '#8b5cf6', bg: '#f5f3ff', tasks: [] },
                    { id: 'later', title: 'Пізніше', color: '#06b6d4', bg: '#ecfeff', tasks: [] },
                    { id: 'no_deadline', title: 'Без терміну', color: '#6b7280', bg: '#f9fafb', tasks: [] }
                ];
                
                filtered.filter(t => t.status !== 'done').forEach(t => {
                    const dl = t.deadlineDate;
                    if (!dl) { columns[5].tasks.push(t); return; }
                    if (dl < today) columns[0].tasks.push(t);
                    else if (dl === today) columns[1].tasks.push(t);
                    else if (dl <= endWeekStr) columns[2].tasks.push(t);
                    else if (dl <= endNextWeekStr) columns[3].tasks.push(t);
                    else columns[4].tasks.push(t);
                });
            }
            
            let html = '<div class="kanban-board">';
            
            columns.forEach(col => {
                html += `<div class="kanban-column" data-col="${col.id}">
                    <div class="kanban-column-header" style="background:${col.bg};color:${col.color};border-bottom:2px solid ${col.color}">
                        <span>${col.title}</span>
                        <span class="kanban-column-count" style="color:${col.color}">${col.tasks.length}</span>
                    </div>
                    <div class="kanban-column-body" data-col="${col.id}" 
                         ondragover="kanbanDragOver(event)" ondragleave="kanbanDragLeave(event)" ondrop="kanbanDrop(event,'${mode}')">
                        <div class="kanban-add-btn" onclick="openTaskModalForKanban('${col.id}','${mode}')" 
                             style="text-align:center;padding:0.4rem;color:#9ca3af;cursor:pointer;font-size:0.8rem;border:1px dashed #d1d5db;border-radius:8px;">+ Додати</div>`;
                
                // Sort tasks: overdue first, then by deadline
                col.tasks.sort((a, b) => {
                    if (a.deadlineDate && b.deadlineDate) return a.deadlineDate.localeCompare(b.deadlineDate);
                    if (a.deadlineDate) return -1;
                    return 1;
                });
                
                const todayStr = getLocalDateStr();
                col.tasks.forEach(t => {
                    const assignee = companyUsers.find(u => u.id === t.assigneeId);
                    const assigneeName = assignee ? (assignee.displayName || assignee.email).split(' ')[0] : '';
                    const funcName = (companyFunctions.find(f => f.id === t.functionId) || {}).name || '';
                    const isOverdue = t.deadlineDate && t.deadlineDate < todayStr && t.status !== 'done';
                    const isToday = t.deadlineDate === todayStr;
                    const escalation = getEscalationLevel(t);
                    
                    let deadlineHtml = '';
                    if (t.deadlineDate) {
                        const d = new Date(t.deadlineDate + 'T12:00:00');
                        const dayMonth = d.toLocaleDateString('uk', {day:'numeric', month:'short'});
                        const color = isOverdue ? '#ef4444' : isToday ? '#f59e0b' : '#6b7280';
                        deadlineHtml = `<span style="color:${color}">📅 ${dayMonth}</span>`;
                    }
                    
                    let checkHtml = '';
                    if (t.checklist?.length) {
                        const done = t.checklist.filter(c => c.done).length;
                        checkHtml = `<span>☑ ${done}/${t.checklist.length}</span>`;
                    }
                    
                    let imgHtml = '';
                    if (t.attachments?.length) {
                        const img = t.attachments.find(a => a.type?.startsWith('image/'));
                        if (img && img.url && (img.url.startsWith('https://') || img.url.startsWith('data:image/'))) {
                            imgHtml = `<img src="${escapeHtml(img.url)}" style="width:100%;height:80px;object-fit:cover;border-radius:6px;margin-bottom:0.3rem;" onerror="this.remove()">`;
                        }
                    }
                    
                    let prioHtml = '';
                    if (t.priority === 'high') prioHtml = '<span class="kanban-card-badge" style="background:#fef2f2;color:#ef4444">🔴</span>';
                    else if (t.priority === 'medium') prioHtml = '<span class="kanban-card-badge" style="background:#fffbeb;color:#f59e0b">🟡</span>';
                    
                    let escalBadge = '';
                    if (escalation) {
                        const escColors = {1:'#fef3c7;color:#92400e',2:'#fed7aa;color:#9a3412',3:'#fee2e2;color:#dc2626'};
                        escalBadge = `<span class="kanban-card-badge" style="background:${escColors[escalation.level]}; font-size:0.65rem">${escalation.label}</span>`;
                    }
                    
                    let statusBadge = '';
                    if (mode === 'deadlines') {
                        const stColors = {new:'#eff6ff;color:#3b82f6', progress:'#fffbeb;color:#f59e0b', review:'#f5f3ff;color:#8b5cf6'};
                        const stLabels = {new:'Нове', progress:'В роботі', review:'Перевірка'};
                        if (stColors[t.status]) statusBadge = `<span class="kanban-card-badge" style="background:${stColors[t.status]};font-size:0.65rem">${stLabels[t.status]}</span>`;
                    }
                    
                    html += `<div class="kanban-card ${isOverdue?'overdue':''} ${isToday?'today':''}" 
                                  draggable="true" data-task-id="${t.id}"
                                  ondragstart="kanbanDragStart(event)" ondragend="kanbanDragEnd(event)"
                                  onclick="kanbanCardClick(event,'${t.id}')">
                        ${imgHtml}
                        <div class="kanban-card-title">${escapeHtml(t.title)}</div>
                        <div class="kanban-card-meta">
                            ${prioHtml}${escalBadge}${statusBadge}
                            ${deadlineHtml}${checkHtml}
                            ${funcName ? `<span style="background:#f0fdf4;color:#16a34a;padding:0.1rem 0.3rem;border-radius:4px">${escapeHtml(funcName)}</span>` : ''}
                            ${assigneeName ? `<span>👤 ${escapeHtml(assigneeName)}</span>` : ''}
                        </div>
                    </div>`;
                });
                
                html += '</div></div>';
            });
            
            html += '</div>';
            container.innerHTML = html;
            
            // Attach touch events for mobile drag
            const board = container.querySelector('.kanban-board');
            if (board) {
                board.addEventListener('touchstart', kanbanTouchStart, { passive: true });
                board.addEventListener('touchmove', kanbanTouchMove, { passive: false });
                board.addEventListener('touchend', kanbanTouchEnd, { passive: true });
            }
        }
        
        // Kanban Drag & Drop
        let kanbanDraggedId = null;
        let kanbanWasDragged = false;
        
        function kanbanDragStart(e) {
            kanbanDraggedId = e.target.closest('.kanban-card')?.dataset.taskId;
            if (!kanbanDraggedId) return;
            kanbanWasDragged = false;
            e.target.closest('.kanban-card').classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', kanbanDraggedId);
        }
        function kanbanDragEnd(e) {
            kanbanWasDragged = true;
            e.target.classList.remove('dragging');
            document.querySelectorAll('.kanban-column-body').forEach(b => b.classList.remove('drag-over'));
            // Reset flag after click event would fire
            setTimeout(() => { kanbanWasDragged = false; }, 50);
        }
        function kanbanCardClick(e, taskId) {
            if (kanbanWasDragged) { e.stopPropagation(); return; }
            if (kanbanTouchMoved) { e.stopPropagation(); return; }
            openEditTask(taskId);
        }
        function kanbanDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('drag-over');
        }
        function kanbanDragLeave(e) {
            e.currentTarget.classList.remove('drag-over');
        }
        
        // Mobile touch drag & drop
        let kanbanTouchCard = null;
        let kanbanTouchClone = null;
        let kanbanTouchStartY = 0;
        let kanbanTouchMoved = false;
        
        function kanbanTouchStart(e) {
            const card = e.target.closest('.kanban-card');
            if (!card) return;
            kanbanTouchCard = card;
            kanbanTouchStartY = e.touches[0].clientY;
            kanbanTouchMoved = false;
            kanbanDraggedId = card.dataset.taskId;
        }
        
        function kanbanTouchMove(e) {
            if (!kanbanTouchCard) return;
            const dy = Math.abs(e.touches[0].clientY - kanbanTouchStartY);
            if (dy < 10 && !kanbanTouchMoved) return; // threshold
            kanbanTouchMoved = true;
            e.preventDefault();
            
            if (!kanbanTouchClone) {
                kanbanTouchClone = kanbanTouchCard.cloneNode(true);
                kanbanTouchClone.style.cssText = 'position:fixed;z-index:9999;opacity:0.8;pointer-events:none;width:250px;transform:rotate(2deg);';
                document.body.appendChild(kanbanTouchClone);
                kanbanTouchCard.classList.add('dragging');
            }
            kanbanTouchClone.style.left = (e.touches[0].clientX - 125) + 'px';
            kanbanTouchClone.style.top = (e.touches[0].clientY - 30) + 'px';
            
            // Highlight column under touch
            document.querySelectorAll('.kanban-column-body').forEach(b => b.classList.remove('drag-over'));
            const el = document.elementFromPoint(e.touches[0].clientX, e.touches[0].clientY);
            const colBody = el?.closest('.kanban-column-body');
            if (colBody) colBody.classList.add('drag-over');
        }
        
        function kanbanTouchEnd(e) {
            if (!kanbanTouchCard) return;
            if (kanbanTouchClone) {
                kanbanTouchClone.remove();
                kanbanTouchClone = null;
            }
            kanbanTouchCard.classList.remove('dragging');
            document.querySelectorAll('.kanban-column-body').forEach(b => b.classList.remove('drag-over'));
            
            if (kanbanTouchMoved && kanbanDraggedId) {
                const touch = e.changedTouches[0];
                const el = document.elementFromPoint(touch.clientX, touch.clientY);
                const colBody = el?.closest('.kanban-column-body');
                if (colBody) {
                    const mode = currentCalendarView;
                    kanbanDrop({ preventDefault(){}, currentTarget: colBody }, mode);
                }
            }
            kanbanTouchCard = null;
            kanbanTouchMoved = false;
        }
        let kanbanDropLock = false;
        async function kanbanDrop(e, mode) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');
            if (!kanbanDraggedId || kanbanDropLock) return;
            kanbanDropLock = true;
            
            const targetCol = e.currentTarget.dataset.col;
            const task = tasks.find(t => t.id === kanbanDraggedId);
            if (!task) { kanbanDropLock = false; return; }
            
            // Permission check: owner/admin/manager can move any, employee only own
            const role = currentUserData?.role;
            const canMove = role === 'owner' || role === 'admin' || role === 'manager' 
                || task.assigneeId === currentUser.uid || task.creatorId === currentUser.uid;
            if (!canMove) {
                showToast(t('noPermissionTask'), 'error');
                kanbanDropLock = false; return;
            }
            
            if (mode === 'kanban') {
                // STATUS DRAG: change status
                const oldStatus = task.status;
                if (targetCol === oldStatus) { kanbanDropLock = false; return; }
                
                // Якщо тягнуть в done, але задача потребує review — перенаправляємо в review
                let effectiveTarget = targetCol;
                if (targetCol === 'done' && shouldSendForReview(task)) {
                    effectiveTarget = 'review';
                }
                
                try {
                    const ref = db.collection(`companies/${currentCompany}/tasks`).doc(task.id);
                    const upd = { status: effectiveTarget, updatedAt: firebase.firestore.FieldValue.serverTimestamp() };
                    if (effectiveTarget === 'done') {
                        upd.completedAt = firebase.firestore.FieldValue.serverTimestamp();
                        upd.completedBy = currentUser.uid;
                    } else {
                        upd.completedAt = null;
                    }
                    if (effectiveTarget === 'review') {
                        upd.sentForReviewAt = firebase.firestore.FieldValue.serverTimestamp();
                    }
                    await ref.update(upd);
                    await logTaskChange(task.id, 'status', { from: oldStatus, to: effectiveTarget });
                    task.status = effectiveTarget;
                    if (effectiveTarget === 'done') { 
                        task.completedAt = new Date(); 
                        task.completedBy = currentUser.uid;
                        advanceProcessIfLinked(task.id);
                        if (task.projectId) autoUpdateProjectStatus(task.projectId);
                    }
                    if (effectiveTarget === 'review') {
                        task.sentForReviewAt = new Date().toISOString();
                        showToast(t('taskSentForReview'), 'info');
                    }
                    if (effectiveTarget === 'progress' && task.projectId) autoUpdateProjectStatus(task.projectId);
                    showToast(`${t('statusesLabel')} → ${effectiveTarget === 'done' ? t('statusDone') : effectiveTarget === 'review' ? t('statusReview') : effectiveTarget === 'progress' ? t('statusProgress') : t('statusNew')}`, 'success');
                } catch(err) {
                    console.error('Kanban status drop error:', err);
                    showToast(t('error'), 'error');
                    kanbanDropLock = false; return;
                }
            } else {
                // DEADLINE DRAG: change deadline
                const today = getLocalDateStr();
                const todayD = new Date(today);
                let newDeadline = null;
                
                if (targetCol === 'today') {
                    newDeadline = today;
                } else if (targetCol === 'this_week') {
                    const fri = new Date(todayD);
                    fri.setDate(fri.getDate() + (5 - fri.getDay() + 7) % 7);
                    if (fri <= todayD) fri.setDate(fri.getDate() + 7);
                    newDeadline = fri.toISOString().split('T')[0];
                } else if (targetCol === 'next_week') {
                    const nextMon = new Date(todayD);
                    nextMon.setDate(nextMon.getDate() + (8 - nextMon.getDay()) % 7);
                    if (nextMon <= todayD) nextMon.setDate(nextMon.getDate() + 7);
                    const nextFri = new Date(nextMon);
                    nextFri.setDate(nextFri.getDate() + 4);
                    newDeadline = nextFri.toISOString().split('T')[0];
                } else if (targetCol === 'later') {
                    // Set to 2 weeks from today (Friday)
                    const laterDate = new Date(todayD);
                    laterDate.setDate(laterDate.getDate() + 14);
                    newDeadline = laterDate.toISOString().split('T')[0];
                } else if (targetCol === 'no_deadline') {
                    newDeadline = null;
                } else if (targetCol === 'overdue') {
                    kanbanDropLock = false; return; // cant drag TO overdue
                }
                
                const oldDl = task.deadlineDate || null;
                try {
                    const ref = db.collection(`companies/${currentCompany}/tasks`).doc(task.id);
                    await ref.update({ deadlineDate: newDeadline || firebase.firestore.FieldValue.delete(), updatedAt: firebase.firestore.FieldValue.serverTimestamp() });
                    await logTaskChange(task.id, 'edit', { field: 'deadlineDate', from: oldDl, to: newDeadline });
                    task.deadlineDate = newDeadline;
                    showToast(newDeadline ? `Дедлайн → ${newDeadline}` : 'Дедлайн знято', 'success');
                } catch(err) {
                    console.error('Kanban deadline drop error:', err);
                    showToast(t('deadlineChangeError'), 'error');
                    kanbanDropLock = false; return;
                }
            }
            
            renderKanbanBoard(mode);
            kanbanDropLock = false;
        }
        
        function openTaskModalForKanban(colId, mode) {
            openAddTask();
            // Pre-set based on column
            setTimeout(() => {
                if (mode === 'kanban') {
                    // set status after save? Not needed — new tasks always 'new'
                } else {
                    const today = getLocalDateStr();
                    const todayD = new Date(today);
                    let dl = '';
                    if (colId === 'today') dl = today;
                    else if (colId === 'this_week') {
                        const fri = new Date(todayD);
                        fri.setDate(fri.getDate() + (5 - fri.getDay() + 7) % 7);
                        dl = fri.toISOString().split('T')[0];
                    } else if (colId === 'next_week') {
                        // Find next Monday, then +4 for Friday
                        const nextMon = new Date(todayD);
                        nextMon.setDate(nextMon.getDate() + (8 - nextMon.getDay()) % 7);
                        if (nextMon <= todayD) nextMon.setDate(nextMon.getDate() + 7);
                        const nextFri = new Date(nextMon);
                        nextFri.setDate(nextFri.getDate() + 4);
                        dl = nextFri.toISOString().split('T')[0];
                    }
                    if (dl) {
                        const deadlineInput = document.getElementById('taskDeadlineDate');
                        if (deadlineInput) deadlineInput.value = dl;
                    }
                }
            }, 100);
        }
        
        // Escape HTML for security
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // =====================
        // FILE ATTACHMENTS
        // =====================
        
        const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10 MB
        const ALLOWED_EXTENSIONS = ['pdf','doc','docx','xls','xlsx','png','jpg','jpeg','gif','webp','zip','txt','csv'];
        
        function getFileIconClass(filename) {
            const ext = (filename || '').split('.').pop().toLowerCase();
            if (['pdf'].includes(ext)) return 'pdf';
            if (['doc', 'docx', 'txt'].includes(ext)) return 'doc';
            if (['xls', 'xlsx', 'csv'].includes(ext)) return 'xls';
            if (['png', 'jpg', 'jpeg', 'gif', 'webp'].includes(ext)) return 'img';
            return 'other';
        }
        
        function getFileIconLabel(filename) {
            const ext = (filename || '').split('.').pop().toUpperCase();
            return ext.slice(0, 4);
        }
        
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' Б';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' КБ';
            return (bytes / (1024 * 1024)).toFixed(1) + ' МБ';
        }
        
        function isImageFile(filename) {
            const ext = (filename || '').split('.').pop().toLowerCase();
            return ['png', 'jpg', 'jpeg', 'gif', 'webp'].includes(ext);
        }
        
        // Load and render files for a task
        function loadTaskFiles(taskId) {
            if (!taskId) {
                document.getElementById('taskFilesList').innerHTML = '';
                document.getElementById('fileCount').textContent = '0';
                return;
            }
            
            const task = tasks.find(t => t.id === taskId);
            const files = task?.files || [];
            renderTaskFiles(files);
        }
        
        function renderTaskFiles(files) {
            const listEl = document.getElementById('taskFilesList');
            const countEl = document.getElementById('fileCount');
            
            countEl.textContent = files.length;
            
            if (files.length === 0) {
                listEl.innerHTML = '';
                return;
            }
            
            // Визначаємо creatorId задачі для мітки
            const task = editingId ? tasks.find(t => t.id === editingId) : null;
            const taskCreatorId = task?.creatorId;
            
            listEl.innerHTML = files.map((file, index) => {
                const iconClass = getFileIconClass(file.name);
                const iconLabel = getFileIconLabel(file.name);
                const isImg = isImageFile(file.name);
                const canDelete = currentUserData?.role !== 'employee' || 
                                  file.uploadedBy === currentUser?.uid;
                
                // Мітка: постановник = ТЗ, виконавець = Результат
                const isCreatorFile = file.uploadedBy === taskCreatorId;
                const roleBadge = isCreatorFile
                    ? '<span class="file-role-badge creator">ТЗ</span>'
                    : '<span class="file-role-badge executor">Результат</span>';
                
                return `
                    <div class="task-file-item ${isImg ? 'image-preview' : ''}">
                        <div class="file-preview-row">
                            <div class="task-file-icon ${iconClass}">${iconLabel}</div>
                            <div class="task-file-info">
                                <div class="task-file-name" title="${esc(file.name)}">${roleBadge} ${esc(file.name)}</div>
                                <div class="task-file-meta">
                                    <span>${formatFileSize(file.size || 0)}</span>
                                    <span>${esc(file.uploadedByName || '')}</span>
                                    ${file.uploadedAt ? `<span>${formatCommentTime(file.uploadedAt)}</span>` : ''}
                                </div>
                            </div>
                            <div class="task-file-actions">
                                <button onclick="downloadTaskFile('${escId(file.url)}')" title="Завантажити">
                                    <i data-lucide="download" class="icon icon-sm"></i>
                                </button>
                                ${canDelete ? `<button class="delete-file" onclick="deleteTaskFile(${index})" title="Видалити">
                                    <i data-lucide="trash-2" class="icon icon-sm"></i>
                                </button>` : ''}
                            </div>
                        </div>
                        ${isImg ? `<img src="${esc(file.url)}" class="file-preview-img" alt="${esc(file.name)}" onclick="window.open('${escId(file.url)}', '_blank')" loading="lazy">` : ''}
                    </div>
                `;
            }).join('');
            
            refreshIcons();
        }
        
        function downloadTaskFile(url) {
            window.open(url, '_blank');
        }
        
        async function deleteTaskFile(fileIndex) {
            if (!editingId) return;
            if (!confirm(t('deleteFileConfirm'))) return;
            
            const task = tasks.find(t => t.id === editingId);
            if (!task || !task.files || !task.files[fileIndex]) return;
            
            const file = task.files[fileIndex];
            
            try {
                // Delete from Storage
                if (file.storagePath) {
                    try {
                        await storage.ref(file.storagePath).delete();
                    } catch (e) {
                        console.warn('Storage delete failed (file may not exist):', e);
                    }
                }
                
                // Remove from task
                const updatedFiles = [...task.files];
                updatedFiles.splice(fileIndex, 1);
                
                await db.collection('companies').doc(currentCompany)
                    .collection('tasks').doc(editingId)
                    .update({ files: updatedFiles });
                
                task.files = updatedFiles;
                renderTaskFiles(updatedFiles);
                showToast(t('fileDeleted'), 'success');
            } catch (error) {
                console.error('deleteTaskFile error:', error);
                showToast(t('fileDeleteError'), 'error');
            }
        }
        
        function handleFileDrop(e) {
            e.preventDefault();
            const files = e.dataTransfer?.files;
            if (files && files.length > 0) {
                uploadFiles(files);
            }
        }
        
        function handleFileSelect(e) {
            const files = e.target.files;
            if (files && files.length > 0) {
                uploadFiles(files);
            }
            // Reset input so same file can be selected again
            e.target.value = '';
        }
        
        async function uploadFiles(fileList) {
            if (!editingId || !currentCompany || !currentUser) {
                showToast(t('saveTaskBeforeFiles'), 'warning');
                return;
            }
            
            const filesToUpload = Array.from(fileList);
            
            // Validate
            for (const file of filesToUpload) {
                if (file.size > MAX_FILE_SIZE) {
                    showToast(t('fileTooBig').replace('{name}', file.name), 'error');
                    return;
                }
                const ext = file.name.split('.').pop().toLowerCase();
                if (!ALLOWED_EXTENSIONS.includes(ext)) {
                    showToast(t('fileTypeNotSupported').replace('{ext}', ext), 'error');
                    return;
                }
            }
            
            const progressEl = document.getElementById('fileUploadProgress');
            const progressFill = document.getElementById('fileProgressFill');
            const progressText = document.getElementById('fileProgressText');
            progressEl.style.display = 'block';
            
            const task = tasks.find(t => t.id === editingId);
            const existingFiles = task?.files || [];
            const newFiles = [];
            
            try {
                for (let i = 0; i < filesToUpload.length; i++) {
                    const file = filesToUpload[i];
                    progressText.textContent = `Завантаження ${i + 1}/${filesToUpload.length}: ${file.name}`;
                    progressFill.style.width = '10%';
                    
                    // Generate unique path
                    const timestamp = Date.now();
                    const safeName = file.name.replace(/[^a-zA-Z0-9._-]/g, '_');
                    const storagePath = `companies/${currentCompany}/tasks/${editingId}/${timestamp}_${safeName}`;
                    
                    const storageRef = storage.ref(storagePath);
                    
                    // Upload with progress tracking
                    const uploadTask = storageRef.put(file);
                    
                    await new Promise((resolve, reject) => {
                        uploadTask.on('state_changed',
                            (snapshot) => {
                                const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
                                progressFill.style.width = progress + '%';
                            },
                            (error) => reject(error),
                            () => resolve()
                        );
                    });
                    
                    // Get download URL
                    const url = await storageRef.getDownloadURL();
                    
                    newFiles.push({
                        name: file.name,
                        size: file.size,
                        type: file.type,
                        url: url,
                        storagePath: storagePath,
                        uploadedBy: currentUser.uid,
                        uploadedByName: currentUserData?.name || currentUser.email,
                        uploadedAt: new Date().toISOString()
                    });
                }
                
                // Save to Firestore
                const allFiles = [...existingFiles, ...newFiles];
                await db.collection('companies').doc(currentCompany)
                    .collection('tasks').doc(editingId)
                    .update({ files: allFiles });
                
                // Update local
                if (task) task.files = allFiles;
                renderTaskFiles(allFiles);
                
                progressFill.style.width = '100%';
                progressText.textContent = `Завантажено ${newFiles.length} файл(ів)`;
                
                setTimeout(() => {
                    progressEl.style.display = 'none';
                    progressFill.style.width = '0%';
                }, 2000);
                
                showToast(t('filesUploaded').replace('{n}', newFiles.length), 'success');
                
            } catch (error) {
                console.error('uploadFiles error:', error);
                progressEl.style.display = 'none';
                showToast(t('fileUploadError') + ': ' + error.message, 'error');
            }
        }
        
        // Clean up comments listener when closing modal
        const originalCloseModal = window.closeModal;
        window.closeModal = function(modalId) {
            if (modalId === 'taskModal') {
                if (commentsUnsubscribe) {
                    commentsUnsubscribe();
                    commentsUnsubscribe = null;
                    currentTaskIdForComments = null;
                }
                // Зупиняємо time tracker
                if (timeTrackerInterval) {
                    stopTimeTracker();
                }
            }
            if (originalCloseModal) {
                originalCloseModal(modalId);
            }
        };

    // =====================
    // COMPLETION REPORT — підтвердження виконання
    // =====================
    let completionReportTaskId = null;
    let completionReportCallback = null;
    
    function requiresCompletionReport(task) {
        if (!task) return false;
        return !!(task.reportFormat || task.expectedResult);
    }
    
    function showCompletionReport(taskId, callback) {
        const task = tasks.find(t => t.id === taskId);
        if (!task) { callback(); return; }
        
        completionReportTaskId = taskId;
        completionReportCallback = callback;
        
        const body = document.getElementById('completionReportBody');
        
        let html = '';
        
        if (task.expectedResult) {
            html += `<div style="margin-bottom:1rem;padding:0.75rem;background:#f0fdf4;border-radius:10px;border-left:3px solid #22c55e;">
                <div style="font-size:0.7rem;font-weight:600;color:#16a34a;text-transform:uppercase;letter-spacing:0.5px;margin-bottom:0.3rem;">Очікуваний результат</div>
                <div style="font-size:0.85rem;color:#1a1a1a;">${esc(task.expectedResult)}</div>
            </div>`;
        }
        
        if (task.reportFormat) {
            html += `<div style="margin-bottom:1rem;padding:0.75rem;background:#fffbeb;border-radius:10px;border-left:3px solid #f59e0b;">
                <div style="font-size:0.7rem;font-weight:600;color:#92400e;text-transform:uppercase;letter-spacing:0.5px;margin-bottom:0.3rem;">Формат звіту</div>
                <div style="font-size:0.85rem;color:#1a1a1a;">${esc(task.reportFormat)}</div>
            </div>`;
        }
        
        html += `<div style="margin-top:0.75rem;">
            <label style="font-size:0.8rem;font-weight:600;color:#374151;display:block;margin-bottom:0.4rem;">Коментар до виконання (необов'язково)</label>
            <textarea id="completionReportText" style="width:100%;min-height:60px;border:1px solid #e5e7eb;border-radius:10px;padding:0.6rem;font-size:0.85rem;resize:vertical;font-family:inherit;" placeholder="Що було зроблено, результат..."></textarea>
        </div>`;
        
        body.innerHTML = html;
        document.getElementById('completionReportModal').style.display = 'block';
    }
    
    function closeCompletionReport(proceed) {
        closeModal('completionReportModal');
        if (!proceed && completionReportCallback) {
            // Cancelled — rollback optimistic update
            completingTaskIds.delete(completionReportTaskId);
            const taskIndex = tasks.findIndex(t => t.id === completionReportTaskId);
            if (taskIndex >= 0) {
                tasks[taskIndex].status = tasks[taskIndex]._prevStatus || 'progress';
                delete tasks[taskIndex]._prevStatus;
                renderMyDay();
                refreshCurrentView();
            }
        }
        completionReportTaskId = null;
        completionReportCallback = null;
    }
    
    async function submitCompletionReport() {
        const text = document.getElementById('completionReportText')?.value?.trim() || '';
        const taskId = completionReportTaskId;
        const callback = completionReportCallback;
        
        // Save completion note as comment
        if (text && taskId) {
            try {
                await db.collection('companies').doc(currentCompany)
                    .collection('tasks').doc(taskId)
                    .collection('comments').add({
                        text: '[Звіт] ' + text,
                        authorId: currentUser.uid,
                        authorName: currentUserData?.name || currentUser.email,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                // Also save as completionNote on task
                await db.collection('companies').doc(currentCompany)
                    .collection('tasks').doc(taskId)
                    .update({ completionNote: text });
            } catch(e) {
                console.error('Save completion note error:', e);
            }
        }
        
        closeModal('completionReportModal');
        
        // Proceed with actual completion
        if (callback) callback();
        completionReportTaskId = null;
        completionReportCallback = null;
    }

    // =====================
    // NOTIFICATION CENTER
    // =====================
    let notifications = [];
    let notificationPanelOpen = false;
    const MAX_NOTIFICATIONS = 50;
    
    function addNotification(type, title, body, taskId) {
        const notif = {
            id: Date.now() + '_' + Math.random().toString(36).substr(2, 5),
            type, // 'new_task', 'completed', 'review', 'rejected', 'process'
            title,
            body,
            taskId: taskId || null,
            time: new Date(),
            read: false
        };
        // Dedup: skip if same type+body within 3s
        const isDupe = notifications.some(n => n.type === notif.type && n.body === notif.body && (notif.time - n.time) < 3000);
        if (isDupe) return;
        notifications.unshift(notif);
        if (notifications.length > MAX_NOTIFICATIONS) notifications.pop();
        updateNotificationBadge();
        renderNotificationList();
    }
    
    function updateNotificationBadge() {
        const badge = document.getElementById('notificationBadge');
        const bell = document.getElementById('notificationBell');
        if (!badge || !bell) return;
        
        const unread = notifications.filter(n => !n.read).length;
        if (unread > 0) {
            badge.style.display = 'flex';
            badge.textContent = unread > 99 ? '99+' : unread;
            bell.style.background = 'rgba(239,68,68,0.08)';
        } else {
            badge.style.display = 'none';
            bell.style.background = 'transparent';
        }
    }
    
    function toggleNotificationPanel() {
        const panel = document.getElementById('notificationPanel');
        notificationPanelOpen = !notificationPanelOpen;
        panel.style.display = notificationPanelOpen ? 'flex' : 'none';
        if (notificationPanelOpen) renderNotificationList();
    }
    
    function markAllNotificationsRead() {
        notifications.forEach(n => n.read = true);
        updateNotificationBadge();
        renderNotificationList();
    }
    
    function renderNotificationList() {
        const list = document.getElementById('notificationList');
        if (!list) return;
        
        if (notifications.length === 0) {
            list.innerHTML = '<div style="text-align:center;color:#9ca3af;padding:2rem;font-size:0.85rem;">Немає сповіщень</div>';
            return;
        }
        
        const icons = {
            new_task: { color: '#3b82f6', svg: '<path d="M12 5v14M5 12h14"/>' },
            completed: { color: '#22c55e', svg: '<path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/>' },
            review: { color: '#8b5cf6', svg: '<circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/>' },
            rejected: { color: '#f59e0b', svg: '<path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/>' },
            process: { color: '#10b981', svg: '<line x1="6" y1="3" x2="6" y2="15"/><circle cx="18" cy="6" r="3"/><circle cx="6" cy="18" r="3"/><path d="M18 9a9 9 0 0 1-9 9"/>' }
        };
        
        const now = new Date();
        
        list.innerHTML = notifications.map(n => {
            const icon = icons[n.type] || icons.new_task;
            const ago = getTimeAgo(n.time, now);
            const unreadDot = n.read ? '' : '<div style="width:8px;height:8px;background:#3b82f6;border-radius:50%;flex-shrink:0;"></div>';
            
            const taskArg = n.taskId ? ", '" + n.taskId + "'" : '';
            return `<div style="display:flex;gap:10px;align-items:flex-start;padding:0.7rem 1.25rem;cursor:pointer;${n.read ? 'opacity:0.6;' : ''}border-bottom:1px solid #f9fafb;" onclick="onNotificationClick('${n.id}'${taskArg})">
                <div style="width:32px;height:32px;border-radius:8px;background:${icon.color}12;display:flex;align-items:center;justify-content:center;flex-shrink:0;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="${icon.color}" stroke-width="2">${icon.svg}</svg>
                </div>
                <div style="flex:1;min-width:0;">
                    <div style="font-size:0.8rem;font-weight:600;color:#1a1a1a;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${esc(n.title)}</div>
                    <div style="font-size:0.75rem;color:#6b7280;margin-top:2px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${esc(n.body)}</div>
                    <div style="font-size:0.65rem;color:#9ca3af;margin-top:3px;">${ago}</div>
                </div>
                ${unreadDot}
            </div>`;
        }).join('');
    }
    
    function onNotificationClick(notifId, taskId) {
        // Mark as read
        const n = notifications.find(x => x.id === notifId);
        if (n) n.read = true;
        updateNotificationBadge();
        renderNotificationList();
        
        // Open task if available
        if (taskId) {
            toggleNotificationPanel();
            openTaskModal(taskId);
        }
    }
    
    function getTimeAgo(date, now) {
        const diff = Math.floor((now - new Date(date)) / 1000);
        if (diff < 60) return 'щойно';
        if (diff < 3600) return Math.floor(diff / 60) + ' хв тому';
        if (diff < 86400) return Math.floor(diff / 3600) + ' год тому';
        return Math.floor(diff / 86400) + ' дн тому';
    }
    
    // Close panel on outside click
    document.addEventListener('click', (e) => {
        if (notificationPanelOpen && !e.target.closest('#notificationPanel') && !e.target.closest('#notificationBell')) {
            notificationPanelOpen = false;
            document.getElementById('notificationPanel').style.display = 'none';
        }
    });



    // ====== MERGED FROM SCRIPT 3 ======
    // Service Worker registration + PWA Install
    let deferredInstallPrompt = null;
    
    window.addEventListener('beforeinstallprompt', (e) => {
        e.preventDefault();
        deferredInstallPrompt = e;
        showInstallBanner();
    });
    
    function showInstallBanner() {
        // Не показуємо якщо вже встановлено або якщо банер вже є
        if (window.matchMedia('(display-mode: standalone)').matches) return;
        if (document.getElementById('pwaInstallBanner')) return;
        
        const banner = document.createElement('div');
        banner.id = 'pwaInstallBanner';
        banner.innerHTML = `
            <div style="position:fixed;bottom:70px;left:50%;transform:translateX(-50%);
                background:linear-gradient(135deg,#1a1a1a,#2d2d2d);color:white;
                padding:14px 20px;border-radius:16px;display:flex;align-items:center;gap:14px;
                box-shadow:0 12px 40px rgba(0,0,0,0.4);z-index:10000;max-width:420px;width:calc(100% - 32px);
                border:1px solid rgba(255,255,255,0.1);animation:slideUpBanner 0.3s ease;">
                <img src="icons/icon-96x96.png" style="width:44px;height:44px;border-radius:10px;flex-shrink:0;">
                <div style="flex:1;min-width:0;">
                    <div style="font-weight:600;font-size:0.95rem;">Встановити TALKO Tasks</div>
                    <div style="font-size:0.8rem;color:rgba(255,255,255,0.7);">Додати на головний екран</div>
                </div>
                <button onclick="installPWA()" style="background:#22c55e;color:white;border:none;padding:10px 18px;
                    border-radius:10px;font-weight:600;cursor:pointer;font-size:0.85rem;white-space:nowrap;flex-shrink:0;">
                    Додати
                </button>
                <button onclick="dismissInstallBanner()" style="background:none;border:none;color:rgba(255,255,255,0.5);
                    cursor:pointer;font-size:1.2rem;padding:4px;flex-shrink:0;">✕</button>
            </div>
        `;
        document.body.appendChild(banner);
    }
    
    function installPWA() {
        if (!deferredInstallPrompt) return;
        deferredInstallPrompt.prompt();
        deferredInstallPrompt.userChoice.then(result => {
            if (result.outcome === 'accepted') {
                console.log('[PWA] Installed');
            }
            deferredInstallPrompt = null;
            dismissInstallBanner();
        });
    }
    
    function dismissInstallBanner() {
        const banner = document.getElementById('pwaInstallBanner');
        if (banner) banner.remove();
    }
    
    // iOS install hint (Safari не підтримує beforeinstallprompt)
    function checkIOSInstallHint() {
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        const isStandalone = window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone;
        const dismissed = localStorage.getItem('talko_ios_install_dismissed');
        
        if (isIOS && !isStandalone && !dismissed) {
            setTimeout(() => {
                const hint = document.createElement('div');
                hint.id = 'pwaInstallBanner';
                hint.innerHTML = `
                    <div style="position:fixed;bottom:70px;left:50%;transform:translateX(-50%);
                        background:linear-gradient(135deg,#1a1a1a,#2d2d2d);color:white;
                        padding:16px 20px;border-radius:16px;display:flex;flex-direction:column;gap:10px;
                        box-shadow:0 12px 40px rgba(0,0,0,0.4);z-index:10000;max-width:380px;width:calc(100% - 32px);
                        border:1px solid rgba(255,255,255,0.1);animation:slideUpBanner 0.3s ease;">
                        <div style="display:flex;align-items:center;gap:12px;">
                            <img src="icons/icon-96x96.png" style="width:40px;height:40px;border-radius:10px;">
                            <div style="flex:1;">
                                <div style="font-weight:600;font-size:0.95rem;">Встановити TALKO Tasks</div>
                            </div>
                            <button onclick="dismissIOSHint()" style="background:none;border:none;color:rgba(255,255,255,0.5);cursor:pointer;font-size:1.2rem;">✕</button>
                        </div>
                        <div style="font-size:0.85rem;color:rgba(255,255,255,0.8);line-height:1.5;">
                            Натисніть <span style="display:inline-flex;align-items:center;background:rgba(255,255,255,0.15);padding:2px 8px;border-radius:6px;margin:0 2px;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><path d="M4 12v8a2 2 0 002 2h12a2 2 0 002-2v-8"/><polyline points="16 6 12 2 8 6"/><line x1="12" y1="2" x2="12" y2="15"/></svg>
                            </span> → <b>На Гол. екран</b>
                        </div>
                    </div>
                `;
                document.body.appendChild(hint);
            }, 3000);
        }
    }
    
    function dismissIOSHint() {
        localStorage.setItem('talko_ios_install_dismissed', '1');
        dismissInstallBanner();
    }
    
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('sw.js').then(reg => {
                console.log('[SW] Registered:', reg.scope);
                // Перевірка оновлень кожні 30 хвилин
                setInterval(() => reg.update(), 30 * 60 * 1000);
            }).catch(err => {
                console.log('[SW] Registration skipped:', err.message);
            });
            
            checkIOSInstallHint();
        });
    }
    // =====================
    // FOCUS MODE - Конвеєрний режим виконання завдань
    // =====================
    const AI_TECH_LEAD_URL = 'https://chatgpt.com/g/g-685640bc592881918743da9332b83f31-ai-alex-talko-technical-lead';
    
    function getAiHelpUrl(taskTitle, taskDescription, taskFunction) {
        const prompt = encodeURIComponent(
            `Допоможи виконати завдання:\n` +
            `Назва: ${taskTitle || ''}\n` +
            `${taskFunction ? 'Функція: ' + taskFunction + '\n' : ''}` +
            `${taskDescription ? 'Інструкція: ' + taskDescription + '\n' : ''}` +
            `Поясни що потрібно зробити покроково.`
        );
        return AI_TECH_LEAD_URL + '?q=' + prompt;
    }
    
    function getAiHelpButton(taskTitle, taskDescription, taskFunction, size) {
        const url = getAiHelpUrl(taskTitle, taskDescription, taskFunction);
        if (size === 'small') {
            return `<a href="${url}" target="_blank" onclick="event.stopPropagation();" style="display:inline-flex;align-items:center;gap:4px;padding:3px 8px;background:#f0fdf4;border:1px solid #bbf7d0;border-radius:6px;font-size:0.7rem;color:#16a34a;text-decoration:none;white-space:nowrap;" title="Запитати AI">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>
                AI
            </a>`;
        }
        if (size === 'medium') {
            return `<a href="${url}" target="_blank" onclick="event.stopPropagation();" style="display:inline-flex;align-items:center;gap:6px;padding:6px 12px;background:#f0fdf4;border:1px solid #bbf7d0;border-radius:8px;font-size:0.8rem;color:#16a34a;text-decoration:none;font-weight:500;" title="Запитати AI-помічника">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>
                Не зрозуміло? Запитай AI
            </a>`;
        }
        // large - for focus mode
        return `<a href="${url}" target="_blank" onclick="event.stopPropagation();" style="display:flex;align-items:center;justify-content:center;gap:8px;padding:10px 16px;background:linear-gradient(135deg,#f0fdf4,#dcfce7);border:1px solid #bbf7d0;border-radius:12px;font-size:0.9rem;color:#16a34a;text-decoration:none;font-weight:600;margin-top:0.75rem;">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>
            Не зрозуміло? Запитай AI-помічника
        </a>`;
    }
    
    let focusTasks = [];
    let focusCurrentIndex = 0;
    let focusTimerInterval = null;
    let focusTimerSeconds = 0;
    let focusTimerRunning = false;
    
    function getFocusTasks() {
        const today = new Date();
        const todayStr = getLocalDateStr(today);
        const todayDay = today.getDay();
        const result = [];
        
        const funcByName = {};
        functions.forEach(f => { funcByName[f.name] = f; });
        
        const generatedTaskIndex = {};
        tasks.forEach(t => {
            if (t.regularTaskId && t.deadlineDate === todayStr && t.assigneeId === currentUser?.uid) {
                if (!generatedTaskIndex[t.regularTaskId]) generatedTaskIndex[t.regularTaskId] = t;
            }
        });
        
        // Разові
        tasks.filter(t => {
            if (t.assigneeId !== currentUser?.uid) return false;
            if (t.status === 'done' || t.status === 'review') return false;
            if (t.deadlineDate === todayStr) return true;
            if (t.deadlineDate < todayStr) return true;
            return false;
        }).forEach(t => {
            result.push({
                id: t.id,
                title: t.title,
                time: t.deadlineTime || '',
                description: t.description || t.instruction || '',
                function: t.function || '',
                estimatedTime: parseInt(t.estimatedTime || t.duration || '60'),
                type: 'task',
                processId: t.processId || null,
                processStep: t.processStep,
                priority: t.priority || 'medium',
                overdue: t.deadlineDate < todayStr,
                checklist: t.checklist || [],
                originalTask: t
            });
        });
        
        // Регулярні (не виконані)
        regularTasks.forEach(rt => {
            const func = funcByName[rt.function];
            if (!func || !func.assigneeIds?.includes(currentUser?.uid)) return;
            
            let isToday = false;
            if (rt.period === 'daily') isToday = true;
            else if (rt.period === 'weekly') {
                if (rt.daysOfWeek && Array.isArray(rt.daysOfWeek)) isToday = rt.daysOfWeek.includes(todayDay.toString());
                else if (rt.dayOfWeek) isToday = rt.dayOfWeek === todayDay.toString();
            } else if (rt.period === 'monthly') {
                const todayDate = today.getDate();
                isToday = rt.dayOfMonth === 'last' 
                    ? todayDate === new Date(today.getFullYear(), today.getMonth() + 1, 0).getDate()
                    : todayDate === parseInt(rt.dayOfMonth);
            }
            if (!isToday) return;
            
            const gen = generatedTaskIndex[rt.id];
            if (gen?.status === 'done' || gen?.status === 'review') return;
            
            result.push({
                id: rt.id,
                generatedTaskId: gen?.id || null,
                title: rt.title,
                time: rt.timeStart || rt.time || '',
                description: rt.instruction || rt.description || '',
                function: rt.function || '',
                estimatedTime: parseInt(rt.estimatedTime || rt.duration || '30'),
                type: 'regular',
                processId: null,
                priority: 'medium',
                overdue: false,
                checklist: [],
                originalTask: gen || rt
            });
        });
        
        // Сортування: прострочені → по часу
        result.sort((a, b) => {
            if (a.overdue !== b.overdue) return a.overdue ? -1 : 1;
            return (a.time || '99:99').localeCompare(b.time || '99:99');
        });
        
        return result;
    }
    
    function startFocusMode() {
        focusTasks = getFocusTasks();
        if (focusTasks.length === 0) {
            showToast(t('noTasksToday'), 'info');
            return;
        }
        focusCurrentIndex = 0;
        document.getElementById('focusModal').style.display = 'flex';
        document.body.style.overflow = 'hidden';
        renderFocusTask();
    }
    
    function closeFocusMode() {
        closeModal('focusModal');
        document.body.style.overflow = '';
        stopFocusTimer();
        renderMyDay();
    }
    
    function renderFocusTask() {
        const task = focusTasks[focusCurrentIndex];
        if (!task) {
            renderFocusComplete();
            return;
        }
        
        const total = focusTasks.length;
        const doneCount = focusCurrentIndex;
        const progressPercent = Math.round((doneCount / total) * 100);
        
        // Process badge
        let processBadge = '';
        if (task.processId) {
            const process = processes.find(p => p.id === task.processId);
            const template = process ? processTemplates.find(t => t.id === process.templateId) : null;
            if (process && template) {
                processBadge = `<div style="display:flex;align-items:center;gap:6px;padding:6px 12px;background:rgba(139,92,246,0.1);border-radius:8px;font-size:0.8rem;color:#7c3aed;">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="6" y1="3" x2="6" y2="15"/><circle cx="18" cy="6" r="3"/><circle cx="6" cy="18" r="3"/><path d="M18 9a9 9 0 0 1-9 9"/></svg>
                    ${esc(process.name)} — крок ${(task.processStep||0)+1}/${template.steps.length}
                </div>`;
            }
        }
        
        // Priority color
        const prioColors = { urgent: '#ef4444', high: '#f59e0b', medium: '#3b82f6', low: '#6b7280' };
        const prioNames = { urgent: 'Терміново', high: 'Високий', medium: 'Середній', low: 'Низький' };
        
        // Checklist
        let checklistHtml = '';
        if (task.checklist?.length > 0) {
            checklistHtml = `<div style="margin-top:1rem;">
                <div style="font-size:0.8rem;font-weight:600;color:#6b7280;margin-bottom:0.5rem;">Чеклист:</div>
                ${task.checklist.map((item, i) => `
                    <label style="display:flex;align-items:center;gap:8px;padding:8px 0;border-bottom:1px solid #f3f4f6;cursor:pointer;font-size:0.9rem;" onclick="event.stopPropagation();">
                        <input type="checkbox" ${item.done ? 'checked' : ''} onchange="toggleFocusChecklist(${i})" style="width:18px;height:18px;accent-color:#22c55e;">
                        <span style="${item.done ? 'text-decoration:line-through;color:#9ca3af;' : ''}">${esc(item.text || item.title || item)}</span>
                    </label>
                `).join('')}
            </div>`;
        }
        
        // Estimated time for timer
        const estMinutes = task.estimatedTime || 30;
        
        const container = document.getElementById('focusContent');
        container.innerHTML = `
            <!-- Progress bar -->
            <div style="padding:1rem 1.5rem 0;">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;">
                    <span style="font-size:0.8rem;color:#9ca3af;">Завдання ${doneCount + 1} з ${total}</span>
                    <span style="font-size:0.8rem;color:#9ca3af;">${progressPercent}%</span>
                </div>
                <div style="height:6px;background:#f3f4f6;border-radius:99px;overflow:hidden;">
                    <div style="height:100%;width:${progressPercent}%;background:linear-gradient(90deg,#22c55e,#16a34a);border-radius:99px;transition:width 0.5s ease;"></div>
                </div>
            </div>
            
            <!-- Task card -->
            <div style="padding:1.5rem;flex:1;overflow-y:auto;">
                <!-- Status badges -->
                <div style="display:flex;flex-wrap:wrap;gap:6px;margin-bottom:1rem;">
                    ${task.time ? `<div style="display:flex;align-items:center;gap:4px;padding:4px 10px;background:#f0fdf4;border-radius:8px;font-size:0.8rem;color:#16a34a;font-weight:500;">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
                        ${esc(task.time)}
                    </div>` : ''}
                    <div style="display:flex;align-items:center;gap:4px;padding:4px 10px;background:${prioColors[task.priority]}15;border-radius:8px;font-size:0.8rem;color:${prioColors[task.priority]};font-weight:500;">
                        ${prioNames[task.priority] || task.priority}
                    </div>
                    ${task.function ? `<div style="padding:4px 10px;background:#f3f4f6;border-radius:8px;font-size:0.8rem;color:#6b7280;">${esc(task.function)}</div>` : ''}
                    ${task.overdue ? `<div style="padding:4px 10px;background:#fef2f2;border-radius:8px;font-size:0.8rem;color:#ef4444;font-weight:600;"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align:-2px;"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg> Прострочено</div>` : ''}
                </div>
                
                ${processBadge}
                
                <!-- Title -->
                <h2 style="margin:1rem 0 0.5rem;font-size:1.4rem;font-weight:700;line-height:1.3;color:#1a1a1a;">${esc(task.title)}</h2>
                
                <!-- Timer -->
                <div style="display:flex;align-items:center;gap:1rem;margin:1.5rem 0;padding:1rem;background:#f9fafb;border-radius:12px;">
                    <div style="font-size:2rem;font-weight:700;font-variant-numeric:tabular-nums;color:#1a1a1a;letter-spacing:1px;" id="focusTimerDisplay">
                        ${String(Math.floor(estMinutes)).padStart(2,'0')}:00
                    </div>
                    <div style="display:flex;gap:0.5rem;">
                        <button onclick="toggleFocusTimer(${estMinutes})" id="focusTimerBtn" style="width:40px;height:40px;border:none;border-radius:50%;background:#22c55e;color:white;cursor:pointer;display:flex;align-items:center;justify-content:center;">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><polygon points="5 3 19 12 5 21 5 3"/></svg>
                        </button>
                        <button onclick="resetFocusTimer(${estMinutes})" style="width:40px;height:40px;border:none;border-radius:50%;background:#f3f4f6;color:#6b7280;cursor:pointer;display:flex;align-items:center;justify-content:center;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
                        </button>
                    </div>
                    <div style="font-size:0.75rem;color:#9ca3af;">
                        ~${estMinutes} хв
                    </div>
                </div>
                
                <!-- Description / Instruction -->
                ${task.description ? `
                    <div style="margin:1rem 0;padding:1rem;background:#fffbeb;border-radius:12px;border-left:4px solid #f59e0b;">
                        <div style="font-size:0.75rem;font-weight:600;color:#92400e;margin-bottom:0.5rem;text-transform:uppercase;letter-spacing:0.5px;"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align:-2px;"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/><rect x="8" y="2" width="8" height="4" rx="1" ry="1"/></svg> Інструкція</div>
                        <div style="font-size:0.9rem;color:#451a03;line-height:1.6;white-space:pre-line;">${esc(task.description)}</div>
                    </div>
                    ${getAiHelpButton(task.title, task.description, task.function, 'large')}
                ` : `
                    ${getAiHelpButton(task.title, '', task.function, 'large')}
                `}
                
                ${checklistHtml}
            </div>
            
            <!-- Action buttons - sticky bottom -->
            <div style="padding:1rem 1.5rem;border-top:1px solid #f3f4f6;background:white;display:flex;gap:0.75rem;">
                <button onclick="focusSkipTask()" style="flex:1;padding:1rem;border:2px solid #e5e7eb;border-radius:14px;background:white;font-size:0.95rem;font-weight:600;color:#6b7280;cursor:pointer;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align:-2px;"><polygon points="5 4 15 12 5 20 5 4"/><line x1="19" y1="5" x2="19" y2="19"/></svg> Пропустити
                </button>
                <button onclick="focusCompleteTask()" style="flex:2;padding:1rem;border:none;border-radius:14px;background:linear-gradient(135deg,#22c55e,#16a34a);font-size:1.05rem;font-weight:700;color:white;cursor:pointer;box-shadow:0 4px 14px rgba(34,197,94,0.4);">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" style="vertical-align:-3px;"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg> Виконано
                </button>
            </div>
        `;
        
        // Reset timer
        stopFocusTimer();
        focusTimerSeconds = estMinutes * 60;
        focusTimerRunning = false;
        updateFocusTimerDisplay();
    }
    
    function renderFocusComplete() {
        const total = focusTasks.length;
        const container = document.getElementById('focusContent');
        container.innerHTML = `
            <div style="flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:2rem;text-align:center;">
                <div style="width:80px;height:80px;background:#f0fdf4;border-radius:50%;display:flex;align-items:center;justify-content:center;margin-bottom:1.5rem;">
                    <svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="#22c55e" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>
                </div>
                <h2 style="margin:0 0 0.5rem;font-size:1.5rem;font-weight:700;">Всі завдання виконано!</h2>
                <p style="color:#6b7280;margin-bottom:2rem;">${total} завдань за сьогодні — чудова робота</p>
                <button onclick="closeFocusMode()" style="padding:1rem 3rem;border:none;border-radius:14px;background:linear-gradient(135deg,#22c55e,#16a34a);font-size:1rem;font-weight:700;color:white;cursor:pointer;">
                    Закрити
                </button>
            </div>
        `;
    }
    
    async function focusCompleteTask() {
        const task = focusTasks[focusCurrentIndex];
        if (!task) return;
        
        stopFocusTimer();
        
        // Анімація
        const content = document.getElementById('focusContent');
        content.style.opacity = '0.5';
        content.style.transform = 'translateX(-30px)';
        
        try {
            if (task.type === 'regular') {
                // Для регулярних — toggleMyDayTask логіка
                const todayStr = getLocalDateStr();
                
                if (task.generatedTaskId) {
                    await db.collection('companies').doc(currentCompany).collection('tasks').doc(task.generatedTaskId).update({
                        status: 'done',
                        completedAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    logTaskChange(task.generatedTaskId, 'complete', { status: 'done' }, { status: 'new' });
                    const local = tasks.find(t => t.id === task.generatedTaskId);
                    if (local) local.status = 'done';
                } else {
                    // Створюємо new task для regular
                    const rt = regularTasks.find(r => r.id === task.id);
                    const func = functions.find(f => f.name === rt?.function);
                    const headId = func?.headId || func?.assigneeIds?.[0] || currentUser.uid;
                    const head = users.find(u => u.id === headId);
                    
                    const ref = await db.collection('companies').doc(currentCompany).collection('tasks').add({
                        title: rt?.title || task.title,
                        function: rt?.function || '',
                        assigneeId: currentUser.uid,
                        assigneeName: currentUserData?.name || currentUser.email,
                        deadlineDate: todayStr,
                        deadlineTime: task.time || '18:00',
                        deadline: todayStr + 'T' + (task.time || '18:00'),
                        status: 'done',
                        priority: rt?.priority || 'medium',
                        pinned: false,
                        completedAt: firebase.firestore.FieldValue.serverTimestamp(),
                        regularTaskId: task.id,
                        autoGenerated: true,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                        createdDate: todayStr,
                        creatorId: currentUser.uid,
                        creatorName: t('systemUser')
                    });
                    tasks.unshift({ id: ref.id, status: 'done', regularTaskId: task.id, deadlineDate: todayStr, deadlineTime: task.time || '18:00', assigneeId: currentUser.uid, autoGenerated: true, createdDate: todayStr, createdAt: new Date() });
                }
            } else {
                // Разове завдання
                const needsReview = shouldSendForReview(task.originalTask);
                const newStatus = needsReview ? 'review' : 'done';
                
                await db.collection('companies').doc(currentCompany).collection('tasks').doc(task.id).update({
                    status: newStatus,
                    completedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                logTaskChange(task.id, 'complete', { status: newStatus }, { status: task.originalTask?.status || 'new' });
                
                const local = tasks.find(t => t.id === task.id);
                if (local) local.status = newStatus;
                
                // Автопросування процесу
                if (!needsReview) {
                    advanceProcessIfLinked(task.id);
                }
                // Автостатус проєкту
                if (task.projectId) autoUpdateProjectStatus(task.projectId);
                
                if (needsReview) {
                    showToast(t('sentForReview'), 'info');
                }
            }
        } catch (e) {
            console.error('focusComplete error:', e);
            showToast(t('error') + ': ' + e.message, 'error');
        }
        
        // Переходимо до наступного
        setTimeout(() => {
            focusCurrentIndex++;
            content.style.opacity = '1';
            content.style.transform = 'translateX(0)';
            renderFocusTask();
        }, 300);
    }
    
    function focusSkipTask() {
        stopFocusTimer();
        const content = document.getElementById('focusContent');
        content.style.opacity = '0.5';
        
        // Переміщуємо в кінець
        const skipped = focusTasks.splice(focusCurrentIndex, 1)[0];
        if (skipped) focusTasks.push(skipped);
        
        setTimeout(() => {
            content.style.opacity = '1';
            if (focusCurrentIndex >= focusTasks.length) focusCurrentIndex = 0;
            renderFocusTask();
        }, 200);
    }
    
    // Timer
    function toggleFocusTimer(estMinutes) {
        if (focusTimerRunning) {
            stopFocusTimer();
        } else {
            if (focusTimerSeconds <= 0) focusTimerSeconds = estMinutes * 60;
            focusTimerRunning = true;
            const btn = document.getElementById('focusTimerBtn');
            if (btn) btn.innerHTML = '<svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>';
            
            focusTimerInterval = setInterval(() => {
                focusTimerSeconds--;
                updateFocusTimerDisplay();
                if (focusTimerSeconds <= 0) {
                    stopFocusTimer();
                    // Vibrate + visual alert
                    if (navigator.vibrate) navigator.vibrate([200, 100, 200]);
                    const display = document.getElementById('focusTimerDisplay');
                    if (display) { display.style.color = '#ef4444'; display.textContent = '00:00'; }
                }
            }, 1000);
        }
    }
    
    function stopFocusTimer() {
        focusTimerRunning = false;
        if (focusTimerInterval) clearInterval(focusTimerInterval);
        focusTimerInterval = null;
        const btn = document.getElementById('focusTimerBtn');
        if (btn) btn.innerHTML = '<svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><polygon points="5 3 19 12 5 21 5 3"/></svg>';
    }
    
    function resetFocusTimer(estMinutes) {
        stopFocusTimer();
        focusTimerSeconds = estMinutes * 60;
        updateFocusTimerDisplay();
        const display = document.getElementById('focusTimerDisplay');
        if (display) display.style.color = '#1a1a1a';
    }
    
    function updateFocusTimerDisplay() {
        const display = document.getElementById('focusTimerDisplay');
        if (!display) return;
        const m = Math.floor(focusTimerSeconds / 60);
        const s = focusTimerSeconds % 60;
        display.textContent = `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    }
    
    function toggleFocusChecklist(index) {
        const task = focusTasks[focusCurrentIndex];
        if (!task?.checklist?.[index]) return;
        task.checklist[index].done = !task.checklist[index].done;
    }
    </script>
    
    <!-- Bottom Navigation for Mobile -->
    <nav class="bottom-nav" id="bottomNav">
        <div class="bottom-nav-items">
            <button class="bottom-nav-btn active" onclick="switchTab('myday')" data-tab="myday">
                <i data-lucide="sun" class="icon"></i>
                <span data-i18n="tabMyDay">Мій день</span>
            </button>
            <button class="bottom-nav-btn" onclick="switchTab('tasks')" data-tab="tasks" style="position:relative;">
                <i data-lucide="clipboard-list" class="icon"></i>
                <span id="overdueNavBadge" style="display:none;position:absolute;top:2px;right:12px;background:#ef4444;color:white;font-size:0.55rem;font-weight:700;min-width:16px;height:16px;border-radius:8px;align-items:center;justify-content:center;padding:0 4px;line-height:1;"></span>
                <span data-i18n="tabTasks">Завдання</span>
            </button>
            <button class="bottom-nav-btn" onclick="switchTab('control')" data-tab="control">
                <i data-lucide="layout-dashboard" class="icon"></i>
                <span data-i18n="tabControl">Контроль</span>
            </button>
            <button class="bottom-nav-btn" onclick="switchTab('regular')" data-tab="regular">
                <i data-lucide="repeat" class="icon"></i>
                <span data-i18n="tabRegular">Регулярні</span>
            </button>
            <button class="bottom-nav-btn" onclick="openMobileMenu()" data-tab="more">
                <i data-lucide="more-horizontal" class="icon"></i>
                <span>Ще</span>
            </button>
        </div>
    </nav>
    
    <!-- FAB for adding tasks -->
    <button class="fab-add" id="fabAdd">
        <i data-lucide="plus" class="icon"></i>
    </button>
    
    <!-- Mobile Filter Modal -->
    <div class="modal" id="filterModal">
        <div class="modal-content" style="max-width:400px;margin-top:auto;margin-bottom:0;border-radius:16px 16px 0 0;padding:0;">
            <div class="filter-modal-header">
                <h3><i data-lucide="sliders" class="icon icon-sm"></i> Фільтри</h3>
                <button onclick="closeFilterModal()" style="background:none;border:none;cursor:pointer;padding:0.5rem;">
                    <i data-lucide="x" class="icon"></i>
                </button>
            </div>
            
            <div class="filter-modal-content">
                <div class="filter-section">
                    <div class="filter-section-title">Тип завдань</div>
                    <div class="filter-chips" id="filterTypeChips">
                        <div class="filter-chip selected" data-value="" onclick="selectFilterChip(this, 'type')">Всі</div>
                        <div class="filter-chip" data-value="my" onclick="selectFilterChip(this, 'type')">Мої завдання</div>
                        <div class="filter-chip" data-value="created" onclick="selectFilterChip(this, 'type')">Створені мною</div>
                    </div>
                </div>
                
                <div class="filter-section">
                    <div class="filter-section-title">Дата</div>
                    <div class="filter-chips" id="filterDateChips">
                        <div class="filter-chip selected" data-value="" onclick="selectFilterChip(this, 'date')">Всі</div>
                        <div class="filter-chip" data-value="overdue" onclick="selectFilterChip(this, 'date')">Прострочені</div>
                        <div class="filter-chip" data-value="today" onclick="selectFilterChip(this, 'date')">Сьогодні</div>
                        <div class="filter-chip" data-value="week" onclick="selectFilterChip(this, 'date')">Цей тиждень</div>
                        <div class="filter-chip" data-value="month" onclick="selectFilterChip(this, 'date')">Цей місяць</div>
                    </div>
                </div>
                
                <div class="filter-section">
                    <div class="filter-section-title">Статус</div>
                    <div class="filter-chips" id="filterStatusChips">
                        <div class="filter-chip selected" data-value="" onclick="selectFilterChip(this, 'status')">Всі</div>
                        <div class="filter-chip" data-value="new" onclick="selectFilterChip(this, 'status')">Нові</div>
                        <div class="filter-chip" data-value="progress" onclick="selectFilterChip(this, 'status')">В роботі</div>
                        <div class="filter-chip" data-value="review" onclick="selectFilterChip(this, 'status')">Перевірка</div>
                        <div class="filter-chip" data-value="done" onclick="selectFilterChip(this, 'status')">Готово</div>
                    </div>
                </div>
                
                <div class="filter-section">
                    <div class="filter-section-title">Функція</div>
                    <div class="filter-chips" id="filterFunctionChips">
                        <div class="filter-chip selected" data-value="" onclick="selectFilterChip(this, 'function')">Всі</div>
                        <!-- Filled dynamically -->
                    </div>
                </div>
                
                <div class="filter-section">
                    <div class="filter-section-title">Виконавець</div>
                    <div class="filter-chips" id="filterAssigneeChips">
                        <div class="filter-chip selected" data-value="" onclick="selectFilterChip(this, 'assignee')">Всі</div>
                        <!-- Filled dynamically -->
                    </div>
                </div>
            </div>
            
            <div class="filter-modal-footer">
                <button class="btn" onclick="clearAllFilters()">
                    <i data-lucide="x" class="icon icon-sm"></i> Очистити
                </button>
                <button class="btn btn-success" onclick="applyFiltersAndClose()">
                    <i data-lucide="check" class="icon icon-sm"></i> Застосувати
                </button>
            </div>
        </div>
    </div>
    
    <!-- COMPLETION REPORT Modal -->
    <div id="completionReportModal" class="modal" onclick="if(event.target===this) closeCompletionReport(false);" style="z-index:10002;">
        <div class="modal-content" style="max-width:420px;border-radius:16px;padding:0;overflow:hidden;">
            <div style="padding:1.25rem 1.5rem;border-bottom:1px solid #f3f4f6;">
                <h3 style="margin:0;font-size:1rem;display:flex;align-items:center;gap:8px;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#22c55e" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>
                    Підтвердження виконання
                </h3>
            </div>
            <div style="padding:1.25rem 1.5rem;" id="completionReportBody">
                <!-- Filled by JS -->
            </div>
            <div style="padding:0.75rem 1.5rem 1.25rem;display:flex;gap:0.75rem;">
                <button onclick="closeCompletionReport(false)" class="btn" style="flex:1;">Скасувати</button>
                <button onclick="submitCompletionReport()" class="btn btn-success" style="flex:2;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align:-2px;"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>
                    Підтвердити
                </button>
            </div>
        </div>
    </div>

    <!-- NOTIFICATION PANEL -->
    <div id="notificationPanel" style="display:none;position:fixed;top:56px;right:12px;width:360px;max-width:calc(100vw - 24px);max-height:70vh;background:white;border-radius:16px;box-shadow:0 8px 30px rgba(0,0,0,0.15);z-index:10001;overflow:hidden;flex-direction:column;" onclick="event.stopPropagation();">
        <div style="display:flex;align-items:center;justify-content:space-between;padding:1rem 1.25rem;border-bottom:1px solid #f3f4f6;">
            <span style="font-weight:700;font-size:0.95rem;">Сповіщення</span>
            <div style="display:flex;gap:0.5rem;">
                <button onclick="markAllNotificationsRead()" style="border:none;background:none;font-size:0.75rem;color:#22c55e;cursor:pointer;font-weight:500;">Прочитати все</button>
                <button onclick="toggleNotificationPanel()" style="border:none;background:none;cursor:pointer;color:#9ca3af;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                </button>
            </div>
        </div>
        <div id="notificationList" style="overflow-y:auto;max-height:calc(70vh - 60px);padding:0.5rem 0;">
            <div style="text-align:center;color:#9ca3af;padding:2rem;font-size:0.85rem;">Немає сповіщень</div>
        </div>
    </div>

    <!-- FOCUS MODE Modal -->
    <div id="focusModal" style="display:none;position:fixed;inset:0;z-index:10000;background:white;flex-direction:column;" onclick="event.stopPropagation();">
        <!-- Header -->
        <div style="display:flex;align-items:center;justify-content:space-between;padding:0.75rem 1.25rem;border-bottom:1px solid #f3f4f6;background:white;">
            <div style="display:flex;align-items:center;gap:0.5rem;">
                <div style="width:8px;height:8px;background:#22c55e;border-radius:50%;animation:focusPulse 2s infinite;"></div>
                <span style="font-weight:700;font-size:0.95rem;color:#1a1a1a;">Режим фокусу</span>
            </div>
            <button onclick="closeFocusMode()" style="width:36px;height:36px;border:none;border-radius:50%;background:#f3f4f6;cursor:pointer;display:flex;align-items:center;justify-content:center;">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#6b7280" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
            </button>
        </div>
        <!-- Content (rendered by JS) -->
        <div id="focusContent" style="flex:1;display:flex;flex-direction:column;overflow:hidden;transition:all 0.3s ease;">
        </div>
    </div>
    <style>
        @keyframes focusPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }
    </style>

    <!-- Mobile More Menu Modal -->
    <div class="modal" id="mobileMenuModal" onclick="if(event.target === this) closeMobileMenu();">
        <div class="modal-content" style="max-width:100%;margin-top:auto;margin-bottom:0;border-radius:20px 20px 0 0;padding:0;min-height:auto;">
            <!-- Handle bar -->
            <div style="display:flex;justify-content:center;padding:0.75rem 0 0.5rem;">
                <div style="width:40px;height:4px;background:#ddd;border-radius:4px;"></div>
            </div>
            
            <div style="padding:0 1.25rem 1.25rem;">
                <!-- AI Assistants - top -->
                <div style="display:flex;gap:0.5rem;margin-bottom:0.5rem;">
                    <a href="https://chatgpt.com/g/g-684bb075301481918669f787231e1af7-radar-ai-alex-talko" target="_blank" class="btn" style="flex:1;justify-content:center;background:#8b5cf6;color:white;font-size:0.8rem;padding:0.6rem;" onclick="closeMobileMenu();">
                        <i data-lucide="target" class="icon icon-sm"></i> Керівник
                    </a>
                    <a href="https://chatgpt.com/g/g-685640bc592881918743da9332b83f31-ai-alex-talko-technical-lead" target="_blank" class="btn" style="flex:1;justify-content:center;background:#22c55e;color:white;font-size:0.8rem;padding:0.6rem;" onclick="closeMobileMenu();">
                        <i data-lucide="wrench" class="icon icon-sm"></i> Технічний
                    </a>
                </div>
                <a href="https://chatgpt.com/g/g-69382bfa841881918aff7b50aa25a4f9-talko-task-manager-support" target="_blank" class="btn" style="justify-content:center;background:#3b82f6;color:white;font-size:0.8rem;padding:0.6rem;margin-bottom:0.75rem;width:100%;" onclick="closeMobileMenu();">
                    <i data-lucide="message-circle" class="icon icon-sm"></i> Підтримка
                </a>
                
                <hr style="border:none;border-top:1px solid #f0f0f0;margin:0 0 0.75rem;">
                
                <!-- Navigation grid -->
                <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:0.4rem;margin-bottom:0.75rem;">
                    <button class="btn" onclick="switchTab('control');closeMobileMenu();" style="justify-content:center;padding:0.6rem;font-size:0.75rem;flex-direction:column;gap:2px;">
                        <i data-lucide="layout-dashboard" class="icon icon-sm"></i> Контроль
                    </button>
                    <button class="btn" onclick="switchTab('regular');closeMobileMenu();" style="justify-content:center;padding:0.6rem;font-size:0.75rem;flex-direction:column;gap:2px;">
                        <i data-lucide="repeat" class="icon icon-sm"></i> Регулярні
                    </button>
                    <button class="btn" onclick="switchTab('processes');closeMobileMenu();" style="justify-content:center;padding:0.6rem;font-size:0.75rem;flex-direction:column;gap:2px;">
                        <i data-lucide="git-branch" class="icon icon-sm"></i> Процеси
                    </button>
                    <button class="btn" onclick="switchTab('projects');closeMobileMenu();" style="justify-content:center;padding:0.6rem;font-size:0.75rem;flex-direction:column;gap:2px;">
                        <i data-lucide="folder-kanban" class="icon icon-sm"></i> Проєкти
                    </button>
                    <button class="btn" onclick="switchTab('functions');closeMobileMenu();" style="justify-content:center;padding:0.6rem;font-size:0.75rem;flex-direction:column;gap:2px;">
                        <i data-lucide="settings" class="icon icon-sm"></i> Функції
                    </button>
                    <button class="btn" onclick="switchTab('analytics');closeMobileMenu();" style="justify-content:center;padding:0.6rem;font-size:0.75rem;flex-direction:column;gap:2px;">
                        <i data-lucide="bar-chart-3" class="icon icon-sm"></i> Аналітика
                    </button>
                </div>
                
                <!-- Settings row -->
                <div style="display:flex;gap:0.5rem;margin-bottom:0.5rem;">
                    <button class="btn" onclick="openProfileModal();closeMobileMenu();" style="flex:1;justify-content:center;padding:0.6rem;font-size:0.8rem;">
                        <i data-lucide="user" class="icon icon-sm"></i> Профіль
                    </button>
                    <button id="notificationToggleBtn" class="btn btn-success" onclick="toggleNotifications();closeMobileMenu();" style="flex:1;justify-content:center;padding:0.6rem;font-size:0.8rem;">
                        <i data-lucide="bell" class="icon icon-sm"></i> Сповіщення
                    </button>
                </div>
                
                <!-- Language -->
                <div style="display:flex;gap:0.5rem;margin-bottom:0.5rem;">
                    <button class="btn" onclick="setLanguage('ua');closeMobileMenu();" style="flex:1;justify-content:center;padding:0.5rem;font-size:0.8rem;" id="mLangUA">UA</button>
                    <button class="btn" onclick="setLanguage('ru');closeMobileMenu();" style="flex:1;justify-content:center;padding:0.5rem;font-size:0.8rem;" id="mLangRU">RU</button>
                    <button class="btn" onclick="setLanguage('pl');closeMobileMenu();" style="flex:1;justify-content:center;padding:0.5rem;font-size:0.8rem;" id="mLangPL">PL</button>
                </div>
                
                <!-- SuperAdmin: Demo data -->
                <button class="btn" onclick="openDemoDataModal();closeMobileMenu();" style="justify-content:center;width:100%;padding:0.6rem;font-size:0.8rem;background:#fef2f2;color:#dc2626;border:1px solid #fecaca;margin-bottom:0.5rem;" id="demoDataBtn">
                    <i data-lucide="database" class="icon icon-sm"></i> Демо-дані / Очистити
                </button>
                
                <!-- Logout -->
                <button class="btn btn-danger" onclick="if(confirm(t('logoutConfirm'))){auth.signOut();closeMobileMenu();}" style="justify-content:center;width:100%;padding:0.6rem;font-size:0.85rem;">
                    <i data-lucide="log-out" class="icon icon-sm"></i> Вийти
                </button>
            </div>
        </div>
    </div>
    
    <!-- Demo Data Modal -->
    <div class="modal" id="demoDataModal">
        <div class="modal-content" style="max-width:450px;">
            <div class="modal-header">
                <h3><i data-lucide="database" class="icon"></i> Завантажити демо-дані</h3>
                <button class="close-btn" onclick="closeDemoDataModal()">&times;</button>
            </div>
            <div style="padding:1.5rem;">
                <p style="color:#666;margin-bottom:1.5rem;font-size:0.9rem;">
                    Оберіть тип бізнесу для завантаження демо-даних. Буде створено функції, регулярні завдання та приклади задач.
                </p>
                
                <div style="display:flex;flex-direction:column;gap:1rem;">
                    <button class="demo-option-btn" onclick="loadDemoData('clinic')">
                        <div class="demo-option-icon" style="background:#ecfdf5;color:#10b981;">
                            <i data-lucide="heart-pulse" class="icon icon-lg"></i>
                        </div>
                        <div class="demo-option-info">
                            <strong>Медична клініка</strong>
                            <span>Стоматологія, приватна практика, медцентр</span>
                        </div>
                        <i data-lucide="chevron-right" class="icon"></i>
                    </button>
                    
                    <button class="demo-option-btn" onclick="loadDemoData('manufacturing')">
                        <div class="demo-option-icon" style="background:#fef3c7;color:#f59e0b;">
                            <i data-lucide="factory" class="icon icon-lg"></i>
                        </div>
                        <div class="demo-option-info">
                            <strong>Виробництво</strong>
                            <span>Завод, цех, виробнича компанія</span>
                        </div>
                        <i data-lucide="chevron-right" class="icon"></i>
                    </button>
                </div>
                
                <div style="margin-top:1.5rem;padding:1rem;background:#fef2f2;border-radius:8px;font-size:0.85rem;color:#991b1b;">
                    <i data-lucide="alert-triangle" class="icon icon-sm" style="vertical-align:middle;margin-right:0.25rem;"></i>
                    Увага: демо-дані будуть додані до існуючих даних компанії.
                </div>
                
                <div style="margin-top:1rem;border-top:1px solid #e5e7eb;padding-top:1rem;">
                    <button class="btn btn-danger" onclick="clearAllCompanyData()" style="width:100%;">
                        <i data-lucide="trash-2" class="icon"></i> Очистити ВСІ дані компанії
                    </button>
                    <p style="font-size:0.75rem;color:#999;text-align:center;margin-top:0.5rem;">Видалить завдання, функції, процеси, проєкти, регулярні — все крім користувачів</p>
                </div>
            </div>
        </div>
    </div>
    
    
    <style>
        /* Tab swipe indicator */
        .tab-swipe-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            color: var(--success);
            opacity: 0.8;
            pointer-events: none;
            animation: fadeOut 0.3s forwards;
            z-index: 9999;
        }
        
        @keyframes fadeOut {
            to { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
        }
        
        @keyframes slideUpBanner {
            from { opacity: 0; transform: translateX(-50%) translateY(30px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
        
        /* Offline indicator */
        .offline-indicator {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%) translateY(-100%);
            background: #ff9800;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            z-index: 9998;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            transition: transform 0.3s;
        }
        
        .offline-indicator.show {
            transform: translateX(-50%) translateY(0);
        }
        
        /* Undo Toast */
        .undo-toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: white;
            padding: 16px 24px;
            border-radius: 16px;
            display: flex;
            align-items: center;
            gap: 20px;
            box-shadow: 0 12px 40px rgba(0,0,0,0.4);
            z-index: 10001;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s, visibility 0.3s;
            max-width: 500px;
            width: calc(100% - 32px);
            border: 1px solid rgba(255,255,255,0.1);
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }
        
        .undo-toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }
        
        .undo-toast .toast-icon {
            width: 40px;
            height: 40px;
            background: rgba(239, 68, 68, 0.2);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .undo-toast .toast-icon svg {
            width: 20px;
            height: 20px;
            stroke: #ef4444;
        }
        
        .undo-toast .toast-content {
            flex: 1;
            min-width: 0;
        }
        
        .undo-toast .toast-title {
            font-size: 0.95rem;
            font-weight: 600;
            margin-bottom: 2px;
        }
        
        .undo-toast .toast-message {
            font-size: 0.8rem;
            color: rgba(255,255,255,0.7);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .undo-toast .undo-btn {
            background: #22c55e;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        .undo-toast .undo-btn:hover {
            background: #16a34a;
            transform: scale(1.05);
        }
        
        .undo-toast .toast-timer {
            width: 100%;
            height: 4px;
            background: rgba(255,255,255,0.1);
            position: absolute;
            bottom: 0;
            left: 0;
            border-radius: 0 0 16px 16px;
            overflow: hidden;
        }
        
        .undo-toast .toast-timer-bar {
            height: 100%;
            background: linear-gradient(90deg, #22c55e, #16a34a);
            transition: width 0.1s linear;
        }
        
        @media (max-width: 500px) {
            .undo-toast {
                bottom: 80px;
                padding: 14px 16px;
                gap: 12px;
            }
            .undo-toast .toast-icon {
                width: 36px;
                height: 36px;
            }
            .undo-toast .undo-btn {
                padding: 8px 14px;
                font-size: 0.85rem;
            }
        }
    </style>
    
    <!-- Undo Toast -->
    <div id="undoToast" class="undo-toast">
        <div class="toast-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
            </svg>
        </div>
        <div class="toast-content">
            <div class="toast-title">Видалено</div>
            <div class="toast-message" id="undoMessage">Завдання</div>
        </div>
        <button class="undo-btn" onclick="undoDelete()">Відмінити</button>
        <div class="toast-timer"><div class="toast-timer-bar" id="undoTimerBar"></div></div>
    </div>
    
</body>
</html>
